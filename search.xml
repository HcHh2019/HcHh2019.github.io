<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="posts/0.html"/>
      <url>posts/0.html</url>
      
        <content type="html"><![CDATA[for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)   }   // 会输出 0、1、2、3、4 ]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/85be.html"/>
      <url>posts/85be.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript变量是松散类型的，意思是可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有三个关键字可以声明变量：var、const、let。其中，var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更高版本中使用。</p><hr><h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>要定义变量可以用操作符var，后跟变量名。<br>var message;</p><p>变量可以保存任何类型的值。不初始会保存一个特殊值undefined。</p><hr><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用var操作符定义的变量会成为包含它的函数的局部变量。比如使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过，在函数内部定义变量时省略var操作符，可以创建一个全局变量，只要调用一次函数，可以在函数外部引用: (不推荐这么做:省略var)</p><pre><code>            function test(){                message="hi";   //全局变量            }            test();            console.log(message); </code></pre><hr><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let跟var的作用差不多，但有个明显区别，var声明的范围是函数作用域，而let声明的范围是块作用域</p><pre><code>    if(true){        var name = 'M';        console.log(name); // M    }    console.log(name); // M    if(true){        let age = 'A';        console.log(age); // A    }    console.log(age); // 未定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也试用let</p><p>let也不允许同一个块作用域中出现重复声明</p><pre><code>    var name;    var name;    let age;    let age; //标识符age已经声明过了</code></pre><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><pre><code>    var name;    let name; // 错误    let age;    var age; // 错误 </code></pre><hr><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><pre><code>    var name="M";    console.log(name); // M    console.log(name02); //undefined    var name02="M";     console.log(name02); //报错    let name02="M"; </code></pre><hr><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><pre><code>    var name = 'Matt';    console.log(window.name); // 'Matt'    let age = 26;    console.log(window.age); // undefined </code></pre><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><hr><h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {    // 循环逻辑    }    console.log(i); // 5</code></pre><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    // 循环逻辑    }     console.log(i); // ReferenceError: i 没有定义</code></pre><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {        setTimeout(() =&gt; console.log(i), 0)    }</code></pre><p>// 你可能以为会输出 0、1、2、3、4<br>// 实际上会输出 5、5、5、5、5 </p><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)    }    // 会输出 0、1、2、3、4 </code></pre><hr><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/14a5.html"/>
      <url>posts/14a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><hr><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>首先要知道,<strong>ECMAScript</strong>中一切都区分大小写。无论是<strong>变量</strong>、<strong>函数名</strong>还是<strong>操作符</strong>。换句话说<strong>变量test</strong>和<strong>变量Test</strong>是俩个不同的变量。类似的，<strong>typeof</strong>不能作为函数名，因为它是一个<strong>关键字</strong>。但是<strong>Typeof</strong>是一个完全有效的函数名。</p><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓<strong>标识符</strong>，就是<strong>变量</strong>、<strong>函数</strong>、<strong>属性</strong>或<strong>函数参数</strong>的名称。标识符可以由一或多个下列字符组成：</p><ol><li><p>第一个字符必须是一个<strong>字母</strong>、<strong>下划线</strong>(_)或<strong>美元符号</strong>($);</p></li><li><p>剩下的其他字符可以是<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>或<strong>数字</strong>。</p></li></ol><p>按照惯例，标识符使用<strong>驼峰大小写</strong>形式，即第一个单词首字母小写，后面每个单词的首字母大写。</p><p><strong>注意</strong> 关键字、保留字、true、false和null不能作为标识符。</p><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript采用C语言风格的注释，包括单行注释和块注释。</p><p>单行注释以俩个斜杠字符开头， // 单行注释</p><p>块注释以一个斜杠和一个星号开头，以它们的反向组合结尾， /* 块注释 */</p><hr><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript5增加了严格模式的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><p><code>"use strict"</code></p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p><pre><code>        function doSomething(){            "use strict";            //函数体        }</code></pre><p>所有现代浏览器都支持严格模式</p><hr><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMASCript中语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><pre><code>        let sum = a + b   //没有分号也有效，但不推荐        let diff = a - b; //加分号有效，推荐</code></pre><p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号({)开始，右花括号(})结束。</p><p>if之类的控制语句只在执行多条语句要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即便只有一条语句。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="posts/c06f.html"/>
      <url>posts/c06f.html</url>
      
        <content type="html"><![CDATA[<p>网址在这里:</p><p>版本0.5:<br><a href="https://yanyanzio.top/Project/One/YYZMusic">https://yanyanzio.top/Project/One/YYZMusic</a></p><p>要源码可以联系我,有QQ</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗忘的HTML&amp;&amp;CSS</title>
      <link href="posts/e31c.html"/>
      <url>posts/e31c.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS溢出属性-overflow"><a href="#CSS溢出属性-overflow" class="headerlink" title="CSS溢出属性 overflow"></a>CSS溢出属性 overflow</h3><p>该overflow属性指定如果内容溢出元素框会发生什么情况。</p><p>此属性指定在元素的内容太大而无法放入指定区域时是剪辑内容还是添加滚动条。</p><p>/* 默认值。内容不会被修剪，会呈现在元素框之外 */<br>overflow: visible;</p><p>/* 内容会被修剪，并且其余内容不可见 */<br>overflow: hidden;</p><p>/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */<br>overflow: scroll;</p><p>/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */<br>overflow: auto;</p><p>/* 规定从父元素继承overflow属性的值 */<br>overflow: inherit;</p><hr><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。 </p><p>border 和 outline<br>border 和 outline 很类似，但有如下区别：</p><p>outline不占据空间，绘制于元素内容周围。<br>根据规范，outline通常是矩形，但也可以是非矩形的。</p><p>&lt;’outline-color’&gt;<br>设置轮廓的颜色。没有设置时默认值为 currentcolor。<br>&lt;’outline-style’&gt;<br>设置轮廓的样式。没有设置时默认值为 none。<br>&lt;’outline-width’&gt;<br>设置轮廓的宽度。没有设置时默认值为 medium</p><p>outline:none; 取消选中边框</p><hr><h3 id="选择器-交集选择器"><a href="#选择器-交集选择器" class="headerlink" title="选择器: 交集选择器"></a>选择器: 交集选择器</h3><p>我主要用在绑定一个标签, 如: .Old.Xin  有一个源 <code>&lt;div class="Old"&gt;&lt;/div&gt;</code></p><p>想要在这个<strong>div</strong>中添加一个新的类,即<code>&lt;div class="Old Xin"&gt;&lt;/div&gt;</code></p><p>就用 <strong>.Old.Xin</strong> 交集选择器</p><hr><h3 id="webkit-scrollbar-滚轮样式"><a href="#webkit-scrollbar-滚轮样式" class="headerlink" title="::-webkit-scrollbar 滚轮样式"></a>::-webkit-scrollbar 滚轮样式</h3><p>::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样</p><p>::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分</p><hr><h3 id="img的边框"><a href="#img的边框" class="headerlink" title="img的边框"></a>img的边框</h3><ol><li><code>&lt;img&gt;</code> 标签的 border 属性规定图像周围的边框的宽度</li></ol><p><code>border: none;</code> // css属性</p><ol start="2"><li><p>当img没有接收到src属性的时候会自动出现边框，border:0/none都不管用的情况下，解决方法：</p><pre><code> img[src=""],img:not([src]){     opacity:0; }</code></pre></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="posts/e0b8.html"/>
      <url>posts/e0b8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js是一套构建用户界面的渐进式框架</p><p>Vue.js 只关注视图层， 设计时采用自底向上渐进式开发的构架，核心部件只关注用户界面的构建</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p><p><strong>注意</strong>： Vue.js 不支持 IE8 及其以下 IE 版本</p><h3 id="为什么要使用Vue"><a href="#为什么要使用Vue" class="headerlink" title="为什么要使用Vue"></a>为什么要使用Vue</h3><p>1.轻量级,体积小是一个重要指标,Vue.Js压缩后只有20多KB<br>2.移动优先,更适合移动端,比如移动端的Touch事件<br>3.易上手,学习曲线平稳,文档齐全<br>4.吸收了Angular(模块化)和React(虚拟DOM的长处),并拥有自己独特的功能<br>5.开源,社区活跃度高<br>…</p><h3 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h3><p>在我们继续学习 Vue.js 2 之前，希望对以下知识有一定的了解<br><strong>HTML</strong><br><strong>CSS</strong><br><strong>JavaScript</strong></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><strong>Vue.js</strong> 是一个 <strong>JavaScript</strong> 脚本库，所以安装起来非常简单，只要引用 <strong>vue.min.js</strong> 脚本就可以了</p><p>可以在 Vue.js 的官网上直接下载 vue.min.js 然后使用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li><p><strong>安装 cnpm</strong><br><code>npm install --global cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p><strong>全局安装 vue-cli</strong><br><code>$ cnpm install --global vue-cli</code></p></li><li><p><strong>创建一个基于 webpack 模板的新项目</strong><br><code>$ vue init webpack yyzvue</code></p></li><li><p>这里需要你进行一些配置，如果不想更改，可以直接回车</p></li></ol><p><code>$ vue init webpack yyzvue</code>  </p><p><code>? Project name yyzvue</code><br><code>? Project description A Vue.js project</code><br><code>? Author sense &lt;yu.fei@gmail.com&gt;</code><br><code>? Vue build standalone</code><br><code>? Install vue-router? Yes</code><br><code>? Use ESLint to lint your code? Yes</code><br><code>? Pick an ESLint preset Standard</code><br><code>? Set up unit tests Yes</code><br><code>? Pick a test runner jest</code><br><code>? Setup e2e tests with Nightwatch? Yes</code></p><p>   <code>vue-cli · Generated "webapp".</code></p><p>   <code>To get started:</code><br>     <code>cd webapp</code><br>     <code>npm install</code><br>     <code>npm run dev</code><br>   <code>Documentation can be found at https://vuejs-templates.github.io/webpack</code></p><ol start="3"><li>安装依赖并运行<br>配置配置完成后，可以进入项目，然后执行以下命令</li></ol><p><code>$ cd webapp</code><br><code>$ cnpm install</code><br>先去喝杯茶，然后调戏小孩，再回来看看是否安装好了…</p><p><code>$ npm run dev</code></p><p> <code>DONE  Compiled successfully in </code></p><p> <code>I  Your application is running here: http://localhost:8080</code></p><p> 成功执行以上命令后访问 <a href="http://localhost:8080/%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">http://localhost:8080/，输出结果如下所示</a></p><p> <img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_1.png"></p><hr><h2 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h2><p>上一章节中，我们使用 vue-cli 工具创建了一个 webapp 的项目</p><p>如果我们使用 IDE（Eclipse、Atom）打开该目录，显示目录结构如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_2.png"></p><h3 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h3><table><thead><tr><th align="left">目录/文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">build</td><td align="left">最终发布的代码存放位置</td></tr><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的</td></tr><tr><td align="left">node_modules</td><td align="left">npm 加载的项目依赖模块</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里里面包含了几个目录及文件assets: 放置一些图片，如logo等components: 目录里面放了一个组件文件，可以不用App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录main.js: 项目的核心文件</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">.xxxx文件</td><td align="left">这些是一些配置文件，包括语法配置，git配置等</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或同统计代码啥的</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><h3 id="用vue写一个hello-word"><a href="#用vue写一个hello-word" class="headerlink" title="用vue写一个hello word"></a>用vue写一个hello word</h3><p>代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id="app"&gt;        {{message}}    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_3.png"></p><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>&lt;div id="app_01"&gt;    {{mes+'!'}}    &lt;h2 v-text="mes+'!'"&gt;iii&lt;/h2&gt;    &lt;h2&gt;hah{{mes}}iii&lt;/h2&gt;&lt;/div&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>    &lt;div id="app_01"&gt;    &lt;span v-text="mes"&gt;&lt;/span&gt;    &lt;span v-html="mes"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm= new Vue({        el: '#app_01' ,        data:{            mes: '&lt;p style="color:red;font-size:30px;"&gt;言言子&lt;/p&gt;'        }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>设置元素属性值,如: v-bind:src=”imgSrc”,v-bind:title=”arcTit”<br>其中 v-bind 可以省略</p><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-bind:title="message"&gt;HHHHH&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>当把鼠标放到<strong>HHHHH</strong>上时,鼠标下会有个标记</p><p>你看到的 <strong>v-bind</strong> 等被称为标记,指令带有前缀<strong>v-</strong>,以示他们是<strong>Vue</strong>提供的特殊特性</p><p>他们会在渲染的<strong>DOM</strong>上应用特殊的响应式行为。在这里,指令的意思为：将这个元素节点的<strong>title</strong></p><p>特性和<strong>Vue</strong>实例的<strong>message</strong>属性保持一致。</p><p>如果打开浏览器的控制台，输入<code>vue.message="哦哦哦哦哦"</code>,就会看到绑定了<strong>title</strong>特性的HTML</p><p>已经进行了更新</p><h3 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h3><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok"&gt;YES&lt;/span&gt;        &lt;span v-else&gt;NONONO&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: true            }        } );    &lt;/script&gt;&lt;/body&gt;&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok==='A'"&gt;这是A&lt;/span&gt;        &lt;span v-else-if="ok==='B'"&gt;这是B&lt;/span&gt;        &lt;span v-else&gt;啥也不是&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: 'A'            }        } );    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>&lt;div id="app"&gt;        &lt;p v-for="item in items"&gt;            {{item.message}}        &lt;/p&gt;&lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: "#app",            data: {                items: [                    {message: '言言子好可爱!'},                    {message: '言言子好萌!'}                ]            }        });    &lt;/script&gt;</code></pre><p>在控制台里，输入 vm.items.push({ message: ‘芜湖！好耶！’ })，你会发现列表最后添加了一个新项目</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><pre><code>&lt;div id="app_01"&gt;    &lt;p @click="func"&gt;{{message}}&lt;/p&gt;    &lt;input type="button" value="事件绑定-点击" v-on:click="func"&gt;    &lt;input type="button" value="事件绑定-点击" @click="func"&gt;    &lt;input type="button" value="事件绑定-" v-on:monseenter="func"&gt;    &lt;input type="button" value="事件绑定-双击" v-on:dblclick="func"&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app_01",            data: {                message: "ABC"            },            methods: {                func() {                    this.message = this.message.split('').reverse().join('');                }            }    }); &lt;/script&gt;</code></pre><p><strong>split() 方法用于把一个字符串分割成字符串数组</strong><br><strong>reverse() 方法用于颠倒数组中元素的顺序</strong><br><strong>join() 方法用于把数组中的所有元素放入一个字符串</strong></p><p>注意在 <strong>reverseMessage</strong> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><h3 id="用Vue做简单计数器"><a href="#用Vue做简单计数器" class="headerlink" title="用Vue做简单计数器"></a>用Vue做简单计数器</h3><pre><code>    &lt;div id="app"&gt;    &lt;button @click="add"&gt;+&lt;/button&gt;    &lt;span&gt;{{num}}&lt;/span&gt;    &lt;button @click="jian"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app",            data: {                num: 0            },            methods: {                add(){                    if(this.num&lt;10){                        this.num+=1;                    }else{                        alert("最大为10!");                    }                },                jian(){                    if(this.num&gt;0){                        this.num-=1;                    }else{                        alert("最小为0!");                    }                }            }    });&lt;/script&gt;</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达式的真假切换元素的显示和隐藏</p><pre><code>&lt;div id="app"&gt;    &lt;button @click="q"&gt;点击隐藏图片&lt;/button&gt;    &lt;img src="./1.jpg" v-show="isShow"&gt;    &lt;img src="./1.jpg" v-if="isShow"&gt;    &lt;img src="./1.jpg" v-show="age&gt;20"&gt;&lt;/div&gt;&lt;script&gt;    var vm =new Vue({        el: "#app",    data: {            isShow: true,            age: 18    },    methods: {            q(){                this.isShow= !this.isShow;            }    }    });&lt;/script&gt;</code></pre><p>频繁切换的元素用 <strong>v-show</strong>,反之用 <strong>v-if</strong></p><p>因为操作DOM数对性能的消耗比较大(<strong>v-if</strong>)</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue 还提供了 <strong>v-model</strong> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><pre><code>&lt;div id="app-6"&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单</p><pre><code>&lt;div class="app"&gt;    &lt;yan&gt;&lt;/yan&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个Vue组件    Vue.component('yan',{        template: '&lt;p&gt;言言子努力加油&lt;/p&gt;'    })     var vm= new Vue({         el: "#app"     }); &lt;/script&gt;</code></pre><h3 id="用Vue切换图片"><a href="#用Vue切换图片" class="headerlink" title="用Vue切换图片"></a>用Vue切换图片</h3><pre><code>&lt;div id="app"&gt;    &lt;div&gt;            &lt;img :src="img[index]" alt=""&gt;            &lt;a href="##" @click="sub" v-show="index!=0"&gt;&lt;&lt;/a&gt;            &lt;a href="##" @click="add" v-show="index&lt;img.length-1"&gt;&gt;&lt;/a&gt;        &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: '#app',        data:{                img: ['./1.jpg','./2.jpg','./3.png'],                index: 0        },        methods:{            add(){                    this.index++;            },            sub(){                    this.index--;            }        }    });&lt;/script&gt;</code></pre><h3 id="用Vue做一个记录本功能"><a href="#用Vue做一个记录本功能" class="headerlink" title="用Vue做一个记录本功能"></a>用Vue做一个记录本功能</h3><pre><code>&lt;div id="app"&gt;    &lt;header&gt;        &lt;h1&gt;记事本&lt;/h1&gt;        &lt;input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;ul&gt;            &lt;li v-for="(item,index) in arr"&gt;                &lt;div&gt;                    &lt;span&gt;{{index+1}}.&lt;/span&gt;                    &lt;label&gt;{{item}}&lt;/label&gt;                    &lt;button @click="sub(index)"&gt;&lt;/button&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;footer v-show="arr.length!=0" &gt;        &lt;span&gt;            &lt;strong  &gt;{{arr.length}}&lt;/strong&gt;        &lt;/span&gt;        &lt;button @click="clear"&gt;Clear&lt;/button&gt;    &lt;/footer&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: "#app",        data: {            arr: [                "ABC",                "QWE",                "ZXC"            ],            inputValue: ""        },        methods: {            add(){                this.arr.push(this.inputValue);            },            sub(index){                this.arr.splice(index,1);            },            clear(){                this.arr= []            }        }    });&lt;/script&gt;</code></pre><hr><h2 id="AXIOS的基本使用-实例"><a href="#AXIOS的基本使用-实例" class="headerlink" title="AXIOS的基本使用(实例)"></a>AXIOS的基本使用(实例)</h2><pre><code>&lt;input type="button"  id="get" value="get请求"&gt;&lt;input type="button" id="post" value="post请求"&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script&gt;    document.querySelector("#get").onclick= function(){        axios.get("https://autumnfish.cn/api/joke/listsadsad?num=1")        .then(function (response){            console.log(response);        },function(err){            console.log(err);        })    }    document.querySelector("#post").onclick=function(){        axios.post("https://autumnfish.cn/api/user/reg",        {username: "言言子"})        .then(function(re){            console.log(re);        },function(err){            console.log(err);        })    }&lt;/script&gt;</code></pre><h3 id="AXIOS-Vue-获取笑话"><a href="#AXIOS-Vue-获取笑话" class="headerlink" title="AXIOS+Vue:获取笑话"></a>AXIOS+Vue:获取笑话</h3><pre><code>&lt;div id="app"&gt;    &lt;input type="button" value="获取笑话" @click="getJoke"&gt;    &lt;p&gt;{{Joke}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm=new Vue({        el: "#app",        data: {            Joke: ""        },        methods: {            getJoke(){                var that= this;                axios.get("https://autumnfish.cn/api/joke")                .then(function(resq){                                            that.Joke= resq.data;                })            }        }    });&lt;/script&gt;</code></pre><h3 id="网络应用-天气查询"><a href="#网络应用-天气查询" class="headerlink" title="网络应用:天气查询"></a>网络应用:天气查询</h3><pre><code>HTML&lt;div id="app"&gt;        &lt;div&gt;            &lt;p&gt;天知道&lt;/p&gt;            &lt;div&gt;                &lt;input type="text" placeholder="请输入查询天气"                 @keyup.enter="searchTQ" v-model="city"&gt;                &lt;input type="button" value="搜索"&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;a href="##" @click="changeCity('北京')"&gt;北京&lt;/a&gt;                &lt;a href="##" @click="changeCity('上海')"&gt;上海&lt;/a&gt;                &lt;a href="##" @click="changeCity('广州')"&gt;广州&lt;/a&gt;                &lt;a href="##" @click="changeCity('深圳')"&gt;深圳&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li v-for="item in weatherList"&gt;                &lt;div&gt;{{item.date}}&lt;/div&gt;                &lt;span&gt;{{item.low}} ~ {{item.high}}&lt;/span&gt;                &lt;span&gt;{{item.type}}&lt;/span&gt;                &lt;span&gt;{{item.fengxiang}}&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;     &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;     JS    window.onload=function(){        var vm=new Vue({            el: "#app",            data: {                city: "",                weatherList: []            },            methods: {                searchTQ(){                    var that=this;                    axios.get("http://wthrcdn.etouch.cn/weather_mini?city="                    +this.city).then(function(resq){                        that.weatherList=resq.data.data.forecast;                    },function(err){                        alert(err);                    })                },                changeCity(city){                    this.city=city;                    this.searchTQ();                }            }        });    };</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/f7d3.html"/>
      <url>posts/f7d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id="Canvas-平移-translate"><a href="#Canvas-平移-translate" class="headerlink" title="Canvas 平移 translate()"></a>Canvas 平移 translate()</h2><p>平移 (translate) 就是将一个图形往水平方向和垂直方向移动一定的距离 <strong>(dx,dy)</strong></p><p>但是，Canvas 中的所有几何变换针对的不是绘制的图形，而是针对画布本身</p><p>例如刚开始的时候在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_42.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>translate(50,50)</strong> 将画布水平和垂直方向各移动 50</p><p>然后在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_43.png"></p><p>此时矩形的起点距离屏幕左上角就已经是 <strong>(100,100)</strong> 了</p><p><strong>语法</strong><br><code>void ctx.translate(dx, dy);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的移动距离</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的移动距离</td></tr></tbody></table><p>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后平移 canvas (50,50) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.translate(50,50);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_44.png"></p><hr><h2 id="Canvas-缩放-scale"><a href="#Canvas-缩放-scale" class="headerlink" title="Canvas 缩放 scale()"></a>Canvas 缩放 scale()</h2><p>缩放 (scale) 就是将一个图形围绕中心点，然后将宽和高分别乘以一定的因子(sx,sy)</p><p>但是，Canvas 中的缩放 (scale) 针对的不是绘制的图形，而是针对画布本身</p><p>画布缩放了，那么画在画布上的图形自然也就缩放了</p><p>例如刚开始的时候在 <strong>(100,100)</strong> 绘制一个 <strong>25x25</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_45.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>scale(0.5,2)</strong> 将画布水平方向缩小一倍和垂直方向放大一倍的时候</p><p>这是什么意思呢？</p><p>就是原来水平方向的 1 个单位现在变成了 0.5 个单位了，垂直方向的 1 个单位现在变成了 2 个单位了</p><p>然后在 <strong>(100,100)</strong> 绘制一个 <strong>5x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_46.png"></p><p><strong>ctx.scale()</strong> 将 <strong>canvas</strong> 水平方向和垂直方向的单位各乘以一定的因子(sx,sy)</p><p>从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离</p><p><strong>语法</strong><br><code>void ctx.scale(sx, sy)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的缩放因子</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的缩放因子</td></tr></tbody></table><p>dx 和 dy 的值可以是负数，负数是啥意思呢？就是想把整个 canvas 翻转，然后再缩放</p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后缩放画布 canvas <strong>(0.5,2)</strong> 最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_47.png"></p><p>如果缩放因子是负数，那么先镜像 (也就是先翻转)，然后再缩放</p><p>如果 sx 是负数，则先按照 Y 轴镜像，然后再缩放<br>如果 sy 是负数，则先按照 X 轴镜像，然后再缩放<br>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后缩放画布 canvas (-0.5,2) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_48.png"></p><p>哎呀，为什么绿色的没掉了呢？因为，因为垂直镜像了之后，x 轴正方向已经从水平向左改成水平向右了</p><p>如果此时还在 <strong>(50,50)</strong> 的位置画画，肯定是看不到啊，因为它已经跑到另一边去了，而屏幕的位置没变啊，于是就看不到了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_49.png"><br>绿色边框是我们的屏幕显示范围</p><p>如果此时还要看到它，就要把绘制起始点的 x 坐标也翻转下，然后再 x 2 就是变成 (-50)x2=-100 就好了</p><p>如果不 x 2 ，结果还是看不到的，因为 -50 也只是把矩形往右移动了 50 像素，到哪里了？ 贴边了…</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-3");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(-100,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_50.png"></p><hr><h2 id="Canvas-旋转-rotate"><a href="#Canvas-旋转-rotate" class="headerlink" title="Canvas 旋转 rotate()"></a>Canvas 旋转 rotate()</h2><p>旋转 ( rotate ) 就是将图形围绕一个中心点(0,0)，顺时针或者逆时针旋转一定的弧度 ( angle )</p><p>但是，Canvas 中的旋转 ( rotate ) 针对的不是绘制的图形，而是针对画布本身</p><p>画布旋转了，带来最直接的结果是什么呢？ 就是某个点与屏幕上边之间的夹角改变了</p><p>我们看一个正常情况下的笛卡尔坐标体系，某个点(50,50) 与屏幕上边和 X 轴正方向之间的夹角都是 45 度</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_51.png"></p><p><strong>绿色</strong> 的是屏幕</p><p><strong>灰色</strong> 的是画布</p><p>当我们画布顺时针旋转 30 度后，就变成了下图这样了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_52.png"></p><p>点还是那个点，点与画布之间的夹角还是 <strong>45°</strong>，但点与屏幕间的夹角已经变成了 <strong>75°</strong></p><p>最直观的感受是啥？ 就是点往左下移了那么一点点，我们去掉各种辅助线，大家看看</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_53.png"></p><p>一个点已经是这样了，如果我们画的是一个图形，那么图形上的所有点都移动了，那么直观看起来，就是图形旋转了</p><p><strong>语法</strong><br><code>void ctx.rotate(angle);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">angle</td><td align="left">顺时针旋转的弧度。可以通过角度值计算：degree * Math.PI / 180</td></tr></tbody></table><p><strong>弧度 angle</strong><br>我们特别说明下 <strong>angle</strong> 这个参数，它是一个弧度</p><p>如果我们要顺时针旋转<strong>30°</strong>，那么</p><p><code>angle = 30 * Math.PI / 180</code><br>如果想要逆时针旋转 <strong>30°</strong> 怎么办呢？逆时针旋转 30°，其实就是顺时针旋转 -30°，也就是</p><p><code>angle = 360 + ( -30 * Math.PI / 180 )</code></p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后顺时针旋转画布 <strong>30°</strong></p><p>最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.rotate(30 * Math.PI / 180);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_54.png"></p><p>我们利用多次旋转画一个折扇图</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var colors = ['#D0021B','#F5A623','#8B572A','#417505','#9013FE','#000000']for ( var i = 0; i &lt; colors.length; i++ ){    ctx.fillStyle = colors[i];    ctx.fillRect(0,0,200,50);    ctx.rotate(15 * Math.PI / 180);}&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_55.png"></p><hr><h2 id="Canvas-橡皮擦-clearRect"><a href="#Canvas-橡皮擦-clearRect" class="headerlink" title="Canvas 橡皮擦 clearRect()"></a>Canvas 橡皮擦 clearRect()</h2><p><strong>ctx.clearRect()</strong> 方法设置指定矩形区域内（以点 (x, y) 为起点，范围是 (width, height) ）所有像素变成透明，并擦除之前绘制的所有内容</p><p><strong>语法</strong><br><code>void ctx.clearRect(x, y, width, height);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">矩形起点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">矩形起点的 y 轴坐标</td></tr><tr><td align="left">width</td><td align="left">矩形的宽度</td></tr><tr><td align="left">height</td><td align="left">矩形的高度</td></tr></tbody></table><p>我们先从 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形，然后再使用 clearRect() 擦出这个矩形的 1/4</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);ctx.clearRect(50,50,200/2,50/2);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_56.png"></p><hr><h2 id="Canvas-绘图上下文-save"><a href="#Canvas-绘图上下文-save" class="headerlink" title="Canvas 绘图上下文 save()"></a>Canvas 绘图上下文 save()</h2><p>Canvas 为我们提供了 图层(Layer) 的支持，Layer(图层) 是按 “栈结构” 来进行管理的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_57.png"></p><p>当我们调用<strong>save()</strong> 方法，会保存当前 Canvas 的状态然后作为一个 Layer(图层)，添加到 Canvas栈 中，</p><p>而当我们调用 <strong>restore()</strong> 方法的时候，会恢复之前 Canvas 的状态，而此时 Canvas 的图层栈 会弹出栈顶的那个 Layer，后继的 Layer 来到栈顶，此时的 Canvas 回复到此栈顶时保存的 Canvas 状态</p><p>简单说就是 <strong>save() 往栈压入一个 Layer，restore()弹出栈顶的一个Layer，这个 Layer 代表Canvas的 状态</strong>！</p><p>也就是说可以 <strong>save()</strong> 多次，也可以 <strong>restore()</strong> 多次，但是 <strong>restore()</strong> 的调用次数 不能大于 <strong>save()</strong> 否则会引发错误</p><p><code>ctx.save()</code> 方法用于将画布的当前状态保存到栈中</p><p>下面的代码使用 save() 方法保存默认的状态，然后平移 (100,100) 绘制一个绿色矩形后，恢复之前的状态，最后再使用默认的设置绘制一个矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.save();ctx.translate(100,100);ctx.fillStyle = "green"ctx.fillRect(50,50,100,50);ctx.restore();ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_58.png"></p><hr><h2 id="Canvas-恢复画板状态-restore"><a href="#Canvas-恢复画板状态-restore" class="headerlink" title="Canvas 恢复画板状态 restore()"></a>Canvas 恢复画板状态 restore()</h2><p><code>ctx.restore()</code> 方法用于将画布恢复到最近一次的保存状态</p><p>如果没有保存状态，此方法不做任何改变</p><hr><h2 id="Canvas-图像混排模式"><a href="#Canvas-图像混排模式" class="headerlink" title="Canvas 图像混排模式"></a>Canvas 图像混排模式</h2><p>首先绘制一个蓝色的矩形，然后绘制一个红色矩形和它重叠，看看不同的图形混排模式带来的效果</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_59.png"></p><p><strong>所有代码如下</strong></p><pre><code>&lt;canvas id="canvas-1" width="500" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var gco = [ 'source-over','source-in','source-out','source-atop',            'destination-over','destination-in','destination-out','destination-atop',            'lighter', 'copy','xor', 'multiply', 'screen', 'overlay', 'darken',            'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'        ];var canvas = document.getElementById("canvas-1");canvas.width = 500;canvas.height = 2700;var ctx = canvas.getContext("2d");function draw(){    for (var i = 0; i &lt; gco.length; i++ )    {        ctx.font = "16px Microsoft YaHei"        ctx.textBaseline = "middle";        ctx.fillStyle="#333"        ctx.save();        ctx.fillText(gco[i],10,15);        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.translate(70,0)        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.fillStyle = "red";        ctx.fillRect(25, 50, 50, 50);        var canvas2 = document.createElement("canvas");        ctx2 = canvas2.getContext("2d");        ctx2.fillStyle = "blue";        ctx2.fillRect(10, 35, 50, 50);        ctx2.globalCompositeOperation = gco[i];        ctx2.fillStyle = "red";        ctx2.fillRect(25, 50, 50, 50);        ctx2.globalCompositeOperation = "source-over";        ctx.drawImage(canvas2,85,0);        ctx.restore();        ctx.translate(0,100);    }}draw();&lt;/script&gt;</code></pre><hr><h2 id="Canvas-图像裁剪"><a href="#Canvas-图像裁剪" class="headerlink" title="Canvas 图像裁剪"></a>Canvas 图像裁剪</h2><p>裁剪用于隐藏部分我们不想看到的图形</p><p>Canvas 中的裁剪和 Photoshop 中的裁剪不一样，Photoshop 中的裁剪针对的是图形，而 Canvas 中的裁剪针对的是画布本身</p><p>Canvas 中的裁剪只有一种方法，就是根据路径来裁剪</p><p>比如我们有一个画布，画布上有一张图片和一个五角星的路径</p><p><strong>语法</strong><br><code>void ctx.clip();</code><br><code>void ctx.clip(fillRule);</code><br><code>void ctx.clip(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">裁剪算法，用于设置判断一个点是在路径内还是在路径外，可选的值有</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕原则，默认的原则</td></tr><tr><td align="left">“evenodd”: 奇偶环绕原则</td><td align="left"></td></tr><tr><td align="left">path</td><td align="left">需要剪切的 Path2D 路径</td></tr></tbody></table><p>先画一个路径，然后调用 clip() 说我要裁剪接下来的图形，而且终身有效</p><p>如果不需要了，那么可以在调用 clip() 前先调用 save() 保存状态，然后再使用完后调用 </p><p>restore() 恢复状态</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c2   = document.getElementById("canvas-2");var ctx2 = c2.getContext("2d");ctx2.save();ctx2.arc(100, 100, 75, 0, Math.PI*2, false);ctx2.clip();ctx2.fillRect(0, 0, 100,100);ctx2.fillStyle="green";ctx2.fillRect(100, 100, 100,100);ctx2.restore();ctx2.fillStyle="red";ctx2.fillRect(40, 40, 30,30);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_60.png"></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
