<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0017.html"/>
      <url>posts/a0017.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0016">对象、类与面向对象编程(三) 继承</a></strong><br>本篇: <strong>对象、类与面向对象编程(四) 类</strong><br>下篇: <strong><a href="a0018"></a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0016.html"/>
      <url>posts/a0016.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0015">对象、类与面向对象编程(二) 创建对象</a></strong><br>本篇: <strong>对象、类与面向对象编程(三) 继承</strong><br>下篇: <strong><a href="a0017">对象、类与面向对象编程(四) 类</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0015.html"/>
      <url>posts/a0015.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0014">对象、类与面向对象编程(一) 理解对象</a></strong><br>本篇: <strong>对象、类与面向对象编程(二) 创建对象</strong><br>下篇: <strong><a href="a0016">对象、类与面向对象编程(三) 继承</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。</p><h2 id="工场模式"><a href="#工场模式" class="headerlink" title="工场模式"></a>工场模式</h2><p>下面的例子展示了一种按照特定接口创建对象的方式：</p><pre><code>function createPerson(name, age, job) {    let o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function() {        console.log(this.name);    };    return o;}let person1 = createPerson("Nicholas", 29, "Software Engineer");let person2 = createPerson("Greg", 27, "Doctor"); </code></pre><p>这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>前面几章提到过，ECMAScript 中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。比如，前面的例子使用构造函数模式可以这样写：</p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Greg</code></pre><p>在这个例子中，Person()构造函数代替了 createPerson()工厂函数。实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。</p><ol><li>没有显式地创建对象。</li><li>属性和方法直接赋值给了 this。</li><li>没有 return。</li></ol><p>另外，要注意函数名 Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。</p><p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[ Prototype]]特性被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p>上一个例子的最后，person1 和 person2 分别保存着 Person 的不同实例。这两个对象都有一个constructor 属性指向 Person，如下所示：</p><pre><code>console.log(person1.constructor == Person); // trueconsole.log(person2.constructor == Person); // true</code></pre><p>constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用instanceof 操作符的结果所示：</p><pre><code>console.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true</code></pre><p>定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承自 Object（后面再详细讨论这一点）。</p><p>构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p><pre><code>let Person = function(name, age, job) {    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Gregconsole.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true </code></pre><p>在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：</p><pre><code>function Person() {    this.name = "Jake";    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person();let person2 = new Person; person1.sayName(); // Jakeperson2.sayName(); // Jakeconsole.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true </code></pre><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><p>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：</p><pre><code>// 作为构造函数let person = new Person("Nicholas", 29, "Software Engineer");person.sayName(); // "Nicholas"// 作为函数调用Person("Greg", 27, "Doctor"); // 添加到 window 对象window.sayName(); // "Greg"// 在另一个对象的作用域中调用let o = new Object();Person.call(o, "Kristen", 25, "Nurse");o.sayName(); // "Kristen" </code></pre><p>这个例子一开始展示了典型的构造函数调用方式，即使用 new 操作符创建一个新对象。然后是普通函数的调用方式，这时候没有使用 new 操作符调用 Person()，结果会将属性和方法添加到 window 对象。这里要记住，在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call()/apply()调用），this 始终指向 Global 对象（在浏览器中就是 window 对象）。因此在上面的调用之后，window 对象上就有了一个 sayName()方法，调用它会返回”Greg”。最后展示的调用方式是通过 call()（或 apply()）调用函数，同时将特定对象指定为作用域。这里的调用将对象 o 指定为 Person()内部的 this 值，因此执行完函数代码后，所有属性和 sayName()方法都会添加到对象 o 上面。</p><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：   </p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = new Function("console.log(this.name)"); // 逻辑等价} </code></pre><p>这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：</p><p><code>console.log(person1.sayName == person2.sayName); // false </code></p><p>因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。要解决这个问题，可以把函数定义转移到构造函数外部：</p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = sayName;}function sayName() {    console.log(this.name);}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Greg</code></pre><p>在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();person1.sayName(); // "Nicholas"let person2 = new Person();person2.sayName(); // "Nicholas"console.log(person1.sayName == person2.sayName); // true </code></pre><p>使用函数表达式也可以：</p><pre><code>let Person = function() {};Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();person1.sayName(); // "Nicholas"let person2 = new Person();person2.sayName(); // "Nicholas"console.log(person1.sayName == person2.sayName); // true </code></pre><p>这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。</p><h3 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h3><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</p><p>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自<br>Object。每次调用构造函数创建一个新实例，这个实例的内部[[ Prototype]]指针就会被赋值为构造函数的原型对象。实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p><p>这种关系不好可视化，但可以通过下面的代码来理解原型的行为：</p><pre><code>/*** 构造函数可以是函数表达式* 也可以是函数声明，因此以下两种形式都可以：* function Person() {}* let Person = function() {}*/function Person() {}/*** 声明之后，构造函数就有了一个* 与之关联的原型对象：*/console.log(typeof Person.prototype);console.log(Person.prototype);// {// constructor: f Person(),// __proto__: Object// }/*** 如前所述，构造函数有一个 prototype 属性* 引用其原型对象，而这个原型对象也有一个* constructor 属性，引用这个构造函数* 换句话说，两者循环引用：*/console.log(Person.prototype.constructor === Person); // true/*** 正常的原型链都会终止于 Object 的原型对象* Object 原型的原型是 null*/console.log(Person.prototype.__proto__ === Object.prototype); // trueconsole.log(Person.prototype.__proto__.constructor === Object); // trueconsole.log(Person.prototype.__proto__.__proto__ === null); // trueconsole.log(Person.prototype.__proto__);// {// constructor: f Object(),// toString: ...// hasOwnProperty: ...// isPrototypeOf: ...// ...// }let person1 = new Person(),person2 = new Person();/*** 构造函数、原型对象和实例* 是 3 个完全不同的对象：*/console.log(person1 !== Person); // trueconsole.log(person1 !== Person.prototype); // trueconsole.log(Person.prototype !== Person); // true/*** 实例通过__proto__链接到原型对象，* 它实际上指向隐藏特性[[Prototype]]** 构造函数通过 prototype 属性链接到原型对象** 实例与构造函数没有直接联系，与原型对象有直接联系*/console.log(person1.__proto__ === Person.prototype); // trueconosle.log(person1.__proto__.constructor === Person); // true/*** 同一个构造函数创建的两个实例* 共享同一个原型对象：*/console.log(person1.__proto__ === person2.__proto__); // true/*** instanceof 检查实例的原型链中* 是否包含指定构造函数的原型：*/console.log(person1 instanceof Person); // trueconsole.log(person1 instanceof Object); // trueconsole.log(Person.prototype instanceof Object); // true </code></pre><p>对于前面例子中的 Person 构造函数和 Person.prototype，可以通过图 6-1 看出各个对象之间的关系。</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201123201157.png" alt="6-1"></p><p>图 6-1 展示了 Person 构造函数、Person 的原型对象和 Person 现有两个实例之间的关系。注意，Person.prototype 指向原型对象，而 Person.prototype.contructor 指回 Person 构造函数。原型对象包含 constructor 属性和其他后来添加的属性。Person 的两个实例 person1 和 person2 都只有一个内部属性指回 Person.prototype，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但 person1.sayName()可以正常调用。这是由于对象属性查找机制的原因。</p><p>虽然不是所有实现都对外暴露了[[ Prototype]]，但可以使用 isPrototypeOf()方法确定两个对象之间的这种关系。本质上，isPrototypeOf()会在传入参数的[[ Prototype]]指向调用它的对象时返回 true，如下所示：</p><p><code>console.log(Person.prototype.isPrototypeOf(person1)); // true</code><br><code>console.log(Person.prototype.isPrototypeOf(person2)); // true </code></p><p>这里通过原型对象调用 isPrototypeOf()方法检查了 person1 和 person2。因为这两个例子内部都有链接指向 Person.prototype，所以结果都返回 true。</p><p>ECMAScript 的 Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性[[ Prototype]]的值。例如：</p><p><code>console.log(Object.getPrototypeOf(person1) == Person.prototype); // true</code><br><code>console.log(Object.getPrototypeOf(person1).name); // "Nicholas" </code></p><p>第一行代码简单确认了 Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二<br>行代码则取得了原型对象上 name 属性的值，即”Nicholas”。使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要</p><p>Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[ Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：</p><pre><code>let biped = {    numLegs: 2};let person = {    name: 'Matt'};Object.setPrototypeOf(person, biped);console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true</code></pre><p><strong>警告</strong> Object.setPrototypeOf()可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[ Prototype]]的对象的代码。”</p><p>为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型：</p><pre><code>let biped = {    numLegs: 2};let person = Object.create(biped);person.name = 'Matt';console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0014.html"/>
      <url>posts/a0014.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0013">迭代器与生成器(二) 生成器</a></strong><br>本篇: <strong>对象、类与面向对象编程(一) 理解对象</strong><br>下篇: <strong><a href="a0015">对象、类与面向对象编程(二) 创建对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：</p><pre><code>let person = new Object();person.name = "Nicholas";person.age = 29;person.job = "Software Engineer";person.sayName = function() {    console.log(this.name);}; </code></pre><p>前面的例子如果使用对象字面量则可以这样写：</p><pre><code>let person = {    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }}; </code></pre><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[ Enumerable]]。</p><p>属性分两种：数据属性和访问器属性。</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为。</p><ol><li><p>[[ Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特<br>性都是 true，如前面的例子所示。</p></li><li><p>[[ Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[ Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[ Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。</p></li></ol><p>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如：</p><pre><code>let person = {};Object.defineProperty(person, "name", {    writable: false,    value: "Nicholas"});console.log(person.name); // "Nicholas"person.name = "Greg";console.log(person.name); // "Nicholas" </code></pre><p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就<br>不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p><p>类似的规则也适用于创建不可配置的属性。比如：</p><pre><code>let person = {};Object.defineProperty(person, "name", {configurable: false,value: "Nicholas"});console.log(person.name); // "Nicholas"delete person.name;console.log(person.name); // "Nicholas"</code></pre><p>这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误：</p><pre><code>let person = {};Object.defineProperty(person, "name", {configurable: false,value: "Nicholas"});// 抛出错误Object.defineProperty(person, "name", {configurable: true,value: "Nicholas"}); </code></pre><p>因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设置为 false 之后就会受限制了。</p><p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。</p><ol><li><p>[[ Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[ Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[ Get]]：获取函数，在读取属性时调用。默认值为 undefined。</p></li><li><p>[[ Set]]：设置函数，在写入属性时调用。默认值为 undefined。</p></li></ol><p>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。下面是一个例子：</p><pre><code>// 定义一个对象，包含伪私有成员 year_和公共成员 editionlet book = {    year_: 2017,    edition: 1 };Object.defineProperty(book, "year", {    get() {        return this.year_;    },    set(newValue) {        if (newValue &gt; 2017) {            this.year_ = newValue;            this.edition += newValue - 2017;        }    }});book.year = 2018;console.log(book.edition); // 2 </code></pre><p>在这个例子中，对象 book 有两个默认属性：year_和 edition。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。</p><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><pre><code>let book = {};Object.defineProperties(book, {    year_: {        value: 2017    },    edition: {        value: 1    },    year: {        get() {            return this.year_;        },        set(newValue) {            if (newValue &gt; 2017) {                this.year_ = newValue;                this.edition += newValue - 2017;            }        }    }}); </code></pre><p>这段代码在 book 对象上定义了两个数据属性 year_和 edition，还有一个访问器属性 year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的configurable、enumerable 和 writable 特性值都是 false。</p><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。比如：</p><pre><code>let book = {};Object.defineProperties(book, {    year_: {        value: 2017    },    edition: {        value: 1    },    year: {        get: function() {            return this.year_;        },        set: function(newValue){            if (newValue &gt; 2017) {                this.year_ = newValue;                this.edition += newValue - 2017;            }        }    }}); let descriptor = Object.getOwnPropertyDescriptor(book, "year_");console.log(descriptor.value); // 2017console.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // "undefined"let descriptor = Object.getOwnPropertyDescriptor(book, "year");console.log(descriptor.value); // undefinedconsole.log(descriptor.enumerable); // falseconsole.log(typeof descriptor.get); // "function" </code></pre><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。</p><p>ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[ Get]]取得属性的值，然后使用目标对象上的[[ Set]]设置属性的值。</p><pre><code>let dest, src, result;/*** 简单复制*/dest = {};src = { id: 'src' };result = Object.assign(dest, src); // Object.assign 修改目标对象// 也会返回修改后的目标对象console.log(dest === result); // trueconsole.log(dest !== src); // trueconsole.log(result); // { id: src }console.log(dest); // { id: src } /*** 多个源对象*/dest = {};result = Object.assign(dest, { a: 'foo' }, { b: 'bar' });console.log(result); // { a: foo, b: bar }/*** 获取函数与设置函数*/dest = {    set a(val) {        console.log(`Invoked dest setter with param ${val}`);    }};src = {    get a() {        console.log('Invoked src getter');        return 'foo';    }}; Object.assign(dest, src);// 调用 src 的获取方法// 调用 dest 的设置方法并传入参数"foo"// 因为这里的设置函数不执行赋值操作// 所以实际上并没有把值转移过来console.log(dest); // { set a(val) {...} } </code></pre><p>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p><pre><code>let dest, src, result;、/*** 覆盖属性*/dest = { id: 'dest' };result = Object.assign(dest, { id: 'src1', a: 'foo' }, { id: 'src2', b: 'bar' });// Object.assign 会覆盖重复的属性console.log(result); // { id: src2, a: foo, b: bar }// 可以通过目标对象上的设置函数观察到覆盖的过程：dest = {    set id(x) {        console.log(x);    }};Object.assign(dest, { id: 'first' }, { id: 'second' }, { id: 'third' });// first// second// third /*** 对象引用*/dest = {};src = { a: {} };Object.assign(dest, src);// 浅复制意味着只会复制对象的引用console.log(dest); // { a :{} }console.log(dest.a === src.a); // true </code></pre><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p><pre><code>let dest, src, result;/*** 错误处理*/dest = {};src = {    a: 'foo',    get b() {        // Object.assign()在调用这个获取函数时会抛出错误        throw new Error();    },     c: 'bar'};try {    Object.assign(dest, src);} catch(e) {}// Object.assign()没办法回滚已经完成的修改// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：console.log(dest); // { a: foo } </code></pre><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：</p><pre><code>// 这些是===符合预期的情况console.log(true === 1); // falseconsole.log({} === {}); // falseconsole.log("2" === 2); // false// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等console.log(+0 === -0); // trueconsole.log(+0 === 0); // trueconsole.log(-0 === 0); // true// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()console.log(NaN === NaN); // falseconsole.log(isNaN(NaN)); // true </code></pre><p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p><pre><code>console.log(Object.is(true, 1)); // falseconsole.log(Object.is({}, {})); // falseconsole.log(Object.is("2", 2)); // false// 正确的 0、-0、+0 相等/不等判定console.log(Object.is(+0, -0)); // falseconsole.log(Object.is(+0, 0)); // trueconsole.log(Object.is(-0, 0)); // false// 正确的 NaN 相等判定console.log(Object.is(NaN, NaN)); // true </code></pre><p>要检查超过两个值，递归地利用相等性传递即可：</p><pre><code>function recursivelyCheckEqual(x, ...rest) {return Object.is(x, rest[0]) &amp;&amp;       (rest.length &lt; 2 || recursivelyCheckEqual(...rest));} </code></pre><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><p>ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。</p><p>本节介绍的所有对象语法同样适用于 ECMAScript 6 的类，本章后面会讨论。</p><h3 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h3><p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：</p><pre><code>let name = 'Matt';let person = {    name: name};console.log(person); // { name: 'Matt' } </code></pre><p>为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。以下代码和之前的代码是等价的：</p><pre><code>let name = 'Matt';let person = {    name};console.log(person); // { name: 'Matt' } </code></pre><p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例：</p><pre><code>function makePerson(name) {    return {        name    };}let person = makePerson('Matt');console.log(person.name); // Matt</code></pre><p>在这里，即使参数标识符只限定于函数作用域，编译器也会保留初始的 name 标识符。</p><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如：    </p><pre><code>const nameKey = 'name';const ageKey = 'age'; const jobKey = 'job';let person = {};person[nameKey] = 'Matt';person[ageKey] = 27;person[jobKey] = 'Software engineer';console.log(person); // { name: 'Matt', age: 27, job: 'Software engineer' }</code></pre><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：</p><pre><code>const nameKey = 'name';const ageKey = 'age';const jobKey = 'job';let person = {    [nameKey]: 'Matt',    [ageKey]: 27,    [jobKey]: 'Software engineer'};console.log(person);// { name: 'Matt', age: 27, job: 'Software engineer' } </code></pre><p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p><pre><code>const nameKey = 'name';const ageKey = 'age';const jobKey = 'job';let uniqueToken = 0;function getUniqueKey(key) {    return `${key}_${uniqueToken++}`;}let person = {    [getUniqueKey(nameKey)]: 'Matt',    [getUniqueKey(ageKey)]: 27,    [getUniqueKey(jobKey)]: 'Software engineer'};console.log(person); // { name_0: 'Matt', age_1: 27, job_2: 'Software engineer' } </code></pre><h3 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h3><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><pre><code>let person = {    sayName: function(name) {        console.log(`My name is ${name}`);    }};person.sayName('Matt'); // My name is Matt</code></pre><p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名。相应地，这样也可以明显缩短方法声明。 以下代码和之前的代码在行为上是等价的：</p><pre><code>let person = {    sayName(name) {        console.log(`My name is ${name}`);    }};person.sayName('Matt'); // My name is Matt </code></pre><p>简写方法名对获取函数和设置函数也是适用的：</p><pre><code>let person = {    name_: '',    get name() {        return this.name_;    },    set name(name) {        this.name_ = name;    },    sayName() {        console.log(`My name is ${this.name_}`);    }};person.name = 'Matt';person.sayName(); // My name is Matt</code></pre><p>简写方法名与可计算属性键相互兼容：</p><pre><code>const methodKey = 'sayName';let person = {    [methodKey](name) {        console.log(`My name is ${name}`);    }}person.sayName('Matt'); // My name is Matt</code></pre><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><p>下面的例子展示了两段等价的代码，首先是不使用对象解构的：</p><pre><code>// 不使用对象解构let person = {    name: 'Matt',    age: 27}; let personName = person.name,    personAge = person.age;console.log(personName); // Mattconsole.log(personAge); // 27 </code></pre><p>然后，是使用对象解构的：</p><pre><code>// 使用对象解构let person = {    name: 'Matt',    age: 27};let { name: personName, age: personAge } = person;console.log(personName); // Mattconsole.log(personAge); // 27 </code></pre><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, age } = person;console.log(name); // Mattconsole.log(age); // 27 </code></pre><p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, job } = person;console.log(name); // Mattconsole.log(job); // undefined </code></pre><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, job='Software engineer' } = person;console.log(name); // Mattconsole.log(job); // Software engineer</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(五)</title>
      <link href="posts/a0013.html"/>
      <url>posts/a0013.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。</p><p>上篇: <strong><a href="a0012">迭代器与生成器(一) 迭代器</a></strong><br>本篇: <strong>迭代器与生成器(二) 生成器</strong><br>下篇: <strong><a href="a0014">对象、类与面向对象编程(一) 理解对象</a></strong> </p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程</p><h2 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h2><p>生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义<br>函数的地方，就可以定义生成器。</p><pre><code>// 生成器函数声明function* generatorFn() {}// 生成器函数表达式let generatorFn = function* () {}// 作为对象字面量方法的生成器函数let foo = {    * generatorFn() {}}// 作为类实例方法的生成器函数class Foo {    * generatorFn() {}}// 作为类静态方法的生成器函数class Bar {    static * generatorFn() {}} </code></pre><p><strong>注意</strong> 箭头函数不能用来定义生成器函数</p><p>标识生成器函数的星号不受两侧空格的影响：</p><pre><code>// 等价的生成器函数：function* generatorFnA() {}function *generatorFnB() {}function * generatorFnC() {}// 等价的生成器方法：class Foo {    *generatorFnD() {}    * generatorFnE() {}} </code></pre><p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。</p><pre><code>function* generatorFn() {}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.next); // f next() { [native code] } </code></pre><p>next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。</p><pre><code>function* generatorFn() {}let generatorObject = generatorFn();console.log(generatorObject); // generatorFn {&lt;suspended&gt;}console.log(generatorObject.next()); // { done: true, value: undefined } </code></pre><p>value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定：</p><pre><code>function* generatorFn() {    return 'foo';}let generatorObject = generatorFn();console.log(generatorObject); // generatorFn {&lt;suspended&gt;}console.log(generatorObject.next()); // { done: true, value: 'foo' } </code></pre><p>生成器函数只会在初次调用 next()方法后开始执行，如下所示</p><pre><code>function* generatorFn() {    console.log('foobar');}// 初次调用生成器函数并不会打印日志let generatorObject = generatorFn();generatorObject.next(); // foobar </code></pre><p>生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的：</p><pre><code>function* generatorFn() {}console.log(generatorFn);// f* generatorFn() {}console.log(generatorFn()[Symbol.iterator]); // f [Symbol.iterator]() {native code}console.log(generatorFn());// generatorFn {&lt;suspended&gt;}console.log(generatorFn()[Symbol.iterator]());// generatorFn {&lt;suspended&gt;} const g = generatorFn();console.log(g === g[Symbol.iterator]()); // true</code></pre><h2 id="通过-yield-中断执行"><a href="#通过-yield-中断执行" class="headerlink" title="通过 yield 中断执行"></a>通过 yield 中断执行</h2><p>yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行：</p><pre><code>function* generatorFn() {    yield;}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: undefined }console.log(generatorObject.next()); // { done: true, value: undefined }</code></pre><p>此时的yield 关键字有点像函数的中间返回语句，它生成的值会出现在 next()方法返回的对象里。通过 yield 关键字退出的生成器函数会处在 done: false 状态；通过 return 关键字退出的生成器函数会处于 done: true 状态。</p><pre><code>function* generatorFn() {    yield 'foo';    yield 'bar';    return 'baz';}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: 'foo' }console.log(generatorObject.next()); // { done: false, value: 'bar' }console.log(generatorObject.next()); // { done: true, value: 'baz' }</code></pre><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next()不会影响其他生成器：</p><pre><code>function* generatorFn() {    yield 'foo';    yield 'bar';    return 'baz';}let generatorObject1 = generatorFn();let generatorObject2 = generatorFn();console.log(generatorObject1.next()); // { done: false, value: 'foo' }console.log(generatorObject2.next()); // { done: false, value: 'foo' } console.log(generatorObject2.next()); // { done: false, value: 'bar' }console.log(generatorObject1.next()); // { done: false, value: 'bar' } </code></pre><p>yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</p><pre><code>// 有效function* validGeneratorFn() {    yield;}// 无效function* invalidGeneratorFnA() {    function a() {        yield;    }}// 无效function* invalidGeneratorFnB() {    const b = () =&gt; {        yield;    }}// 无效function* invalidGeneratorFnC() {    (() =&gt; {        yield;    })();} </code></pre><h3 id="生成器对象作为可迭代对象"><a href="#生成器对象作为可迭代对象" class="headerlink" title="生成器对象作为可迭代对象"></a>生成器对象作为可迭代对象</h3><p>在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：</p><pre><code>function* generatorFn() {    yield 1;    yield 2;    yield 3;}for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3</code></pre><p>在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p><pre><code>function* nTimes(n) {    while(n--) {        yield;    }} for (let _ of nTimes(3)) {    console.log('foo');}// foo// foo// foo </code></pre><p>传给生成器的函数可以控制迭代循环的次数。在 n 为 0 时，while 条件为假，循环退出，生成器函数返回。</p><h3 id="使用-yield-实现输入和输出"><a href="#使用-yield-实现输入和输出" class="headerlink" title="使用 yield 实现输入和输出"></a>使用 yield 实现输入和输出</h3><p>除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p><pre><code>function* generatorFn(initial) {    console.log(initial);    console.log(yield);    console.log(yield);}let generatorObject = generatorFn('foo');generatorObject.next('bar'); // foogeneratorObject.next('baz'); // bazgeneratorObject.next('qux'); // qux</code></pre><p>yield 关键字可以同时用于输入和输出，如下例所示：</p><pre><code>function* generatorFn() {    return yield 'foo';}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: 'foo' }console.log(generatorObject.next('bar')); // { done: true, value: 'bar' } </code></pre><p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 yield 关键字时暂停执行并计算出要产生的值：”foo”。下一次调用 next()传入了”bar”，作为交给同一个 yield 的值。然后这个值被确定为本次生成器函数要返回的值。</p><p>yield 关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数：</p><pre><code>function* generatorFn() {    for (let i = 0;;++i) {        yield i;    }}let generatorObject = generatorFn();console.log(generatorObject.next().value); // 0console.log(generatorObject.next().value); // 1console.log(generatorObject.next().value); // 2console.log(generatorObject.next().value); // 3console.log(generatorObject.next().value); // 4console.log(generatorObject.next().value); // 5... </code></pre><p>假设我们想定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p><pre><code>function* nTimes(n) {    for (let i = 0; i &lt; n; ++i) {        yield i;    }}for (let x of nTimes(3)) {    console.log(x);}// 0// 1// 2</code></pre><p>另外，使用 while 循环也可以，而且代码稍微简洁一点：</p><pre><code>function* nTimes(n) {    let i = 0;    while(n--) {        yield i++;    }}for (let x of nTimes(3)) {    console.log(x);}// 0// 1// 2 </code></pre><p>这样使用生成器也可以实现范围和填充数组：<br>    function* range(start, end) {<br>        while(end &gt; start) {<br>            yield start++;<br>        }<br>    }</p><pre><code>for (const x of range(4, 7)) {    console.log(x);}// 4// 5// 6function* zeroes(n) {    while(n--) {        yield 0;    }}console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0] </code></pre><h3 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h3><p>可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</p><pre><code>// 等价的 generatorFn：// function* generatorFn() {// for (const x of [1, 2, 3]) {// yield x;// }// }function* generatorFn() {    yield* [1, 2, 3];}let generatorObject = generatorFn();for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3 </code></pre><p>与生成器函数的星号类似，yield 星号两侧的空格不影响其行为：</p><pre><code>function* generatorFn() {    yield* [1, 2];    yield *[3, 4];    yield * [5, 6];}for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3// 4// 5// 6 </code></pre><p>因为 yield*实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 yield放到一个循环里没什么不同。下面两个生成器函数的行为是等价的：</p><pre><code>function* generatorFnA() {    for (const x of [1, 2, 3]) {        yield x;    }}for (const x of generatorFnA()) {    console.log(x);}// 1// 2// 3function* generatorFnB() {    yield* [1, 2, 3];}for (const x of generatorFnB()) {    console.log(x);} //1 2 3 </code></pre><p>yield*的值是关联迭代器返回 done: true 时的 value 属性。对于普通迭代器来说，这个值是undefined：</p><pre><code>function* generatorFn() {    console.log('iter value:', yield* [1, 2, 3]);}for (const x of generatorFn()) {    console.log('value:', x);}// value: 1// value: 2// value: 3// iter value: undefined </code></pre><p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p><pre><code>function* innerGeneratorFn() {    yield 'foo';    return 'bar';}function* outerGeneratorFn(genObj) {    console.log('iter value:', yield* innerGeneratorFn());}for (const x of outerGeneratorFn()) {    console.log('value:', x);}// value: foo// iter value: bar </code></pre><h3 id="使用-yield-实现递归算法"><a href="#使用-yield-实现递归算法" class="headerlink" title="使用 yield*实现递归算法"></a>使用 yield*实现递归算法</h3><p>yield*最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p><pre><code>function* nTimes(n) {    if (n &gt; 0) {        yield* nTimes(n - 1);        yield n - 1;    }}for (const x of nTimes(3)) {    console.log(x);}// 0// 1// 2 </code></pre><p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</p><p>使用递归生成器结构和 yield*可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p><pre><code>class Node {    constructor(id) {        this.id = id;        this.neighbors = new Set();    }    connect(node) {        if (node !== this) {            this.neighbors.add(node);            node.neighbors.add(this);        }    }} class RandomGraph {    constructor(size) {        this.nodes = new Set();        // 创建节点        for (let i = 0; i &lt; size; ++i) {            this.nodes.add(new Node(i));        }        // 随机连接节点        const threshold = 1 / size;        for (const x of this.nodes) {            for (const y of this.nodes) {                if (Math.random() &lt; threshold) {                    x.connect(y);                }            }        }    }     for (const node of this.nodes) {        const ids = [...node.neighbors]                    .map((n) =&gt; n.id)                    .join(',');        console.log(`${node.id}: ${ids}`);    }}const g = new RandomGraph(6);g.print();// 示例输出：// 0: 2,3,5// 1: 2,3,4,5// 2: 1,3// 3: 0,1,2,4// 4: 2,3// 5: 0,4 </code></pre><p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p><pre><code>class Node {    constructor(id) {        ...    }    connect(node) {        ...    }}class RandomGraph {    constructor(size) {        ...    }    print() {        ...    }     isConnected() {        const visitedNodes = new Set();        function* traverse(nodes) {            for (const node of nodes) {                if (!visitedNodes.has(node)) {                    yield node;                    yield* traverse(node.neighbors);                }            }        }        // 取得集合中的第一个节点        const firstNode = this.nodes[Symbol.iterator]().next().value;        // 使用递归生成器迭代每个节点        for (const node of traverse([firstNode])) {            visitedNodes.add(node);        }        return visitedNodes.size === this.nodes.size;    }}  </code></pre><h2 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h2><p>因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p><pre><code>class Foo {    constructor() {        this.values = [1, 2, 3];    }     * [Symbol.iterator]() {        yield* this.values;    }}const f = new Foo();for (const x of f) {    console.log(x);}// 1// 2// 3 </code></pre><p>这里，for-of 循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p><h2 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h2><p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next()方法，还有一个可选的 return()方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：throw()。</p><pre><code>function* generatorFn() {}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.next); // f next() { [native code] }console.log(g.return); // f return() { [native code] }console.log(g.throw); // f throw() { [native code] }</code></pre><p>return()和 throw()方法都可以用于强制生成器进入关闭状态。</p><h3 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h3><p>return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.return(4)); // { done: true, value: 4 }console.log(g); // generatorFn {&lt;closed&gt;} </code></pre><p>与迭代器不同，所有生成器对象都有 return()方法，只要通过它进入关闭状态，就无法恢复了。后续调用 next()会显示 done: true 状态，而提供的任何返回值都不会被存储或传播：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g.next()); // { done: false, value: 1 }console.log(g.return(4)); // { done: true, value: 4 }console.log(g.next()); // { done: true, value: undefined }console.log(g.next()); // { done: true, value: undefined }console.log(g.next()); // { done: true, value: undefined }  </code></pre><p>for-of 循环等内置语言结构会忽略状态为 done: true 的 IteratorObject 内部返回的值。</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();for (const x of g) {    if (x &gt; 1) {        g.return(4);    }    console.log(x);}// 1// 2 </code></pre><h3 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h3><p>throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}try {    g.throw('foo');} catch (e) {    console.log(e); // foo}console.log(g); // generatorFn {&lt;closed&gt;}</code></pre><p>不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值。比如：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        try {            yield x;        } catch(e) {}    }} const g = generatorFn();console.log(g.next()); // { done: false, value: 1}g.throw('foo');console.log(g.next()); // { done: false, value: 3}</code></pre><p>在这个例子中，生成器在 try/catch 块中的 yield 关键字处暂停执行。在暂停期间，throw()方法向生成器对象内部注入了一个错误：字符串”foo”。这个错误会被 yield 关键字抛出。因为错误是在生成器的 try/catch 块中抛出的，所以仍然在生成器内部被捕获。可是，由于 yield 抛出了那个错误，生成器就不会再产出值 2。此时，生成器函数继续执行，在下一次迭代再次遇到 yield 关键字时产出了值 3。</p><p><strong>注意</strong> 如果生成器对象还没有开始执行，那么调用 throw()抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(五)</title>
      <link href="posts/a0012.html"/>
      <url>posts/a0012.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。</p><p>上篇: <strong><a href="a0011">集合引用类型(八) 迭代与扩展操作</a></strong><br>本篇: <strong>迭代器与生成器(一) 迭代器</strong><br>下篇: <strong><a href="a0013">迭代器与生成器(二) 生成器</a></strong> </p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h2><p>在 JavaScript 中，计数循环就是一种最简单的迭代：</p><pre><code>for (let i = 1; i &lt;= 10; ++i) {    console.log(i);} </code></pre><p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。</p><p>数组是 JavaScript 中有序集合的最典型例子。</p><pre><code>let collection = ['foo', 'bar', 'baz'];for (let index = 0; index &lt; collection.length; ++index) {console.log(collection[index]);} </code></pre><p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。由于如下原因，通过这种循环来执行例程并不理想。</p><ol><li><p>迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，<br>然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。</p></li><li><p>遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适<br>用于其他具有隐式顺序的数据结构。</p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。</p><p>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：</p><pre><code>// 数组的元素是有限的// 递增索引可以按序访问每个元素let arr = [3, 1, 4];// 集合的元素是有限的// 可以按插入顺序访问每个元素let set = new Set().add(3).add(1).add(4); </code></pre><p>不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如本章开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。</p><p><strong>注意</strong> 临时性可迭代对象可以实现为生成器</p><p>任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。迭代器（iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。</p><h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>很多内置类型都实现了 Iterable 接口：</p><ol><li>字符串</li><li>数组</li><li>映射</li><li>集合</li><li>arguments 对象</li><li>NodeList 等 DOM 集合类型</li></ol><p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p><pre><code>let num = 1;let obj = {};// 这两种类型没有实现迭代器工厂函数console.log(num[Symbol.iterator]); // undefinedconsole.log(obj[Symbol.iterator]); // undefinedlet str = 'abc';let arr = ['a', 'b', 'c'];let map = new Map().set('a', 1).set('b', 2).set('c', 3);let set = new Set().add('a').add('b').add('c');let els = document.querySelectorAll('div');// 这些类型都实现了迭代器工厂函数console.log(str[Symbol.iterator]); // f values() { [native code] }console.log(arr[Symbol.iterator]); // f values() { [native code] }console.log(map[Symbol.iterator]); // f values() { [native code] }console.log(set[Symbol.iterator]); // f values() { [native code] }console.log(els[Symbol.iterator]); // f values() { [native code] }// 调用这个工厂函数会生成一个迭代器console.log(str[Symbol.iterator]()); // StringIterator {}console.log(arr[Symbol.iterator]()); // ArrayIterator {}console.log(map[Symbol.iterator]()); // MapIterator {}console.log(set[Symbol.iterator]()); // SetIterator {}console.log(els[Symbol.iterator]()); // ArrayIterator {} </code></pre><p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p><ol><li>for-of 循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()接收由期约组成的可迭代对象</li><li>Promise.race()接收由期约组成的可迭代对象</li><li>yield*操作符，在生成器中使用</li></ol><p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p><pre><code>let arr = ['foo', 'bar', 'baz'];// for-of 循环for (let el of arr) {    console.log(el); }// foo// bar// baz// 数组解构let [a, b, c] = arr;console.log(a, b, c); // foo, bar, baz// 扩展操作符let arr2 = [...arr];console.log(arr2); // ['foo', 'bar', 'baz']// Array.from()let arr3 = Array.from(arr);console.log(arr3); // ['foo', 'bar', 'baz']// Set 构造函数let set = new Set(arr);console.log(set); // Set(3) {'foo', 'bar', 'baz'}// Map 构造函数let pairs = arr.map((x, i) =&gt; [x, i]);console.log(pairs); // [['foo', 0], ['bar', 1], ['baz', 2]]let map = new Map(pairs);console.log(map); // Map(3) { 'foo'=&gt;0, 'bar'=&gt;1, 'baz'=&gt;2 }</code></pre><p>如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口：</p><pre><code>class FooArray extends Array {}let fooArr = new FooArray('foo', 'bar', 'baz');for (let el of fooArr) {    console.log(el);}// foo// bar// baz  </code></pre><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。</p><p>next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。可以通过以下简单的数组来演示：</p><pre><code>// 可迭代对象let arr = ['foo', 'bar'];// 迭代器工厂函数console.log(arr[Symbol.iterator]); // f values() { [native code] }// 迭代器let iter = arr[Symbol.iterator]();console.log(iter); // ArrayIterator {} // 执行迭代console.log(iter.next()); // { done: false, value: 'foo' }console.log(iter.next()); // { done: false, value: 'bar' }console.log(iter.next()); // { done: true, value: undefined }</code></pre><p>这里通过创建迭代器并调用 next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了：</p><pre><code>let arr = ['foo'];let iter = arr[Symbol.iterator]();console.log(iter.next()); // { done: false, value: 'foo' }console.log(iter.next()); // { done: true, value: undefined }console.log(iter.next()); // { done: true, value: undefined }console.log(iter.next()); // { done: true, value: undefined } </code></pre><p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象：</p><pre><code>let arr = ['foo', 'bar'];let iter1 = arr[Symbol.iterator]();let iter2 = arr[Symbol.iterator]();console.log(iter1.next()); // { done: false, value: 'foo' }console.log(iter2.next()); // { done: false, value: 'foo' }console.log(iter2.next()); // { done: false, value: 'bar' }console.log(iter1.next()); // { done: false, value: 'bar' }</code></pre><p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：</p><pre><code>    let arr = ['foo', 'baz'];    let iter = arr[Symbol.iterator]();    console.log(iter.next()); // { done: false, value: 'foo' }    // 在数组中间插入值    arr.splice(1, 0, 'bar');    console.log(iter.next()); // { done: false, value: 'bar' }    console.log(iter.next()); // { done: false, value: 'baz' }    console.log(iter.next()); // { done: true, value: undefined } </code></pre><p><strong>注意</strong> 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p><p>“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。</p><pre><code>// 这个类实现了可迭代接口（Iterable）// 调用默认的迭代器工厂函数会返回// 一个实现迭代器接口（Iterator）的迭代器对象class Foo {    [Symbol.iterator]() {        return {            next() {                return { done: false, value: 'foo' };            }        }    }}let f = new Foo(); // 打印出实现了迭代器接口的对象console.log(f[Symbol.iterator]()); // { next: f() {} } // Array 类型实现了可迭代接口（Iterable）// 调用 Array 类型的默认迭代器工厂函数// 会创建一个 ArrayIterator 的实例let a = new Array();// 打印出 ArrayIterator 的实例console.log(a[Symbol.iterator]()); // Array Iterator {} </code></pre><h2 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h2><p>与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。下面这个例子中的 Counter 类只能被迭代一定的次数：</p><pre><code>class Counter {    // Counter 的实例应该迭代 limit 次    constructor(limit) {        this.count = 1;        this.limit = limit;    }    next() {        if (this.count &lt;= this.limit) {            return { done: false, value: this.count++ };        } else {            return { done: true, value: undefined };        }    }    [Symbol.iterator]() {        return this;    }}let counter = new Counter(3);for (let i of counter) {    console.log(i);}// 1// 2// 3 </code></pre><p>这个类实现了 Iterator 接口，但不理想。这是因为它的每个实例只能被迭代一次：</p><pre><code>for (let i of counter) { console.log(i); } // 1 2 3for (let i of counter) { console.log(i); } // (nothing logged)</code></pre><p>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：</p><pre><code>class Counter {    constructor(limit) {        this.limit = limit;    }    [Symbol.iterator]() {        let count = 1,        limit = this.limit;        return {            next() {                if (count &lt;= limit) {                    return { done: false, value: count++ };                } else {                    return { done: true, value: undefined };                }            }        };    }} let counter = new Counter(3);for (let i of counter) { console.log(i); } //1 2 3for (let i of counter) { console.log(i); } //1 2 3</code></pre><p>每个以这种方式创建的迭代器也实现了 Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器：</p><pre><code>let arr = ['foo', 'bar', 'baz'];let iter1 = arr[Symbol.iterator]();console.log(iter1[Symbol.iterator]); // f values() { [native code] }let iter2 = iter1[Symbol.iterator]();console.log(iter1 === iter2); // true </code></pre><p>因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如for-of 循环：</p><pre><code>let arr = [3, 1, 4];let iter = arr[Symbol.iterator](); for (let item of arr ) { console.log(item); } //3 1 4 for (let item of iter ) { console.log(item); } //3 1 4</code></pre><h2 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h2><p>可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：</p><ol><li>for-of 循环通过 break、continue、return 或 throw 提前退出；</li><li>解构操作并未消费所有值。</li></ol><p>return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。</p><p>如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用return()方法。</p><pre><code>class Counter {    constructor(limit) {        this.limit = limit;    }    [Symbol.iterator]() {        let count = 1,        limit = this.limit;        return {            next() {                if (count &lt;= limit) {                    return { done: false, value: count++ };                } else {                    return { done: true };                }            },            return() {                console.log('Exiting early');                return { done: true };            }        };    }} let counter1 = new Counter(5);for (let i of counter1) {    if (i &gt; 2) {        break;    }    console.log(i);} // 1// 2// Exiting earlylet counter2 = new Counter(5);try {    for (let i of counter2) {        if (i &gt; 2) {            throw 'err';        }        console.log(i);    }} catch(e) {}// 1// 2// Exiting early let counter3 = new Counter(5);let [a, b] = counter3;// Exiting early</code></pre><p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p><pre><code>let a = [1, 2, 3, 4, 5];let iter = a[Symbol.iterator]();for (let i of iter) {    console.log(i);    if (i &gt; 2) {        break;    }}// 1// 2// 3for (let i of iter) {    console.log(i);}// 4// 5 </code></pre><p>因为 return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。</p><pre><code>let a = [1, 2, 3, 4, 5];let iter = a[Symbol.iterator]();iter.return = function() {    console.log('Exiting early');    return { done: true }; };for (let i of iter) {    console.log(i);    if (i &gt; 2) {        break;    }}// 1// 2// 3// 提前退出for (let i of iter) {    console.log(i);}// 4// 5 </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0011.html"/>
      <url>posts/a0011.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0010">集合引用类型(七) WeakSet</a></strong><br>本篇: <strong>集合引用类型(八) 迭代与扩展操作</strong><br>下篇: <strong><a href="a0012">迭代器与生成器(一) 迭代器</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h1><p>ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。</p><p><strong>注意</strong> 第 5 章会更详细地介绍迭代器和生成器。</p><p>如本章前面所示，有 4 种原生集合类型定义了默认迭代器：</p><ol><li>Array</li><li>所有定型数组</li><li>Map</li><li>Set</li></ol><p>很简单，这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环：</p><pre><code>let iterableThings = [    Array.of(1, 2),    typedArr = Int16Array.of(3, 4),    new Map([[5, 6], [7, 8]]),    new Set([9, 10])];for (const iterableThing of iterableThings) {    for (const x of iterableThing) {        console.log(x);    }}// 1// 2// 3// 4// [5, 6]// [7, 8]// 9// 10 </code></pre><p>这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p><pre><code>let arr1 = [1, 2, 3];let arr2 = [...arr1];console.log(arr1); // [1, 2, 3]console.log(arr2); // [1, 2, 3]console.log(arr1 === arr2); // false </code></pre><p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p><pre><code>let map1 = new Map([[1, 2], [3, 4]]);let map2 = new Map(map1);console.log(map1); // Map {1 =&gt; 2, 3 =&gt; 4}console.log(map2); // Map {1 =&gt; 2, 3 =&gt; 4}</code></pre><p>当然，也可以构建数组的部分元素：</p><pre><code>let arr1 = [1, 2, 3];let arr2 = [0, ...arr1, 4, 5];console.log(arr2); // [0, 1, 2, 3, 4, 5] </code></pre><p>浅复制意味着只会复制对象引用：</p><pre><code>let arr1 = [{}];let arr2 = [...arr1];arr1[0].foo = 'bar';console.log(arr2[0]); // { foo: 'bar' } </code></pre><p>上面的这些类型都支持多种构建方法，比如 Array.of()和 Array.from()静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p><pre><code>let arr1 = [1, 2, 3];// 把数组复制到定型数组let typedArr1 = Int16Array.of(...arr1);let typedArr2 = Int16Array.from(arr1);console.log(typedArr1); // Int16Array [1, 2, 3]console.log(typedArr2); // Int16Array [1, 2, 3]// 把数组复制到映射let map = new Map(arr1.map((x) =&gt; [x, 'val' + x]));console.log(map); // Map {1 =&gt; 'val 1', 2 =&gt; 'val 2', 3 =&gt; 'val 3'}// 把数组复制到集合let set = new Set(typedArr2);console.log(set); // Set {1, 2, 3}// 把集合复制回数组let arr2 = [...set];console.log(arr2); // [1, 2, 3] </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0010.html"/>
      <url>posts/a0010.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0009">集合引用类型(六) Set</a></strong><br>本篇: <strong>集合引用类型(七) WeakSet</strong><br>下篇: <strong><a href="a0011">集合引用类型(八) 迭代与扩展操作</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>ECMAScript 6 新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。WeakSet 是 Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>可以使用 new 关键字实例化一个空的 WeakSet：</p><p><code>const ws = new WeakSet(); </code></p><p>弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出TypeError。如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：</p><pre><code>const val1 = {id: 1},val2 = {id: 2},val3 = {id: 3};// 使用数组初始化弱集合const ws1 = new WeakSet([val1, val2, val3]);alert(ws1.has(val1)); // truealert(ws1.has(val2)); // truealert(ws1.has(val3)); // true// 初始化是全有或全无的操作// 只要有一个值无效就会抛出错误，导致整个初始化失败const ws2 = new WeakSet([val1, "BADVAL", val3]);// TypeError: Invalid value used in WeakSettypeof ws2;// ReferenceError: ws2 is not defined// 原始值可以先包装成对象再用作值const stringVal = new String("val1");const ws3 = new WeakSet([stringVal]);alert(ws3.has(stringVal)); // true </code></pre><p>初始化之后可以使用 add()再添加新值，可以使用 has()查询，还可以使用 delete()删除：</p><pre><code>const ws = new WeakSet();const val1 = {id: 1},      val2 = {id: 2};alert(ws.has(val1)); // falsews.add(val1).add(val2);alert(ws.has(val1)); // truealert(ws.has(val2)); // truews.delete(val1); // 只删除这一个值alert(ws.has(val1)); // falsealert(ws.has(val2)); // true </code></pre><p>add()方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const val1 = {id: 1},val2 = {id: 2},val3 = {id: 3};const ws = new WeakSet().add(val1);ws.add(val2).add(val3);alert(ws.has(val1)); // truealert(ws.has(val2)); // truealert(ws.has(val3)); // true</code></pre><h2 id="弱值"><a href="#弱值" class="headerlink" title="弱值"></a>弱值</h2><p>WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。来看下面的例子：</p><pre><code>const ws = new WeakSet();ws.add({}); </code></pre><p>add()方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集合。再看一个稍微不同的例子：</p><pre><code>const ws = new WeakSet();const container = {    val: {}};ws.add(container.val);function removeReference() {    container.val = null;} </code></pre><p>这一次，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0009.html"/>
      <url>posts/a0009.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0008">集合引用类型(五) WeakMap</a></strong><br>本篇: <strong>集合引用类型(六) Set</strong><br>下篇: <strong><a href="a0010">集合引用类型(七) WeakSet</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>使用 new 关键字和 Set 构造函数可以创建一个空集合：</p><p><code>const m = new Set(); </code></p><p>如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素：</p><pre><code>// 使用数组初始化集合const s1 = new Set(["val1", "val2", "val3"]);alert(s1.size); // 3// 使用自定义迭代器初始化集合const s2 = new Set({[Symbol.iterator]: function*() {    yield "val1";    yield "val2";    yield "val3";}});alert(s2.size); // 3</code></pre><p>初始化之后，可以使用 add()增加值，使用 has()查询，通过 size 取得元素数量，以及使用 delete()和 clear()删除元素：</p><pre><code>const s = new Set();alert(s.has("Matt")); // falsealert(s.size); // 0s.add("Matt").add("Frisbie");alert(s.has("Matt")); // truealert(s.size); // 2s.delete("Matt");alert(s.has("Matt")); // falsealert(s.has("Frisbie")); // truealert(s.size); // 1s.clear(); // 销毁集合实例中的所有值alert(s.has("Matt")); // falsealert(s.has("Frisbie")); // falsealert(s.size); // 0 </code></pre><p>add()返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：</p><pre><code>const s = new Set().add("val1");s.add("val2").add("val3");alert(s.size); // 3 </code></pre><p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作,基本上相当于使用严格对象相等的标准来检查值的匹配性。</p><pre><code>const s = new Set();const functionVal = function() {};const symbolVal = Symbol();const objectVal = new Object();s.add(functionVal);s.add(symbolVal);s.add(objectVal);alert(s.has(functionVal)); // truealert(s.has(symbolVal)); // truealert(s.has(objectVal)); // true// SameValueZero 检查意味着独立的实例不会冲突alert(s.has(function() {})); // false </code></pre><p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p><pre><code>const s = new Set();const objVal = {},      arrVal = [];s.add(objVal);s.add(arrVal);objVal.bar = "bar";arrVal.push("bar");alert(s.has(objVal)); // truealert(s.has(arrVal)); // true</code></pre><p>add()和 delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值：</p><pre><code>const s = new Set();s.add('foo');alert(s.size); // 1s.add('foo');alert(s.size); // 1// 集合里有这个值alert(s.delete('foo')); // true// 集合里没有这个值alert(s.delete('foo')); // false</code></pre><h2 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p>Set 会维护值插入时的顺序，因此支持按顺序迭代。</p><p>集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);for (let value of s.values()) {    alert(value);}// val1// val2// val3 </code></pre><p>因为 values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);console.log([...s]); // ["val1", "val2", "val3"] </code></pre><p>集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);for (let pair of s.entries()) {    console.log(pair);}// ["val1", "val1"]// ["val2", "val2"]// ["val3", "val3"] </code></pre><p>使用迭代器，而是使用回调方式，则可以调用集合的 forEach()方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);s.forEach((val, dupVal) =&gt; alert(`${val} -&gt; ${dupVal}`));// val1 -&gt; val1// val2 -&gt; val2// val3 -&gt; val3 </code></pre><p>修改集合中值的属性不会影响其作为集合值的身份：</p><pre><code>const s1 = new Set(["val1"]);// 字符串原始值作为值不会被修改for (let value of s1.values()) { alert(value); // newValalert(s1.has("val1")); // true}const valObj = {id: 1};const s2 = new Set([valObj]);// 修改值对象的属性，但对象仍然存在于集合中for (let value of s2.values()) {    value.id = "newVal";    alert(value); // {id: "newVal"}    alert(s2.has(valObj)); // true}alert(valObj); // {id: "newVal"} </code></pre><h2 id="定义正式集合操作"><a href="#定义正式集合操作" class="headerlink" title="定义正式集合操作"></a>定义正式集合操作</h2><p>从各方面来看，Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 对自身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。</p><ol><li><p>某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</p></li><li><p>Set 保留插入顺序，所有方法返回的集合必须保证顺序。</p></li><li><p>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</p></li><li><p>不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。</p><p> class XSet extends Set {<br> union(…sets) {</p><pre><code> return XSet.union(this, ...sets)</code></pre><p> }<br> intersection(…sets) {</p><pre><code> return XSet.intersection(this, ...sets);</code></pre><p> }<br> difference(set) {</p><pre><code> return XSet.difference(this, set);</code></pre><p> }<br> symmetricDifference(set) {</p><pre><code> return XSet.symmetricDifference(this, set);</code></pre><p> }<br> cartesianProduct(set) {</p><pre><code> return XSet.cartesianProduct(this, set);</code></pre><p> }<br> powerSet() {</p><pre><code> return XSet.powerSet(this);</code></pre><p> }</p><p>  // 返回两个或更多集合的并集<br> static union(a, …bSets) {</p><pre><code> const unionSet = new XSet(a); for (const b of bSets) {     for (const bValue of b) {     unionSet.add(bValue);     } } return unionSet;</code></pre><p> } </p><p> // 返回两个或更多集合的交集<br> static intersection(a, …bSets) {</p><pre><code> const intersectionSet = new XSet(a); for (const aValue of intersectionSet) {     for (const b of bSets) {         if (!b.has(aValue)) {         intersectionSet.delete(aValue);         }     } } return intersectionSet;</code></pre><p> } </p><p>  // 返回两个集合的差集<br> static difference(a, b) {</p><pre><code> const differenceSet = new XSet(a); for (const bValue of b) {     if (a.has(bValue)) {         differenceSet.delete(bValue);     } } return differenceSet;</code></pre><p> } </p><p>  // 返回两个集合的对称差集<br> static symmetricDifference(a, b) {</p><pre><code> // 按照定义，对称差集可以表达为 return a.union(b).difference(a.intersection(b));</code></pre><p> } </p><p> // 返回两个集合（数组对形式）的笛卡儿积<br> // 必须返回数组集合，因为笛卡儿积可能包含相同值的对<br> static cartesianProduct(a, b) {</p><pre><code> const cartesianProductSet = new XSet(); for (const aValue of a) {     for (const bValue of b) {         cartesianProductSet.add([aValue, bValue]);     } } return cartesianProductSet;</code></pre><p> } </p><p>  // 返回一个集合的幂集<br> static powerSet(a) {</p><pre><code> const powerSet = new XSet().add(new XSet());     for (const aValue of a) {          for (const set of new XSet(powerSet)) {             powerSet.add(new XSet(set).add(aValue));         }     } return powerSet; }</code></pre><p> } </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0008.html"/>
      <url>posts/a0008.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0007">集合引用类型(四) Map</a></strong><br>本篇: <strong>集合引用类型(五) WeakMap</strong><br>下篇: <strong><a href="a0009">集合引用类型(六) Set</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。</p><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><p>可以使用 new 关键字实例化一个空的 WeakMap：</p><p><code>const wm = new WeakMap(); </code></p><p>弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。</p><p>如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：</p><pre><code>const key1 = {id: 1},      key2 = {id: 2},       key3 = {id: 3};// 使用嵌套数组初始化弱映射const wm1 = new WeakMap([    [key1, "val1"],    [key2, "val2"],    [key3, "val3"]]);alert(wm1.get(key1)); // val1alert(wm1.get(key2)); // val2alert(wm1.get(key3)); // val3// 初始化是全有或全无的操作// 只要有一个键无效就会抛出错误，导致整个初始化失败const wm2 = new WeakMap([    [key1, "val1"],    ["BADKEY", "val2"],    [key3, "val3"]]);// TypeError: Invalid value used as WeakMap keytypeof wm2;// ReferenceError: wm2 is not defined// 原始值可以先包装成对象再用作键const stringKey = new String("key1");const wm3 = new WeakMap([    stringKey, "val1"]);alert(wm3.get(stringKey)); // "val1" </code></pre><p>初始化之后可以使用 set()再添加键/值对，可以使用 get()和 has()查询，还可以使用 delete()删除：</p><pre><code>const wm = new WeakMap();const key1 = {id: 1},      key2 = {id: 2};alert(wm.has(key1)); // falsealert(wm.get(key1)); // undefinedwm.set(key1, "Matt").set(key2, "Frisbie");alert(wm.has(key1)); // truealert(wm.get(key1)); // Mattwm.delete(key1); // 只删除这一个键/值对alert(wm.has(key1)); // falsealert(wm.has(key2)); // true </code></pre><p>set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const key1 = {id: 1},    key2 = {id: 2},    key3 = {id: 3};const wm = new WeakMap().set(key1, "val1"); wm.set(key2, "val2").set(key3, "val3");alert(wm.get(key1)); // val1alert(wm.get(key2)); // val2alert(wm.get(key3)); // val3</code></pre><h2 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h2><p>WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。来看下面的例子：</p><pre><code>const wm = new WeakMap();wm.set({}, "val"); </code></pre><p>set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。再看一个稍微不同的例子：</p><pre><code>const wm = new WeakMap();const container = {    key: {}};wm.set(container.key, "val");function removeReference() {    container.key = null;} </code></pre><p>这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0007.html"/>
      <url>posts/a0007.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0006">集合引用类型(三) 定型数组</a></strong><br>本篇: <strong>集合引用类型(四) Map</strong><br>下篇: <strong><a href="a0008">集合引用类型(五) WeakMap</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ECMAScript 6 以前，在 JavaScript 中实现“键/值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此 TC39 委员会专门为“键/值”存储定义了一个规范。</p><p>作为 ECMAScript 6 的新增特性，Map 是一种新的集合类型，为这门语言带来了真正的键/值存储机制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>使用 new 关键字和 Map 构造函数可以创建一个空映射：</p><p><code>const m = new Map(); </code></p><p>如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：</p><pre><code>// 使用嵌套数组初始化映射const m1 = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);alert(m1.size); // 3// 使用自定义迭代器初始化映射const m2 = new Map({[Symbol.iterator]: function*() {    yield ["key1", "val1"];    yield ["key2", "val2"];    yield ["key3", "val3"];}});alert(m2.size); // 3 const m3 = new Map([[]]);alert(m3.has(undefined)); // truealert(m3.get(undefined)); // undefined</code></pre><p>初始化之后，可以使用 set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键/值对的数量，还可以使用 delete()和 clear()删除值。</p><pre><code>const m = new Map();alert(m.has("firstName")); // falsealert(m.get("firstName")); // undefinedalert(m.size); // 0m.set("firstName", "Matt").set("lastName", "Frisbie");alert(m.has("firstName")); // truealert(m.get("firstName")); // Mattalert(m.size); // 2m.delete("firstName"); // 只删除这一个键/值对alert(m.has("firstName")); // falsealert(m.has("lastName")); // truealert(m.size); // 1m.clear(); // 清除这个映射实例中的所有键/值对alert(m.has("firstName")); // falsealert(m.has("lastName")); // falsealert(m.size); // 0 </code></pre><p>set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const m = new Map().set("key1", "val1");m.set("key2", "val2").set("key3", "val3");alert(m.size); // 3</code></pre><p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键。与 Object 类似，映射的值是没有限制的。</p><pre><code>const m = new Map();const functionKey = function() {};const symbolKey = Symbol();const objectKey = new Object();m.set(functionKey, "functionValue");m.set(symbolKey, "symbolValue");m.set(objectKey, "objectValue");alert(m.get(functionKey)); // functionValuealert(m.get(symbolKey)); // symbolValuealert(m.get(objectKey)); // objectValue// SameValueZero 比较意味着独立实例不冲突alert(m.get(function() {})); // undefined </code></pre><p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p><pre><code>const m = new Map();const objKey = {},      objVal = {},      arrKey = [],      arrVal = [];m.set(objKey, objVal);m.set(arrKey, arrVal);objKey.foo = "foo";objVal.bar = "bar";arrKey.push("foo");arrVal.push("bar");console.log(m.get(objKey)); // {bar: "bar"}console.log(m.get(arrKey)); // ["bar"] </code></pre><h2 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p>与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过 entries()方法取得这个迭代器：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);for (let pair of m.entries()) {alert(pair);}// [key1,val1]// [key2,val2]// [key3,val3] </code></pre><p>因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]] </code></pre><p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);m.forEach((val, key) =&gt; alert(`${key} -&gt; ${val}`));// key1 -&gt; val1// key2 -&gt; val2// key3 -&gt; val3 </code></pre><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p><pre><code>const m1 = new Map([    ["key1", "val1"]]);// 作为键的字符串原始值是不能修改的for (let key of m1.keys()) {    key = "newKey";    alert(key); // newKey    alert(m1.get("key1")); // val1}const keyObj = {id: 1};const m = new Map([[keyObj, "val1"]]); // 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值for (let key of m.keys()) {    key.id = "newKey";    alert(key); // {id: "newKey"}    alert(m.get(keyObj)); // val1}alert(keyObj); // {id: "newKey"}</code></pre><h2 id="选择-Object-还是-Map"><a href="#选择-Object-还是-Map" class="headerlink" title="选择 Object 还是 Map"></a>选择 Object 还是 Map</h2><p>对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p><ol><li><p>内存占用<br>Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。</p></li><li><p>插入性能<br>向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</p></li><li><p>查找速度<br>与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</p></li><li><p>删除性能<br>使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0006.html"/>
      <url>posts/a0006.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0005">集合引用类型(二) Array</a></strong><br>本篇: <strong>集合引用类型(三) 定型数组</strong><br>下篇: <strong><a href="a0007">集合引用类型(四) Map</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h1><h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p>Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。</p><p>ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。</p><pre><code>const buf = new ArrayBuffer(16); // 在内存中分配 16 字节alert(buf.byteLength); // 16 </code></pre><p>ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中：</p><pre><code>const buf1 = new ArrayBuffer(16);const buf2 = buf1.slice(4, 12);alert(buf2.byteLength); // 8</code></pre><p>ArrayBuffer 某种程度上类似于 C++的 malloc()，但也有几个明显的区别。</p><ol><li><p>malloc()在分配失败时会返回一个 null 指针。ArrayBuffer 在分配失败时会抛出错误。</p></li><li><p>malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer分配的内存不能超过 Number.MAX_SAFE_INTEGER（2^53 - 1）字节。</p></li><li><p>malloc()调用成功不会初始化实际的地址。声明 ArrayBuffer 则会将所有二进制位初始化为 0。</p></li><li><p>通过 malloc()分配的堆内存除非调用 free()或程序退出，否则系统不能再使用。而通过声明ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。</p></li></ol><p>不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。</p><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。</p><p>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><pre><code>const buf = new ArrayBuffer(16);// DataView 默认使用整个 ArrayBufferconst fullDataView = new DataView(buf);alert(fullDataView.byteOffset); // 0alert(fullDataView.byteLength); // 16alert(fullDataView.buffer === buf); // true// 构造函数接收一个可选的字节偏移量和字节长度// byteOffset=0 表示视图从缓冲起点开始// byteLength=8 限制视图为前 8 个字节const firstHalfDataView = new DataView(buf, 0, 8);alert(firstHalfDataView.byteOffset); // 0alert(firstHalfDataView.byteLength); // 8alert(firstHalfDataView.buffer === buf); // true// 如果不指定，则 DataView 会使用剩余的缓冲// byteOffset=8 表示视图从缓冲的第 9 个字节开始// byteLength 未指定，默认为剩余缓冲const secondHalfDataView = new DataView(buf, 8);alert(secondHalfDataView.byteOffset); // 8 alert(secondHalfDataView.byteLength); // 8alert(secondHalfDataView.buffer === buf); // true </code></pre><p>要通过 DataView 读取缓冲，还需要几个组件。</p><ol><li><p>首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。</p></li><li><p>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。</p></li><li><p>最后是内存中值的字节序。默认为大端字节序。</p></li></ol><h3 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a>ElementType</h3><p>DataView 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。</p><p>ECMAScript 6 支持 8 种不同的 ElementType</p><table><thead><tr><th align="left">ElementType</th><th align="left">字 节</th><th align="left">说 明</th><th align="left">等价的 C 类型</th><th align="left">值的范围</th></tr></thead><tbody><tr><td align="left">Int8</td><td align="left">1</td><td align="left">8 位有符号整数</td><td align="left">signed char</td><td align="left">-128~127</td></tr><tr><td align="left">Uint8</td><td align="left">1</td><td align="left">8 位无符号整数</td><td align="left">unsigned char</td><td align="left">0~255</td></tr><tr><td align="left">Int16</td><td align="left">2</td><td align="left">16 位有符号整数</td><td align="left">short</td><td align="left">-32768~32767</td></tr><tr><td align="left">Uint16</td><td align="left">2</td><td align="left">16 位无符号整数</td><td align="left">unsigned short</td><td align="left">0~65535</td></tr><tr><td align="left">Int32</td><td align="left">4</td><td align="left">32 位有符号整数</td><td align="left">int</td><td align="left">-2147483648~2147483647</td></tr><tr><td align="left">Uint32</td><td align="left">4</td><td align="left">32 位无符号整数</td><td align="left">unsigned int</td><td align="left">0~4294967295</td></tr><tr><td align="left">Float32</td><td align="left">4</td><td align="left">32 位 IEEE-754 浮点数</td><td align="left">float</td><td align="left">-3.4e+38~+3.4e+38</td></tr><tr><td align="left">Float64</td><td align="left">8</td><td align="left">64 位 IEEE-754 浮点数</td><td align="left">double</td><td align="left">-1.7e+308~+1.7e+308</td></tr></tbody></table><p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：</p><pre><code>// 在内存中分配两个字节并声明一个 DataViewconst buf = new ArrayBuffer(2);const view = new DataView(buf);// 说明整个缓冲确实所有二进制位都是 0// 检查第一个和第二个字符alert(view.getInt8(0)); // 0alert(view.getInt8(1)); // 0// 检查整个缓冲alert(view.getInt16(0)); // 0// 将整个缓冲都设置为 1// 255 的二进制表示是 11111111（2^8 - 1）view.setUint8(0, 255);// DataView 会自动将数据转换为特定的 ElementType// 255 的十六进制表示是 0xFFview.setUint8(1, 0xFF);// 现在，缓冲里都是 1 了// 如果把它当成二补数的有符号整数，则应该是-1alert(view.getInt16(0)); // -1 </code></pre><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p><p>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。</p><pre><code>// 在内存中分配两个字节并声明一个 DataViewconst buf = new ArrayBuffer(2);const view = new DataView(buf);// 填充缓冲，让第一位和最后一位都是 1view.setUint8(0, 0x80); // 设置最左边的位等于 1view.setUint8(1, 0x01); // 设置最右边的位等于 1// 缓冲内容（为方便阅读，人为加了空格）// 0x8 0x0 0x0 0x1// 1000 0000 0000 0001// 按大端字节序读取 Uint16// 0x80 是高字节，0x01 是低字节// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769alert(view.getUint16(0)); // 32769// 按小端字节序读取 Uint16// 0x01 是高字节，0x80 是低字节// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384alert(view.getUint16(0, true)); // 384// 按大端字节序写入 Uint16view.setUint16(0, 0x0004);// 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x0 0x0 0x4// 0000 0000 0000 0100alert(view.getUint8(0)); // 0alert(view.getUint8(1)); // 4// 按小端字节序写入 Uint16view.setUint16(0, 0x0002, true);// 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x2 0x0 0x0// 0000 0010 0000 0000alert(view.getUint8(0)); // 2alert(view.getUint8(1)); // 0 </code></pre><h3 id="边界情形"><a href="#边界情形" class="headerlink" title="边界情形"></a>边界情形</h3><p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p><pre><code>const buf = new ArrayBuffer(6);const view = new DataView(buf);// 尝试读取部分超出缓冲范围的值view.getInt32(4);// RangeError// 尝试读取超出缓冲范围的值view.getInt32(8);// RangeError// 尝试读取超出缓冲范围的值view.getInt32(-1);// RangeError// 尝试写入超出缓冲范围的值view.setInt32(4, 123);// RangeError </code></pre><p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p><pre><code>const buf = new ArrayBuffer(1);const view = new DataView(buf);view.setInt8(0, 1.5);alert(view.getInt8(0)); // 1view.setInt8(0, [4]);alert(view.getInt8(0)); // 4view.setInt8(0, 'f');alert(view.getInt8(0)); // 0view.setInt8(0, Symbol());// TypeError </code></pre><h2 id="定型数组-1"><a href="#定型数组-1" class="headerlink" title="定型数组"></a>定型数组</h2><p>定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。</p><p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过&lt; ElementType&gt;.from()和&lt; ElementType&gt;.of()也可以创建定型数组：</p><pre><code>// 创建一个 12 字节的缓冲const buf = new ArrayBuffer(12);// 创建一个引用该缓冲的 Int32Arrayconst ints = new Int32Array(buf);// 这个定型数组知道自己的每个元素需要 4 字节// 因此长度为 3alert(ints.length); // 3 // 创建一个长度为 6 的 Int32Arrayconst ints2 = new Int32Array(6);// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节alert(ints2.length); // 6// 类似 DataView，定型数组也有一个指向关联缓冲的引用alert(ints2.buffer.byteLength); // 24// 创建一个包含[2, 4, 6, 8]的 Int32Arrayconst ints3 = new Int32Array([2, 4, 6, 8]);alert(ints3.length); // 4alert(ints3.buffer.byteLength); // 16alert(ints3[2]); // 6// 通过复制 ints3 的值创建一个 Int16Arrayconst ints4 = new Int16Array(ints3);// 这个新类型数组会分配自己的缓冲// 对应索引的每个值会相应地转换为新格式alert(ints4.length); // 4alert(ints4.buffer.byteLength); // 8alert(ints4[2]); // 6// 基于普通数组来创建一个 Int16Arrayconst ints5 = Int16Array.from([3, 5, 7, 9]);alert(ints5.length); // 4alert(ints5.buffer.byteLength); // 8alert(ints5[2]); // 7// 基于传入的参数创建一个 Float32Arrayconst floats = Float32Array.of(3.14, 2.718, 1.618);alert(floats.length); // 3alert(floats.buffer.byteLength); // 12alert(floats[2]); // 1.6180000305175781 </code></pre><p>定型数组的构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小：</p><pre><code>alert(Int16Array.BYTES_PER_ELEMENT); // 2alert(Int32Array.BYTES_PER_ELEMENT); // 4const ints = new Int32Array(1),floats = new Float64Array(1);alert(ints.BYTES_PER_ELEMENT); // 4alert(floats.BYTES_PER_ELEMENT); // 8 </code></pre><p>如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：</p><pre><code>const ints = new Int32Array(4);alert(ints[0]); // 0alert(ints[1]); // 0alert(ints[2]); // 0alert(ints[3]); // 0 </code></pre><h3 id="定型数组行为"><a href="#定型数组行为" class="headerlink" title="定型数组行为"></a>定型数组行为</h3><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：</p><ol><li><p>[]</p></li><li><p>copyWithin()</p></li><li><p>entries()</p></li><li><p>every()</p></li><li><p>fill()</p></li><li><p>filter()</p></li><li><p>find()</p></li><li><p>findIndex()</p></li><li><p>forEach()</p></li><li><p>indexOf()</p></li><li><p>join()</p></li><li><p>keys()</p></li><li><p>lastIndexOf()</p></li><li><p>length</p></li><li><p>map()</p></li><li><p>reduce()</p></li><li><p>reduceRight()</p></li><li><p>reverse()</p></li><li><p>slice()</p></li><li><p>some()</p></li><li><p>sort()</p></li><li><p>toLocaleString()</p></li><li><p>toString()</p></li><li><p>values()</p></li></ol><p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p><pre><code>const ints = new Int16Array([1, 2, 3]);const doubleints = ints.map(x =&gt; 2*x);alert(doubleints instanceof Int16Array); // true</code></pre><p>定型数组有一个 Symbol.iterator 符号属性，因此可以通过 for..of 循环和扩展操作符来操作：</p><pre><code>const ints = new Int16Array([1, 2, 3]);for (const int of ints) {    alert(int);}// 1// 2// 3alert(Math.max(...ints)); // 3 </code></pre><h3 id="合并、复制和修改定型数组"><a href="#合并、复制和修改定型数组" class="headerlink" title="合并、复制和修改定型数组"></a>合并、复制和修改定型数组</h3><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p><ol><li><p>concat()</p></li><li><p>pop()</p></li><li><p>push()</p></li><li><p>shift()</p></li><li><p>splice()</p></li><li><p>unshift()</p></li></ol><p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set()和 subarray()。set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p><pre><code>// 创建长度为 8 的 int16 数组const container = new Int16Array(8);// 把定型数组复制为前 4 个值// 偏移量默认为索引 0container.set(Int8Array.of(1, 2, 3, 4));console.log(container); // [1,2,3,4,0,0,0,0]// 把普通数组复制为后 4 个值// 偏移量 4 表示从索引 4 开始插入container.set([5,6,7,8], 4);console.log(container); // [1,2,3,4,5,6,7,8]// 溢出会抛出错误container.set([5,6,7,8], 7);// RangeError </code></pre><p>subarray()执行与 set()相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p><pre><code>const source = Int16Array.of(2, 4, 6, 8);// 把整个数组复制为一个同类型的新数组const fullCopy = source.subarray();console.log(fullCopy); // [2, 4, 6, 8]// 从索引 2 开始复制数组const halfCopy = source.subarray(2);console.log(halfCopy); // [6, 8]// 从索引 1 开始复制到索引 3const partialCopy = source.subarray(1, 3);console.log(partialCopy); // [4, 6]</code></pre><p>定型数组没有原生的拼接能力，但使用定型数组 API 提供的很多工具可以手动构建：</p><pre><code>// 第一个参数是应该返回的数组类型// 其余参数是应该拼接在一起的定型数组function typedArrayConcat(typedArrayConstructor, ...typedArrays) {    // 计算所有数组中包含的元素总数    const numElements = typedArrays.reduce((x,y) =&gt; (x.length || x) + y.length);    // 按照提供的类型创建一个数组，为所有元素留出空间    const resultArray = new typedArrayConstructor(numElements);    // 依次转移数组    let currentOffset = 0;    typedArrays.map(x =&gt; {        resultArray.set(x, currentOffset);        currentOffset += x.length;    });    return resultArray;}const concatArray = typedArrayConcat(Int32Array,                                     Int8Array.of(1, 2, 3),                                     Int16Array.of(4, 5, 6),                                     Float32Array.of(7, 8, 9));console.log(concatArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(concatArray instanceof Int32Array); // true</code></pre><h3 id="下溢和上溢"><a href="#下溢和上溢" class="headerlink" title="下溢和上溢"></a>下溢和上溢</h3><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：</p><pre><code>// 长度为 2 的有符号整数数组// 每个索引保存一个二补数形式的有符号整数// 范围是-128（-1 * 2^7）~127（2^7 - 1）const ints = new Int8Array(2);// 长度为 2 的无符号整数数组// 每个索引保存一个无符号整数// 范围是 0~255（2^7 - 1）const unsignedInts = new Uint8Array(2);// 上溢的位不会影响相邻索引// 索引只取最低有效位上的 8 位unsignedInts[1] = 256; // 0x100console.log(unsignedInts); // [0, 0]unsignedInts[1] = 511; // 0x1FFconsole.log(unsignedInts); // [0, 255]// 下溢的位会被转换为其无符号的等价值// 0xFF 是以二补数形式表示的-1（截取到 8 位）,// 但 255 是一个无符号整数unsignedInts[1] = -1 // 0xFF (truncated to 8 bits)console.log(unsignedInts); // [0, 255]// 上溢自动变成二补数形式// 0x80 是无符号整数的 128，是二补数形式的-128ints[1] = 128; // 0x80console.log(ints); // [0, -128]// 下溢自动变成二补数形式// 0xFF 是无符号整数的 255，是二补数形式的-1ints[1] = 255; // 0xFFconsole.log(ints); // [0, -1] </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0005.html"/>
      <url>posts/a0005.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0004">集合引用类型(一) Object</a></strong><br>本篇: <strong>集合引用类型(二) Array</strong><br>下篇: <strong><a href="a0006">集合引用类型(三) 定型数组</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加自动增长。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：</p><p><code>let colors = new Array(); </code></p><p>如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始 length 为 20 的数组：</p><p><code>let colors = new Array(20); </code></p><p>也可以给 Array 构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的数组：</p><p><code>let colors = new Array("red", "blue", "green"); </code></p><p>另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个元素的数组let names = []; // 创建一个空数组let values = [1,2,]; // 创建一个包含 2 个元素的数组</code></pre><p><strong>注意</strong> 与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。</p><p>Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。</p><p>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很多场合：</p><pre><code>// 字符串会被拆分为单字符数组console.log(Array.from("Matt")); // ["M", "a", "t", "t"]// 可以使用 from()将集合和映射转换为一个新数组const m = new Map().set(1, 2).set(3, 4);const s = new Set().add(1).add(2).add(3).add(4);console.log(Array.from(m)); // [[1, 2], [3, 4]]console.log(Array.from(s)); // [1, 2, 3, 4]// Array.from()对现有数组执行浅复制const a1 = [1, 2, 3, 4];const a2 = Array.from(a1);console.log(a1); // [1, 2, 3, 4]alert(a1 === a2); // false// 可以使用任何可迭代对象const iter = {    *[Symbol.iterator]() {        yield 1;        yield 2;        yield 3;        yield 4;    }};console.log(Array.from(iter)); // [1, 2, 3, 4] // arguments 对象可以被轻松地转换为数组function getArgsArray() {    return Array.from(arguments);}console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]// from()也能转换带有必要属性的自定义对象const arrayLikeObject = {    0: 1,    1: 2,    2: 3,    3: 4,    length: 4};console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]</code></pre><p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。但这个重写的 this 值在箭头函数中不适用。</p><pre><code>const a1 = [1, 2, 3, 4];const a2 = Array.from(a1, x =&gt; x**2);const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});console.log(a2); // [1, 4, 9, 16]console.log(a3); // [1, 4, 9, 16] </code></pre><p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</p><pre><code>console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]console.log(Array.of(undefined)); // [undefined]</code></pre><h2 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h2><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。可以像下面这样创建一个空位数组：</p><pre><code>const options = [,,,,,]; // 创建包含 5 个元素的数组console.log(options.length); // 5console.log(options); // [,,,,,]</code></pre><p>ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：</p><pre><code>const options = [1,,,,5];for (const option of options) {console.log(option === undefined);}// false// true// true// true// false </code></pre><p><strong>注意</strong> 由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替。</p><h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 定义一个字符串数组alert(colors[0]); // 显示第一项colors[2] = "black"; // 修改第三项colors[3] = "brown"; // 添加第四项</code></pre><p>使用 length 属性可以方便地向数组末尾添加元素，如下例所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[colors.length] = "black"; // 添加一种颜色（位置 3）colors[colors.length] = "brown"; // 再添加一种颜色（位置 4）</code></pre><p>length 属性会更新为位置加上 1，如下例所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[99] = "black"; // 添加一种颜色（位置 99）alert(colors.length); // 100</code></pre><p>这里，colors 数组有一个值被插入到位置 99，结果新 length 就变成了 100（99 + 1）。这中间的所有元素，即位置 3~98，实际上并不存在，因此在访问时会返回 undefined。</p><p><strong>注意</strong> 数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误</p><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣：</p><pre><code>if (value instanceof Array){// 操作数组} </code></pre><p>使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。</p><p>为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p><pre><code>if (Array.isArray(value)){// 操作数组} </code></pre><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><p>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引/值对的迭代器：</p><pre><code>const a = ["foo", "bar", "baz", "qux"];// 因为这些方法都返回迭代器，所以可以将它们的内容// 通过 Array.from()直接转换为数组实例const aKeys = Array.from(a.keys());const aValues = Array.from(a.values());const aEntries = Array.from(a.entries());console.log(aKeys); // [0, 1, 2, 3]console.log(aValues); // ["foo", "bar", "baz", "qux"]console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]] </code></pre><p>使用 ES6 的解构可以非常容易地在循环中拆分键/值对：</p><pre><code>const a = ["foo", "bar", "baz", "qux"];    for (const [idx, element] of a.entries()) {    alert(idx);    alert(element);}// 0// foo// 1// bar// 2// baz// 3// qux</code></pre><h2 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h2><p>ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p><p>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p><pre><code>const zeroes = [0, 0, 0, 0, 0];// 用 5 填充整个数组zeroes.fill(5);console.log(zeroes); // [5, 5, 5, 5, 5]zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素zeroes.fill(6, 3);console.log(zeroes); // [0, 0, 0, 6, 6]zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素zeroes.fill(7, 1, 3);console.log(zeroes); // [0, 7, 7, 0, 0];zeroes.fill(0); // 重置// 用 8 填充索引大于等于 1 且小于 4 的元素// (-4 + zeroes.length = 1)// (-1 + zeroes.length = 4)zeroes.fill(8, -4, -1);console.log(zeroes); // [0, 8, 8, 8, 0];fill()静默忽略超出数组边界、零长度及方向相反的索引范围：const zeroes = [0, 0, 0, 0, 0];// 索引过低，忽略zeroes.fill(1, -10, -6);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引过高，忽略zeroes.fill(1, 10, 15);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引反向，忽略zeroes.fill(2, 4, 2);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引部分可用，填充可用部分zeroes.fill(4, 3, 10)console.log(zeroes); // [0, 0, 0, 4, 4] </code></pre><p>与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法：</p><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的例子：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,greenalert(colors.valueOf()); // red,blue,greenalert(colors); // red,blue,green </code></pre><p>首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果。</p><p>在调用数组的 toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 toLocaleString()方法，而不是toString()方法。看下面的例子：</p><pre><code>let person1 = {    toLocaleString() {        return "Nikolaos";    },    toString() {        return "Nicholas";    }}; let person2 = {    toLocaleString() {        return "Grigorios";    },    toString() {        return "Greg";    }};let people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nikolaos,Grigorios </code></pre><p>这里定义了两个对象 person1 和 person2，它们都定义了 toString()和 toLocaleString()方法，而且返回不同的值。然后又创建了一个包含这两个对象的数组 people。在将数组传给 alert()时，输出的是”Nicholas,Greg”，这是因为会在数组每一项上调用 toString()方法（与下一行显式调用toString()方法结果一样）。而在调用数组的 toLocaleString()方法时，结果变成了”Nikolaos,Grigorios”，这是因为调用了数组每一项的 toLocaleString()方法。</p><p>继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue"];alert(colors.join(",")); // red,green,bluealert(colors.join("||")); // red||green||blue</code></pre><p>这里在 colors 数组上调用了 join()方法，得到了与调用 toString()方法相同的结果。传入逗号，结果就是逗号分隔的字符串。最后一行给 join() 传入了双竖线，得到了字符串”red||green||blue”。如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。</p><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。</p><p>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.push("red", "green"); // 推入两项alert(count); // 2count = colors.push("black"); // 再推入一项alert(count); // 3let item = colors.pop(); // 取得最后一项alert(item); // blackalert(colors.length); // 2 </code></pre><p>栈方法可以与数组的其他任何方法一起使用，如下例所示：</p><pre><code>let colors = ["red", "blue"];colors.push("brown"); // 再添加一项colors[3] = "black"; // 添加一项alert(colors.length); // 4let item = colors.pop(); // 取得最后一项alert(item); // black </code></pre><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.push("red", "green"); // 推入两项alert(count); // 2count = colors.push("black"); // 再推入一项alert(count); // 3let item = colors.shift(); // 取得第一项alert(item); // redalert(colors.length); // 2 </code></pre><p>ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.unshift("red", "green"); // 从数组开头推入两项alert(count); // 2count = colors.unshift("black"); // 再推入一项alert(count); // 3let item = colors.pop(); // 取得最后一项alert(item); // greenalert(colors.length); // 2 </code></pre><p>这里，先创建一个数组，再通过 unshift()填充数组。首先，给数组添加”red”和”green”，再添<br>加”black”，得到[ “black”,”red”,”green”]。调用 pop()时，删除最后一项”green”并返回它。</p><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就是将数组元素反向排列。比如：</p><pre><code>let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1 </code></pre><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就是将数组元素反向排列。比如：</p><pre><code>let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1 </code></pre><p>一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。</p><p>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一个例子：</p><pre><code>function compare(value1, value2) {    if (value1 &lt; value2) {    return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }} </code></pre><p>这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示：</p><pre><code>let values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15 </code></pre><p>在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：</p><pre><code>function compare(value1, value2) {    if (value1 &lt; value2) {        return 1;    } else if (value1 &gt; value2) {        return -1;    } else {        return 0;    }}let values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0 </code></pre><p>此外，这个比较函数还可简写为一个箭头函数：</p><pre><code>let values = [0, 1, 5, 10, 15];values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0);alert(values); // 15,10,5,1,0 </code></pre><p>如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：</p><pre><code>function compare(value1, value2){    return value2 - value1;}</code></pre><p>比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue"];let colors2 = colors.concat("yellow", ["black", "brown"]);console.log(colors); // ["red", "green","blue"]console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"] </code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如   果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue", "yellow", "purple"];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow </code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice()方法的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。</p><ol><li><p>删除。需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。</p></li><li><p>插入。需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串”red”和”green”。</p></li><li><p>替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入”red”和”green”。</p><p> let colors = [“red”, “green”, “blue”];<br> let removed = colors.splice(0,1); // 删除第一项<br> alert(colors); // green,blue<br> alert(removed); // red，只有一个元素的数组</p><p> removed = colors.splice(1, 0, “yellow”, “orange”); // 在位置 1 插入两个元素<br> alert(colors); // green,yellow,orange,blue<br> alert(removed); // 空数组</p><p> removed = colors.splice(1, 1, “red”, “purple”); // 插入两个值，删除一个元素<br> alert(colors); // green,red,purple,orange,blue<br> alert(removed); // yellow，只有一个元素的数组</p></li></ol><h2 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h2><h3 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h3><p>ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索</p><p>indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较，也就是说两项必须严格相等。下面来看一些例子：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];alert(numbers.indexOf(4)); // 3alert(numbers.lastIndexOf(4)); // 5alert(numbers.includes(4)); // truealert(numbers.indexOf(4, 4)); // 5alert(numbers.lastIndexOf(4, 4)); // 3alert(numbers.includes(4, 7)); // falselet person = { name: "Nicholas" };let people = [{ name: "Nicholas" }];let morePeople = [person];alert(people.indexOf(person)); // -1alert(morePeople.indexOf(person)); // 0alert(people.includes(person)); // falsealert(morePeople.includes(person)); // true </code></pre><h3 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h3><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p><p>find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。</p><pre><code>const people = [    {        name: "Matt",        age: 27    },{        name: "Nicholas",        age: 29    }];alert(people.find((element, index, array) =&gt; element.age &lt; 28));// {name: "Matt", age: 27}alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28));// 0 </code></pre><p>找到匹配项后，这两个方法都不再继续搜索。</p><pre><code>const evens = [2, 4, 6];// 找到匹配后，永远不会检查数组的最后一个元素evens.find((element, index, array) =&gt; {    console.log(element);    console.log(index);    console.log(array);    return element === 4;});// 2// 0// [2, 4, 6]// 4// 1// [2, 4, 6] </code></pre><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身。</p><ol><li><p>every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</p></li><li><p>filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</p></li><li><p>forEach()：对数组每一项都运行传入的函数，没有返回值。</p></li><li><p>map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</p></li><li><p>some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</p></li></ol><p>这些方法都不改变调用它们的数组。</p><p>在这些方法中，every()和 some()是最相似的，都是从数组中搜索符合某个条件的元素。对 every()来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 some()来说，只要有一项让传入的函数返回 true，它就会返回 true。下面是一个例子：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);alert(everyResult); // falselet someResult = numbers.some((item, index, array) =&gt; item &gt; 2);alert(someResult); // true </code></pre><p>下面再看一看 filter()方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);alert(filterResult); // 3,4,5,4,3 </code></pre><p>这里，调用 filter()返回的数组包含 3、4、5、4、3，因为只有对这些项传入的函数才返回 true。这个方法非常适合从数组中筛选满足给定条件的元素。</p><p>接下来 map()方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let mapResult = numbers.map((item, index, array) =&gt; item * 2);alert(mapResult); // 2,4,6,8,10,8,6,4,2</code></pre><p>以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原始数组元素一一对应的新数组。</p><p>最后，再来看一看 forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，forEach()方法相当于使用 for 循环遍历数组。比如：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach((item, index, array) =&gt; {    // 执行某些操作}); </code></pre><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。</p><p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。</p><p>如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><p>可以使用 reduce()函数执行累加数组中所有数值的操作，比如：</p><pre><code>let values = [1, 2, 3, 4, 5];let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur);alert(sum); // 15</code></pre><p>reduceRight()方法与之类似，只是方向相反。来看下面的例子：</p><pre><code>let values = [1, 2, 3, 4, 5];let sum = values.reduceRight(function(prev, cur, index, array){return prev + cur;});alert(sum); // 15 </code></pre><p>在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。当然，最终结果相同，因为归并操作都是简单的加法。究竟是使用 reduce()还是 reduceRight()，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0004.html"/>
      <url>posts/a0004.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0003">基本引用类型(四) 单例内置对象</a></strong><br>本篇: <strong>集合引用类型(一) Object</strong><br>下篇: <strong><a href="a0005">集合引用类型(二) Array</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="Objcet"><a href="#Objcet" class="headerlink" title="Objcet"></a>Objcet</h2><p>到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。</p><p>显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：</p><pre><code>let person = new Object();person.name = "Nicholas";person.age = 29; </code></pre><p>另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象字面量表示法：</p><pre><code>let person = {    name: "Nicholas",    age: 29};</code></pre><p>接下来指定了 name 属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，因此字符串”Nicholas”后面有一个逗号，而 29 后面没有，因为 age 是这个对象的最后一个属性。</p><p>在对象字面量表示法中，属性名可以是字符串或数值，比如：</p><pre><code>let person = {    "name": "Nicholas",    "age": 29,    5: true}; </code></pre><p>这个例子会得到一个带有属性 name、age 和 5 的对象。注意，数值属性会自动转换为字符串。</p><p>当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p><pre><code>let person = {}; // 与 new Object()相同person.name = "Nicholas";person.age = 29; </code></pre><p>虽然使用哪种方式创建 Object 实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，比如：</p><pre><code>function displayInfo(args) {    let output = "";    if (typeof args.name == "string"){        output += "Name: " + args.name + "\n";    }    if (typeof args.age == "number") {        output += "Age: " + args.age + "\n";    }    alert(output);}displayInfo({    name: "Nicholas",    age: 29});displayInfo({    name: "Greg"});</code></pre><p>虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p><pre><code>console.log(person["name"]); // "Nicholas"console.log(person.name); // "Nicholas" </code></pre><p>从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，就像下面这个例子中一样：</p><pre><code>let propertyName = "name";console.log(person[propertyName]); // "Nicholas"</code></pre><p>通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。</p><p><strong>注意</strong> 第 5 章将更全面、深入地介绍 Object 类型</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0003.html"/>
      <url>posts/a0003.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="a0002">基本引用类型(三) 原始值包装类型</a></strong><br>本篇: <strong>基本引用类型(四) 单例内置对象</strong><br>下篇: <strong><a href="a0004">集合引用类型(一) Object</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h2><p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括 Object、Array 和 String。本节介绍 ECMA-262定义的另外两个单例内置对象：Global 和 Math。</p><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定 Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。</p><h4 id="URL-编码方法"><a href="#URL-编码方法" class="headerlink" title="URL 编码方法"></a>URL 编码方法</h4><p>encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。</p><p>ecnodeURI()方法用于对整个 URI 进行编码，比如”<a href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。而encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的”illegal value.js”。</p><p>这两个方法的主要区别是，encodeURI()不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent()会编码它发现的所有非标准字符。来看下面的例子：</p><pre><code>let uri = "http://www.wrox.com/illegal value.js#start";// "http://www.wrox.com/illegal%20value.js#start"console.log(encodeURI(uri));// "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start"console.log(encodeURIComponent(uri)); </code></pre><p><strong>注意</strong> 一般来说，使用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p><p>与 encodeURI()和 encodeURIComponent()相对的是 decodeURI()和 decodeURIComponent()。decodeURI()只对使用 encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由 encodeURI()替换的。类似地，decodeURIComponent()解码所有被 encodeURIComponent()编码的字符，基本上就是解码所有特殊值。来看下面的例子：</p><pre><code>let uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start";// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23startconsole.log(decodeURI(uri));// http:// www.wrox.com/illegal value.js#startconsole.log(decodeURIComponent(uri));</code></pre><h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h4><p>最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是 eval()。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。来看一个例子：</p><p><code>eval("console.log('hi')");</code></p><p>上面这行代码的功能与下一行等价：</p><p><code>console.log("hi");</code></p><p>通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 eval()调用内部被引用，比如下面这个例子：</p><pre><code>let msg = "hello world";eval("console.log(msg)"); // "hello world" </code></pre><p>这里，变量 msg 是在 eval()调用的外部上下文中定义的，而 console.log()显示了文本”helloworld”。这是因为第二行代码会被替换成一行真正的函数调用代码。类似地，可以在 eval()内部定义一个函数或变量，然后在外部代码中引用，如下所示：</p><pre><code>eval("function sayHi() { console.log('hi'); }");sayHi();</code></pre><p>对于变量也是一样的：</p><pre><code>eval("let msg = 'hello world';");console.log(msg); // Reference Error: msg is not defined </code></pre><p>通过 eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 eval()执行的时候才会被创建。</p><p>在严格模式下，在 eval()内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给 eval 也会导致错误：</p><pre><code>"use strict";eval = "hi"; // 导致错误</code></pre><p><strong>注意</strong> 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p><h4 id="Global-对象属性"><a href="#Global-对象属性" class="headerlink" title="Global 对象属性"></a>Global 对象属性</h4><p>Global 对象有很多属性，其中一些前面已经提到过了。像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是Global 对象的属性。下表列出了所有这些属性。</p><table><thead><tr><th align="left">属 性</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">undefined</td><td align="left">特殊值 undefined</td></tr><tr><td align="left">NaN</td><td align="left">特殊值 NaN</td></tr><tr><td align="left">Infinity</td><td align="left">特殊值 Infinity</td></tr><tr><td align="left">Object</td><td align="left">Object 的构造函数</td></tr><tr><td align="left">Array</td><td align="left">Array 的构造函数</td></tr><tr><td align="left">Function</td><td align="left">Function 的构造函数</td></tr><tr><td align="left">Boolean</td><td align="left">Boolean 的构造函数</td></tr><tr><td align="left">String</td><td align="left">String 的构造函数</td></tr><tr><td align="left">Number</td><td align="left">Number 的构造函数</td></tr><tr><td align="left">Date</td><td align="left">Date 的构造函数</td></tr><tr><td align="left">RegExp</td><td align="left">RegExp 的构造函数</td></tr><tr><td align="left">Symbol</td><td align="left">Symbol 的伪构造函数</td></tr><tr><td align="left">Error</td><td align="left">Error 的构造函数</td></tr><tr><td align="left">EvalError</td><td align="left">EvalError 的构造函数</td></tr><tr><td align="left">RangeError</td><td align="left">RangeError 的构造函数</td></tr><tr><td align="left">ReferenceError</td><td align="left">ReferenceError 的构造函数</td></tr><tr><td align="left">SyntaxError</td><td align="left">SyntaxError 的构造函数</td></tr><tr><td align="left">TypeError</td><td align="left">TypeError 的构造函数</td></tr><tr><td align="left">URIError</td><td align="left">URIError 的构造函数</td></tr></tbody></table><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><p>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。来看下面的例子：</p><pre><code>var color = "red";function sayColor() {    console.log(window.color);}window.sayColor(); // "red" </code></pre><p><strong>注意</strong> window 对象在 JavaScript 中远不止实现了 ECMAScript 的 Global 对象那么简单。<br>关于 window 对象的更多介绍，请参考第 9 章。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。</p><p><strong>注意</strong> Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p><h4 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h4><p>Math 对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p><table><thead><tr><th align="left">属 性</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Math.E</td><td align="left">自然对数的基数 e 的值</td></tr><tr><td align="left">Math.LN10</td><td align="left">10 为底的自然对数</td></tr><tr><td align="left">Math.LN2</td><td align="left">2 为底的自然对数</td></tr><tr><td align="left">Math.LOG2E</td><td align="left">以 2 为底 e 的对数</td></tr><tr><td align="left">Math.LOG10E</td><td align="left">以 10 为底 e 的对数</td></tr><tr><td align="left">Math.PI</td><td align="left">π 的值</td></tr><tr><td align="left">Math.SQRT1_2</td><td align="left">1/2 的平方根</td></tr><tr><td align="left">Math.SQRT2</td><td align="left">2 的平方根</td></tr></tbody></table><h4 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min()和 max()方法"></a>min()和 max()方法</h4><p>Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：</p><pre><code>let max = Math.max(3, 54, 32, 16);console.log(max); // 54let min = Math.min(3, 54, 32, 16);console.log(min); // 3 </code></pre><p>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</p><pre><code>let values = [1, 2, 3, 4, 5, 6, 7, 8];let max = Math.max(...val); </code></pre><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><p>接下来是用于把小数值舍入为整数的 4 个方法：Math.ceil()、Math.floor()、Math.round()和 Math.fround()。这几个方法处理舍入的方式如下所述。</p><ol><li><p>Math.ceil()方法始终向上舍入为最接近的整数。</p></li><li><p>Math.floor()方法始终向下舍入为最接近的整数。</p></li><li><p>Math.round()方法执行四舍五入。</p></li><li><p>Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示。</p></li></ol><p>以下示例展示了这些方法的用法：</p><pre><code>console.log(Math.ceil(25.9)); // 26console.log(Math.ceil(25.5)); // 26console.log(Math.ceil(25.1)); // 26console.log(Math.round(25.9)); // 26console.log(Math.round(25.5)); // 26console.log(Math.round(25.1)); // 25console.log(Math.fround(0.4)); // 0.4000000059604645console.log(Math.fround(0.5)); // 0.5console.log(Math.fround(25.9)); // 25.899999618530273console.log(Math.floor(25.9)); // 25console.log(Math.floor(25.5)); // 25console.log(Math.floor(25.1)); // 25 </code></pre><h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4><p>Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 Math.random()从一组整数中随机选择一个数：</p><p><code>number = Math.floor(Math.random() * total_number_of_choices +first_possible_value) </code></p><p>这里使用了 Math.floor()方法，因为 Math.random()始终返回小数，即便乘以一个数再加上一个数也是小数。因此，如果想从 1~10 范围内随机选择一个数，代码就是这样的：</p><p><code>let num = Math.floor(Math.random() * 10 + 1);</code></p><p>这样就有 10 个可能的值（1<del>10），其中最小的值是 1。如果想选择一个 2</del>10 范围内的值，则代码就要写成这样：</p><p><code>let num = Math.floor(Math.random() * 9 + 2); </code></p><p>2~10 只有 9 个数，所以可选总数（total_number_of_choices）是 9，而最小可能的值（first_possible_value）是 2。很多时候，通过函数来算出可选总数和最小可能的值可能更方便，比如：</p><pre><code>function selectFrom(lowerValue, upperValue) {    let choices = upperValue - lowerValue + 1;    return Math.floor(Math.random() * choices + lowerValue);}let num = selectFrom(2,10);console.log(num); // 2~10 范围内的值，其中包含 2 和 10 </code></pre><p>这里的函数 selectFrom()接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加 1 得到可选总数，然后再套用上面的公式。于是，调用 selectFrom(2,10)就可以从 2~10（包含）范围内选择一个值了。使用这个函数，从一个数组中随机选择一个元素就很容易，比如：</p><pre><code>let colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];let color = colors[selectFrom(0, colors.length-1)]; </code></pre><p><strong>注意</strong> 如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用 window.crypto.getRandomValues()。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>Math 对象还有很多涉及各种简单或高阶数运算的方法。</p><table><thead><tr><th align="left">方 法</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Math.abs(x)</td><td align="left">返回 x 的绝对值</td></tr><tr><td align="left">Math.exp(x)</td><td align="left">返回 Math.E 的 x 次幂</td></tr><tr><td align="left">Math.expm1(x)</td><td align="left">等于 Math.exp(x) - 1</td></tr><tr><td align="left">Math.log(x)</td><td align="left">返回 x 的自然对数</td></tr><tr><td align="left">Math.log1p(x)</td><td align="left">等于 1 + Math.log(x)</td></tr><tr><td align="left">Math.pow(x, power)</td><td align="left">返回 x 的 power 次幂</td></tr><tr><td align="left">Math.hypot(…nums)</td><td align="left">返回 nums 中每个数平方和的平方根</td></tr><tr><td align="left">Math.clz32(x)</td><td align="left">返回 32 位整数 x 的前置零的数量</td></tr><tr><td align="left">Math.sign(x)</td><td align="left">返回表示 x 符号的 1、0、-0 或-1</td></tr><tr><td align="left">Math.trunc(x)</td><td align="left">返回 x 的整数部分，删除所有小数</td></tr><tr><td align="left">Math.sqrt(x)</td><td align="left">返回 x 的平方根</td></tr><tr><td align="left">Math.cbrt(x)</td><td align="left">返回 x 的立方根</td></tr><tr><td align="left">Math.acos(x)</td><td align="left">返回 x 的反余弦</td></tr><tr><td align="left">Math.acosh(x)</td><td align="left">返回 x 的反双曲余弦</td></tr><tr><td align="left">Math.asin(x)</td><td align="left">返回 x 的反正弦</td></tr><tr><td align="left">Math.asinh(x)</td><td align="left">返回 x 的反双曲正弦</td></tr><tr><td align="left">Math.atan(x)</td><td align="left">返回 x 的反正切</td></tr><tr><td align="left">Math.atanh(x)</td><td align="left">返回 x 的反双曲正切</td></tr><tr><td align="left">Math.atan2(y, x)</td><td align="left">返回 y/x 的反正切</td></tr><tr><td align="left">Math.cos(x)</td><td align="left">返回 x 的余弦</td></tr><tr><td align="left">Math.sin(x)</td><td align="left">返回 x 的正弦</td></tr><tr><td align="left">Math.tan(x)</td><td align="left">返回 x 的正切</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0002.html"/>
      <url>posts/a0002.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong><br>本篇: <strong>基本引用类型(三) 原始值包装类型</strong><br>下篇: <strong><a href="a0003">基本引用类型(四) 单例内置对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p><pre><code>let s1 = "some text";let s2 = s1.substring(2);</code></pre><p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：</p><p>(1) 创建一个 String 类型的实例；<br>(2) 调用实例上的特定方法；<br>(3) 销毁实例。</p><p>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p><pre><code>let s1 = new String("some text");let s2 = s1.substring(2);s1 = null;</code></pre><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过<br>用的是 Boolean 和 Number 包装类型而已。</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p><pre><code>let s1 = "some text";s1.color = "red";console.log(s1.color); // undefined</code></pre><p>可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 typeof 会返回”object”，所有原始值包装对象都会转换为布尔值 true。</p><p>另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p><pre><code>let obj = new Object("some text");console.log(obj instanceof String); // true</code></pre><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：</p><p><code>let booleanObject = new Boolean(true);</code></p><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。</p><p>不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：</p><pre><code>let falseObject = new Boolean(false);let result = falseObject &amp;&amp; true;console.log(result); // truelet falseValue = false;result = falseValue &amp;&amp; true;console.log(result); // false</code></pre><p>在这段代码中，我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。</p><p>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：</p><pre><code>console.log(typeof falseObject); // objectconsole.log(typeof falseValue); // booleanconsole.log(falseObject instanceof Boolean); // trueconsole.log(falseValue instanceof Boolean); // false</code></pre><p>理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：</p><p><code>let numberObject = new Number(10);</code></p><p>valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>toFixed()方法返回包含指定小数点位数的数值字符串，如：</p><pre><code>let num = 10;console.log(num.toFixed(2)); // "10.00"</code></pre><p>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小位：</p><pre><code>let num = 10.005;console.log(num.toFixed(2)); // "10.01"</code></pre><p>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。</p><p>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：</p><pre><code>let num = 10;console.log(num.toExponential(1)); // "1.0e+1"</code></pre><p>toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：</p><pre><code>let num = 99;console.log(num.toPrecision(1)); // "1e+2"console.log(num.toPrecision(2)); // "99"console.log(num.toPrecision(3)); // "99.0" </code></pre><p>与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。</p><pre><code>let numberObject = new Number(10);let numberValue = 10;console.log(typeof numberObject); // "object"console.log(typeof numberValue); // "number"console.log(numberObject instanceof Number); // trueconsole.log(numberValue instanceof Number); // false </code></pre><p>isInteger()方法与安全整数<br>ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0可能会让人误以为数值是一个浮点值：</p><pre><code>console.log(Number.isInteger(1)); // trueconsole.log(Number.isInteger(1.00)); // trueconsole.log(Number.isInteger(1.01)); // false</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值，如下例所示：</p><p><code>let stringObject = new String("hello world");</code></p><p>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleStrin()和 toString()都返回对象的原始字符串值。</p><p>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.length); // "11"</code></pre><p>charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p><pre><code>let message = "abcde";console.log(message.charAt(2)); // "c" </code></pre><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p>首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world");console.log(result); // "hello world"console.log(stringValue); // "hello" </code></pre><p>在这个例子中，对 stringValue 调 用 concat()方法的结果是得到”hello world”， 但<br>stringValue 的值保持不变。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字串，如下所示：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world", "!");console.log(result); // "hello world!"console.log(stringValue); // "hello"</code></pre><p>虽然 concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对拼接多个字符串来说，使用加号更方便。</p><p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：slice()、substr()和 substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是取结束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样，slice()substr()和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.slice(3)); // "lo world"console.log(stringValue.substring(3)); // "lo world"console.log(stringValue.substr(3)); // "lo world"console.log(stringValue.slice(3, 7)); // "lo w"console.log(stringValue.substring(3,7)); // "lo w"console.log(stringValue.substr(3, 7)); // "lo worl"</code></pre><p>substr()返回”lo worl”，因为第二个参数对它而言表示返回的字符数</p><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o")); // 4console.log(stringValue.lastIndexOf("o")); // 7</code></pre><p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o", 6)); // 7console.log(stringValue.lastIndexOf("o", 6)); // 4 </code></pre><p>像这样使用第二个参数并循环调用indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串，如下所示：</p><pre><code>let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";let positions = new Array();let pos = stringValue.indexOf("e");while(pos &gt; -1) {    positions.push(pos);    pos = stringValue.indexOf("e", pos + 1);}console.log(positions); // [3,24,32,35,52]</code></pre><p>这个例子逐步增大开始搜索的位置，通过 indexOf()遍历了整个字符串。首先取得第一个”e”的位置，然后进入循环，将上一次的位置加 1 再传给 indexOf()，确保搜索到最后一个子字符串实例之后。每个位置都保存在 positions 数组中，可供以后使用。</p><h4 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h4><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("bar")); // falseconsole.log(message.endsWith("baz")); // trueconsole.log(message.endsWith("bar")); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("qux")); // false</code></pre><p>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("foo", 1)); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("bar", 4)); // false</code></pre><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p><pre><code>let stringValue = " hello world ";let trimmedStringValue = stringValue.trim();console.log(stringValue); // " hello world "console.log(trimmedStringValue); // "hello world"</code></pre><p>由于 trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。另外，trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</p><h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p><pre><code>let stringValue = "na ";console.log(stringValue.repeat(16) + "batman");// na na na na na na na na na na na na na na na na batman</code></pre><h4 id="padStart-和-padEnd-方法"><a href="#padStart-和-padEnd-方法" class="headerlink" title="padStart()和 padEnd()方法"></a>padStart()和 padEnd()方法</h4><p>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(6)); // " foo"console.log(stringValue.padStart(9, ".")); // "......foo"console.log(stringValue.padEnd(6)); // "foo "console.log(stringValue.padEnd(9, ".")); // "foo......"</code></pre><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(8, "bar")); // "barbafoo"console.log(stringValue.padStart(2)); // "foo"console.log(stringValue.padEnd(8, "bar")); // "foobarba"console.log(stringValue.padEnd(2)); // "foo"</code></pre><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><p>下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的法，与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在于特定地区实现。</p><pre><code>let stringValue = "hello world";console.log(stringValue.toLocaleUpperCase()); // "HELLO WORLD"console.log(stringValue.toUpperCase()); // "HELLO WORLD"console.log(stringValue.toLocaleLowerCase()); // "hello world"console.log(stringValue.toLowerCase()); // "hello world" </code></pre><h4 id="字符串模式匹配方法"><a href="#字符串模式匹配方法" class="headerlink" title="字符串模式匹配方法"></a>字符串模式匹配方法</h4><p>String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。来看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;// 等价于 pattern.exec(text)let matches = text.match(pattern);console.log(matches.index); // 0console.log(matches[0]); // "cat"console.log(pattern.lastIndex); // 0</code></pre><p>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返-1。search()始终从字符串开头向后匹配模式。看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pos = text.search(/at/);console.log(pos); // 1 </code></pre><p>为简化子字符串替换操作，ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let result = text.replace("at", "ond");console.log(result); // "cond, bat, sat, fat"result = text.replace(/at/g, "ond");console.log(result); // "cond, bond, sond, fond"</code></pre><p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262 中规定了下表中的值。</p><table><thead><tr><th align="left">字符序列</th><th align="left">替换文本</th></tr></thead><tbody><tr><td align="left">$$</td><td align="left">$</td></tr><tr><td align="left">$&amp;</td><td align="left">匹配整个模式的子字符串。与 RegExp.lastMatch 相同</td></tr><tr><td align="left">$’</td><td align="left">匹配的子字符串之前的字符串。与 RegExp.rightContext 相同</td></tr><tr><td align="left">$`</td><td align="left">匹配的子字符串之后的字符串。与 RegExp.leftContext 相同</td></tr><tr><td align="left">$n</td><td align="left">匹配第 n 个捕获组的字符串，其中 n 是 0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr><tr><td align="left">$nn</td><td align="left">匹配第 nn 个捕获组字符串，其中 nn 是 01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr></tbody></table><p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";result = text.replace(/(.at)/g, "word ($1)");console.log(result); // word (cat), word (bat), word (sat), word (fat)</code></pre><p>这里，每个以”at”结尾的词都会被替换成”word”后跟一对小括号，其中包含捕获组匹配的内容$1。</p><p>replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：</p><pre><code>function htmlEscape(text) {    return text.replace(/[&lt;&gt;"&amp;]/g, function(match, pos, originalText) {        switch(match) {            case "&lt;":            return "&amp;lt;";            case "&gt;":            return "&amp;gt;";            case "&amp;":            return "&amp;amp;";            case "\"":            return "&amp;quot;";        }    });}console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"));// "&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;" </code></pre><p>这里，函数 htmlEscape()用于将一段 HTML 中的 4 个字符替换成对应的实体：小于号、大于号、和号，还有双引号（都必须经过转义）。实现这个任务最简单的办法就是用一个正则表达式查找这些字符，然后定义一个函数，根据匹配的每个字符分别返回特定的 HTML 实体。</p><p>最后一个与模式匹配相关的字符串方法是 split()。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p><pre><code>let colorText = "red,blue,green,yellow";let colors1 = colorText.split(","); // ["red", "blue", "green", "yellow"]let colors2 = colorText.split(",", 2); // ["red", "blue"]let colors3 = colorText.split(/[^,]+/); // ["", ",", ",", ",", ""]</code></pre><p>在这里，字符串 colorText 是一个逗号分隔的颜色名称符串。调用 split(“,”)会得到包含这些颜色名的数组，基于逗号进行拆分。要把数组元素限制为 2 个，传入第二个参数 2 即可。最后，使用正则表达式可以得到一个包含逗号的数组。注意在最后一次调用 split()时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（”red”）和末尾（”yellow”）。</p><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h4><p>最后一个方法是 localeCompare()，这个方法比较两个字符串，返回如下 3 个值中的一个。</p><ol><li><p>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）</p></li><li><p>如果字符串与字符串参数相等，则返回 0。</p></li><li><p>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</p></li></ol><p>下面是一个例子：</p><pre><code>let stringValue = "yellow";console.log(stringValue.localeCompare("brick")); // 1console.log(stringValue.localeCompare("yellow")); // 0console.log(stringValue.localeCompare("zoo")); // -1</code></pre><p>强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用localeCompare()：</p><pre><code>function determineOrder(value) {    let result = stringValue.localeCompare(value);    if (result &lt; 0) {        console.log(`The string 'yellow' comes before the string '${value}'.`);    } else if (result &gt; 0) {        console.log(`The string 'yellow' comes after the string '${value}'.`);    } else {        console.log(`The string 'yellow' is equal to the string '${value}'.`);    }}determineOrder("brick");determineOrder("yellow");determineOrder("zoo");</code></pre><p>这样一来，就可以保证在所有实现中都能正确判断字符串的顺序了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0001.html"/>
      <url>posts/a0001.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong><br>本篇: <strong>基本引用类型(二) RegExp</strong><br>下篇: <strong><a href="a0002">基本引用类型(三) 原始值包装类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p><ol><li><p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</p></li><li><p>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</p></li><li><p>m：多行模式，表示查找到一行文本末尾时会继续查找。</p></li><li><p>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</p></li><li><p>u：Unicode 模式，启用 Unicode 匹配。</p></li><li><p>s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</p></li></ol><p>使用不同模式和标记可以创建出各种正则表达式，比如：</p><pre><code>// 匹配字符串中的所有"at"let pattern1 = /at/g;// 匹配第一个"bat"或"cat"，忽略大小写let pattern2 = /[bc]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi; </code></pre><p>与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：</p><p>( [ { \ ^ $ | ) ] } ? * + . </p><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 匹配第一个"[bc]at"，忽略大小写let pattern2 = /\[bc\]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi;// 匹配所有".at"，忽略大小写let pattern4 = /\.at/gi; </code></pre><p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 跟 pattern1 一样，只不过是用构造函数创建的let pattern2 = new RegExp("[bc]at", "i"); </code></pre><p>注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。</p><table><thead><tr><th align="left">字面量模式</th><th align="left">对应的字符串</th></tr></thead><tbody><tr><td align="left">/\[bc\]at/</td><td align="left">“\\[bc\\]at”</td></tr><tr><td align="left">/\.at/</td><td align="left">“\\.at”</td></tr><tr><td align="left">/name\/age/</td><td align="left">“name\\/age”</td></tr><tr><td align="left">/\d.\d{1,2}/</td><td align="left">“\\d.\\d{1,2}”</td></tr><tr><td align="left">/\w\\hello\\123/</td><td align="left">“\\w\\\\hello\\\\123”</td></tr></tbody></table><p>此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><pre><code>const re1 = /cat/g;console.log(re1); // "/cat/g"const re2 = new RegExp(re1);console.log(re2); // "/cat/g"const re3 = new RegExp(re1, "i");console.log(re3); // "/cat/i" </code></pre><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。</p><ol><li><p>global：布尔值，表示是否设置了 g 标记。</p></li><li><p>ignoreCase：布尔值，表示是否设置了 i 标记。</p></li><li><p>unicode：布尔值，表示是否设置了 u 标记。</p></li><li><p>sticky：布尔值，表示是否设置了 y 标记。</p></li><li><p>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</p></li><li><p>multiline：布尔值，表示是否设置了 m 标记。</p></li><li><p>dotAll：布尔值，表示是否设置了 s 标记。</p></li><li><p>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</p></li><li><p>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</p></li></ol><p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含<br>这些信息。下面是一个例子：</p><pre><code>let pattern1 = /\[bc\]at/i;console.log(pattern1.global); // falseconsole.log(pattern1.ignoreCase); // trueconsole.log(pattern1.multiline); // falseconsole.log(pattern1.lastIndex); // 0console.log(pattern1.source); // "\[bc\]at"console.log(pattern1.flags); // "i"let pattern2 = new RegExp("\\[bc\\]at", "i");console.log(pattern2.global); // falseconsole.log(pattern2.ignoreCase); // trueconsole.log(pattern2.multiline); // falseconsole.log(pattern2.lastIndex); // 0console.log(pattern2.source); // "\[bc\]at"console.log(pattern2.flags); // "i" </code></pre><p>注意，虽然第一个模式是通过字面量创建的，第二个模式是通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。</p><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p><pre><code>let text = "mom and dad and baby";let pattern = /mom( and dad( and baby)?)?/gi;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" </code></pre><p>在这个例子中，模式包含两个捕获组：最内部的匹配项” and baby”，以及外部的匹配项” and dad”或” and dad and baby”。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获的字符串，第三个元素是匹配第二个捕获组的字符串。</p><p>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0 </code></pre><p>上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（”cat”）。lastIndex在非全局模式下始终不变。</p><p>如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/g;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8matches = pattern.exec(text);console.log(matches.index); // 10console.log(matches[0]); // satconsole.log(pattern.lastIndex); // 13</code></pre><p>这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。</p><p>如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/y;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3// 以索引 3 对应的字符开头找不到匹配项，因此 exec()返回 null// exec()没找到匹配项，于是将 lastIndex 设置为 0matches = pattern.exec(text);console.log(matches); // nullconsole.log(pattern.lastIndex); // 0// 向前设置 lastIndex 可以让粘附的模式通过 exec()找到下一个匹配项：pattern.lastIndex = 5;matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8</code></pre><p>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p><pre><code>let text = "000-00-0000";let pattern = /\d{3}-\d{2}-\d{4}/;if (pattern.test(text)) {console.log("The pattern was matched."); </code></pre><p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p><p>无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：</p><pre><code>let pattern = new RegExp("\\[bc\\]at", "gi");console.log(pattern.toString()); // /\[bc\]at/giconsole.log(pattern.toLocaleString()); // /\[bc\]at/gi</code></pre><p>这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。</p><p><strong>注意</strong> 正则表达式的 valueOf()方法返回正则表达式本身。</p><h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>每个属性都有一个全名和一个简写。下表列出了RegExp 构造函数的属性</p><table><thead><tr><th align="left">全 名</th><th align="left">简 写</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">input</td><td align="left">$_</td><td align="left">最后搜索的字符串（非标准特性）</td></tr><tr><td align="left">lastMatch</td><td align="left">$&amp;</td><td align="left">最后匹配的文本</td></tr><tr><td align="left">lastParen</td><td align="left">$+</td><td align="left">最后匹配的捕获组（非标准特性）</td></tr><tr><td align="left">leftContext</td><td align="left">$`</td><td align="left">input 字符串中出现在 lastMatch 前面的文本</td></tr><tr><td align="left">rightContext</td><td align="left">$’</td><td align="left">input 字符串中出现在 lastMatch 后面的文本</td></tr></tbody></table><p>通过这些属性可以提取出与 exec()和 test()执行的操作相关的信息。来看下面的例子：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;if (pattern.test(text)) {  console.log(RegExp.input); // this has been a short summer  console.log(RegExp.leftContext); // this has been a  console.log(RegExp.rightContext); // summer  console.log(RegExp.lastMatch); // short  console.log(RegExp.lastParen); // s} </code></pre><p>以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下</p><ol><li><p>input 属性中包含原始的字符串。</p></li><li><p>leftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。</p></li><li><p>lastMatch 属性包含匹配整个正则表达式的上一个字符串，即”short”。</p></li><li><p>lastParen 属性包含捕获组的上一次匹配，即”s”。</p></li></ol><p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的 ECMAScript 标识符：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;/** 注意：Opera 不支持简写属性名* IE 不支持多行匹配*/if (pattern.test(text)) {  console.log(RegExp.$_); // this has been a short summer  console.log(RegExp["$`"]); // this has been a  console.log(RegExp["$'"]); // summer  console.log(RegExp["$&amp;"]); // short  console.log(RegExp["$+"]); // s}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/58a1.html"/>
      <url>posts/58a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong><br>本篇: <strong>基本引用类型(一) Date</strong><br>下篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月1 日之前及之后的日期。</p><p>要创建日期对象，就使用 new 操作符来调用 Date 构造函数：</p><p><code>let now = new Date();</code></p><p>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒<br>数。</p><ol><li>“月/日/年”，如”5/23/2019”；</li><li>“月名 日, 年”，如”May 23, 2019”；</li><li>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”；</li><li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00</li></ol><p>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：</p><p><code>let someDate = new Date(Date.parse("May 23, 2019")); </code></p><p>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：</p><p><code>let someDate = new Date("May 23, 2019"); </code></p><p>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：</p><pre><code>// GMT 时间 2000 年 1 月 1 日零点let y2k = new Date(Date.UTC(2000, 0));// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); </code></pre><p>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><pre><code>// 起始时间let start = Date.now();// 调用函数doSomething();// 结束时间let stop = Date.now(),result = stop - start;</code></pre><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为”en-US”的 PST，即 Pacific Standard Time，太平洋标准时间）：</p><pre><code>toLocaleString() - 2/1/2019 12:00:00 AMtoString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) </code></pre><p>Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：</p><pre><code>let date1 = new Date(2019, 0, 1); // 2019 年 1 月 1 日let date2 = new Date(2019, 1, 1); // 2019 年 2 月 1 日console.log(date1 &lt; date2); // trueconsole.log(date1 &gt; date2); // false </code></pre><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ol><li><p>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；</p></li><li><p>toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）;</p></li><li><p>toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；</p></li><li><p>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；</p></li><li><p>toUTCString()显示完整的 UTC 日期（格式特定于实现）。</p></li></ol><p>这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p><table><thead><tr><th align="left">方 法</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">getTime()</td><td align="left">返回日期的毫秒表示；与 valueOf()相同</td></tr><tr><td align="left">setTime(milliseconds)</td><td align="left">设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td align="left">getFullYear()</td><td align="left">返回 4 位数年（即 2019 而不是 19）</td></tr><tr><td align="left">getUTCFullYear()</td><td align="left">返回 UTC 日期的 4 位数年</td></tr><tr><td align="left">setFullYear(year)</td><td align="left">设置日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">setUTCFullYear(year)</td><td align="left">设置 UTC 日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">getMonth()</td><td align="left">返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">getUTCMonth()</td><td align="left">返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">setMonth(month)</td><td align="left">设置日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">setUTCMonth(month)</td><td align="left">设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">getDate()</td><td align="left">返回日期中的日（1~31）</td></tr><tr><td align="left">getUTCDate()</td><td align="left">返回 UTC 日期中的日（1~31）</td></tr><tr><td align="left">setDate(date)</td><td align="left">设置日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">setUTCDate(date)</td><td align="left">设置 UTC 日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">getDay()</td><td align="left">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getUTCDay()</td><td align="left">返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getHours()</td><td align="left">返回日期中的时（0~23）</td></tr><tr><td align="left">getUTCHours()</td><td align="left">返回 UTC 日期中的时（0~23）</td></tr><tr><td align="left">setHours(hours)</td><td align="left">设置日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">setUTCHours(hours)</td><td align="left">设置 UTC 日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回日期中的分（0~59）</td></tr><tr><td align="left">getUTCMinutes()</td><td align="left">返回 UTC 日期中的分（0~59）</td></tr><tr><td align="left">setMinutes(minutes)</td><td align="left">设置日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">setUTCMinutes(minutes)</td><td align="left">设置 UTC 日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回日期中的秒（0~59）</td></tr><tr><td align="left">getUTCSeconds()</td><td align="left">返回 UTC 日期中的秒（0~59）</td></tr><tr><td align="left">setSeconds(seconds)</td><td align="left">设置日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">setUTCSeconds(seconds)</td><td align="left">设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回日期中的毫秒</td></tr><tr><td align="left">getUTCMilliseconds()</td><td align="left">返回 UTC 日期中的毫秒</td></tr><tr><td align="left">setMilliseconds(milliseconds)</td><td align="left">设置日期中的毫秒</td></tr><tr><td align="left">setUTCMilliseconds(milliseconds)</td><td align="left">设置 UTC 日期中的毫秒</td></tr><tr><td align="left">getTimezoneOffset()</td><td align="left">返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/c803.html"/>
      <url>posts/c803.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong><br>本篇: <strong>变量、作用域与内存(三) 垃圾回收</strong><br>下篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>挖坑了~  QAQ<br>此坑挖于: 2020/11/20<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/85b1.html"/>
      <url>posts/85b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong><br>本篇: <strong>变量、作用域与内存(二) 执行上下文与作用域</strong><br>下篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variableobject），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象。</p><p>因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和const 的顶级声明不会定义在全局上下文中但在作用域链解析上效果是一样的。</p><p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）</p><p>看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    if (color === "blue") {        color = "red";    } else {        color = "blue";    }}changeColor();</code></pre><p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    let anotherColor = "red";    function swapColors() {        let tempColor = anotherColor;        anotherColor = color;        color = tempColor;        // 这里可以访问 color、anotherColor 和 tempColor    }    // 这里可以访问 color 和 anotherColor，但访问不到 tempColor    swapColors();}// 这里只能访问 colorchangeColor(); </code></pre><hr><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这现象，即代码执行到下面任意一种情况时：</p><ol><li><p>try/catch 语句的 catch 块</p></li><li><p>with 语句</p></li></ol><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p><pre><code>function buildUrl() {    let qs = "?debug=true";    with(location){        let url = href + qs;    }    return url;}</code></pre><p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块作用域（稍后介绍），所以在 with 块之外没有定义。</p><hr><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="使用-var-的函数作用域声明"><a href="#使用-var-的函数作用域声明" class="headerlink" title="使用 var 的函数作用域声明"></a>使用 var 的函数作用域声明</h4><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p><pre><code>function add(num1, num2) {    var sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 报错：sum 在这里不是有效变量</code></pre><p>这里，函数 add()定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回，但变量 sum 在函数外部是访问不到的。如果省略上面例子中的关键字 var，那么 sum 在 add()被调用之后就变成可以访问的了，如下所示：</p><pre><code>function add(num1, num2) {    sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 30 </code></pre><p><strong>注意</strong> 未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p><p>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。下面的例子展示了在全局作用域中两等价的代码：</p><pre><code>var name = "Jake";// 等价于：name = 'Jake';var name;下面是两个等价的函数：function fn1() {    var name = 'Jake';}// 等价于：function fn2() {    var name;    name = 'Jake';} </code></pre><p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是<br>Reference Error：</p><pre><code>console.log(name); // undefinedvar name = 'Jake';function() {    console.log(name); // undefined    var name = 'Jake';} </code></pre><h4 id="使用-let-的块级作用域声明"><a href="#使用-let-的块级作用域声明" class="headerlink" title="使用 let 的块级作用域声明"></a>使用 let 的块级作用域声明</h4><p>ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域。</p><p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p><pre><code>var a;var a;// 不会报错{    let b;    let b;}// SyntaxError: 标识符 b 已经声明过了</code></pre><p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</p><pre><code>for (var i = 0; i &lt; 10; ++i) {}console.log(i); // 10for (let j = 0; j &lt; 10; ++j) {}console.log(j); // ReferenceError: j 没有定义</code></pre><p>严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal deadzone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提跟 var是不一样的。</p><h4 id="使用-const-的常量声明"><a href="#使用-const-的常量声明" class="headerlink" title="使用 const 的常量声明"></a>使用 const 的常量声明</h4><p>除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><pre><code>const a; // SyntaxError: 常量声明时没有初始化const b = 3;console.log(b); // 3b = 4; // TypeError: 给常量赋值</code></pre><p>const 除了要遵循以上规则，其他方面与 let 声明是一样的</p><p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><pre><code>const o1 = {};o1 = {}; // TypeError: 给常量赋值const o2 = {};o2.name = 'Jake';console.log(o2.name); // 'Jake'</code></pre><p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：</p><pre><code>const o3 = Object.freeze({});o3.name = 'Jake';console.log(o3.name); // undefined </code></pre><p><strong>注意</strong> 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用<br>const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现<br>重新赋值导致的 bug。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/44e8.html"/>
      <url>posts/44e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong><br>本篇: <strong>变量、作用域与内存(一)原始值与引用值</strong><br>下篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。</p><hr><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：</p><pre><code>let person = new Object();person.name = "Nicholas";console.log(person.name); // "Nicholas" </code></pre><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：</p><pre><code>let name = "Nicholas";name.age = 27;console.log(name.age); // undefined </code></pre><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><pre><code>let name1 = "Nicholas";let name2 = new String("Matt");name1.age = 27;name2.age = 26;console.log(name1.age); // undefinedconsole.log(name2.age); // 26console.log(typeof name1); // stringconsole.log(typeof name2); // object </code></pre><hr><h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p><pre><code>let num1 = 5;let num2 = num1;</code></pre><p>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p><pre><code>let obj1 = new Object();let obj2 = obj1;obj1.name = "Nicholas";console.log(obj2.name); // "Nicholas" </code></pre><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><p>在按值传递参数时，值会被复制到一个局部变量在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部</p><pre><code>function addTen(num) {    num += 10;    return num;}let count = 20; let result = addTen(count);console.log(count); // 20，没有变化console.log(result); // 30 function setName(obj) {    obj.name = "Nicholas";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><pre><code>function setName(obj) {    obj.name = "Nicholas";    obj = new Object();    obj.name = "Greg";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><p><strong>注意</strong> ECMAScript 中函数的参数就是局部变量</p><hr><h3 id="确定类型-instanceof"><a href="#确定类型-instanceof" class="headerlink" title="确定类型 instanceof"></a>确定类型 instanceof</h3><p>前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返”object”，如下面的例子所示：</p><pre><code>let s = "Nicholas";let b = true;let i = 22;let u;let n = null;let o = new Object();console.log(typeof s); // stringconsole.log(typeof i); // numberconsole.log(typeof b); // booleanconsole.log(typeof u); // undefinedconsole.log(typeof n); // objectconsole.log(typeof o); // object </code></pre><p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型的实例，则 instanceof 操作符返回 true。来看下面的例子：</p><pre><code>console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><p>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。</p><p><strong>注意</strong></p><p>typeof 操作符在用于检测函数时也会返回”function”</p><p>typeof 对正则表达式也返回”function”，在 IE 和 Firefox 中，typeof 对正则表达式返回”object”</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a1.html"/>
      <url>posts/8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="873e">语言基础(四)操作符</a></strong><br>本篇: <strong>[语言基础(五)语句&amp;&amp;函数]</strong><br>下篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环：</p><pre><code>for (;;) { // 无穷循环doSomething();} </code></pre><hr><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h3><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><pre><code>for (property in expression) statement</code></pre><p>下面是一个例子：</p><pre><code>for (const propName in window) {document.write(propName);} </code></pre><p>这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量propName 赋予一个 window 对象的属性作为值，直到 window 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。</p><p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</p><hr><h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h3><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><pre><code>for (property of expression) statement</code></pre><p>下面是示例：</p><pre><code>for (const el of [2,4,6,8]) {document.write(el);} </code></pre><p>在这个例子中，我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误</p><hr><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p><pre><code>label: statement</code></pre><p>下面是一个例子：</p><pre><code>start: for (let i = 0; i &lt; count; i++) {console.log(i);}</code></pre><p>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</p><hr><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        if (i == 5 &amp;&amp; j == 5) {            break outermost;        }    num++;    }}console.log(num); // 55</code></pre><p>在这个例子中，outermost 标签标识的是第一个 for 语句。正常情况下，每个循环执行 10 次，意味着 num++语句会执行 100 次，而循环结束时 console.log 的结果应该是 100。但是，break 语带来了一个变数，即要退出到的标签。添加标签不仅让 break 退出（使用变量 j 的）内部循环，也会退出（使用变量 i 的）外部循环。当执行到 i 和 j 都等于 5 时，循环停止执行，此时 num 的值是55。</p><p>continue语句也可以使用标签，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {     if (i == 5 &amp;&amp; j == 5) {       continue outermost;    }    num++;    }}console.log(num); // 95 </code></pre><p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次结果 num 等于 95。</p><p>组合使用标签语句和 break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><hr><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>with 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><pre><code>with (expression) statement;</code></pre><p>使用 with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：</p><pre><code>let qs = location.search.substring(1);let hostName = location.hostname;let url = location.href;</code></pre><p>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</p><pre><code>with(location) {let qs = search.substring(1);let hostName = hostname;let url = href;} </code></pre><p>这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 location 对象的属性。</p><p>严格模式不允许使用 with 语句，否则会抛出错误。</p><p><strong>警告</strong> 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p><hr><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>虽然 switch 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：</p><pre><code>switch ("hello world") {    case "hello" + " world":        console.log("Greeting was found.");        break;    case "goodbye":        console.log("Closing was found.");        break;    default:        console.log("Unexpected message was found.");} </code></pre><p>注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值。比如：</p><pre><code>function sum(num1, num2) {return num1 + num2;}</code></pre><p>要注意的是，只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。 </p><p>严格模式对函数也有一些限制：</p><ol><li><p>函数不能以 eval 或 arguments 作为名称；</p></li><li><p>函数的参数不能叫 eval 或 arguments；</p></li><li><p>两个命名参数不能拥有同一个名称。</p></li></ol><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/873e.html"/>
      <url>posts/873e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong><br>本篇: <strong>[语言基础(四)操作符]</strong><br>下篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。</p><hr><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作符叫一元操作符。</p><h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="headerlink" title="递增/递减操作符"></a>递增/递减操作符</h4><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p><p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p><ol><li><p>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</p></li><li><p>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</p></li><li><p>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于浮点值，加 1 或减 1。</p></li><li><p>如果是对象，则调用其（第 3 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。</p></li></ol><p>下面的例子演示了这些规则：</p><pre><code>let s1 = "2";let s2 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1++; // 值变成数值 3s2++; // 值变成 NaNb++; // 值变成数值 1f--; // 值变成 0.10000000000000009（因为浮点数不精确）o--; // 值变成-2 </code></pre><hr><h4 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h4><p>如果将一元加应用到非数值,则会执行与使用Number()转型函数一样的类型转换：布尔值false和true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toStrin()方法以得到可以转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><pre><code>let s1 = "01";let s2 = "1.1"; let s3 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1 = +s1; // 值变成数值 1s2 = +s2; // 值变成数值 1.1s3 = +s3; // 值变成 NaNb = +b; // 值变成数值 0f = +f; // 不变，还是 1.1o = +o; // 值变成数值-1 </code></pre><p>一元减由一个减号（-）表示同上</p><hr><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>挖坑了~<br>此坑挖于:2020/11/20<br>此坑填于:~</p><hr><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h4><p>逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。<br>逻辑非操作符会遵循如下规则：</p><ol><li><p>如果操作数是对象，则返回 false。</p></li><li><p>如果操作数是空字符串，则返回 true。</p></li><li><p>如果操作数是非空字符串，则返回 false。</p></li><li><p>如果操作数是数值 0，则返回 true。</p></li><li><p>如果操作数是非 0 数值（包括 Infinity），则返回 false。</p></li><li><p>如果操作数是 null，则返回 true。</p></li><li><p>如果操作数是 NaN，则返回 true。</p></li><li><p>如果操作数是 undefined，则返回 true。</p></li></ol><p>以下示例验证了上述行为：</p><pre><code>console.log(!false); // trueconsole.log(!"blue"); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!""); // trueconsole.log(!12345); // false </code></pre><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p><pre><code>console.log(!!"blue"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!12345); // true </code></pre><hr><h4 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h4><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p><p>同真为真，其余全是假</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则:</p><ol><li><p>如果第一个操作数是对象，则返回第二个操作数。</p></li><li><p>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</p></li><li><p>如果两个操作数都是对象，则返回第二个操作数。</p></li><li><p>如果有一个操作数是 null，则返回 null。</p></li><li><p>如果有一个操作数是 NaN，则返回 NaN。</p></li><li><p>如果有一个操作数是 undefined，则返回 undefined</p></li></ol><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</p><hr><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h4><p>逻辑或操作符由两个管道符（||）表示</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：</p><ol><li><p>如果第一个操作数是对象，则返回第一个操作数。</p></li><li><p>如果第一个操作数求值为 false，则返回第二个操作数。</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数。</p></li><li><p>如果两个操作数都是 null，则返回 null。</p></li><li><p>如果两个操作数都是 NaN，则返回 NaN。</p></li><li><p>如果两个操作数都是 undefined，则返回 undefined。</p></li></ol><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。</p><hr><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h4 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h4><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。</p><p>乘法操作符在处理特殊值时也有一些特殊的行为。</p><ol><li><p>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以 0，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity -Infinity。</p></li><li><p>如果是 Infinity 乘以 Infinity，则返回 Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</p></li></ol><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p><p>跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ol><li><p>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果是 0 除以 0，则返回 NaN。</p></li><li><p>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><hr><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><p>取模（余数）操作符由一个百分比符号（%）表示</p><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为:</p><ol><li><p>如果操作数是数值，则执行常规除法运算，返回余数。</p></li><li><p>如果被除数是无限值，除数是有限值，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是 0，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是无限值，则返回被除数。</p></li><li><p>如果被除数是 0，除数不是 0，则返回 0。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h4 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>如果有一个操作数是字符串，则要应用如下规则：</p><ol><li><p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</p></li><li><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。</p></li></ol><p>看下面的例子：</p><pre><code>let result1 = 5 + 5; // 两个数值console.log(result1); // 10let result2 = 5 + "5"; // 一个数值和一个字符串console.log(result2); // "55" </code></pre><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + num1 + num2;console.log(message); // "The sum of 5 and 10 is 510" </code></pre><p>如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + (num1 + num2);console.log(message); // "The sum of 5 and 10 is 15" </code></pre><hr><h4 id="加法操作符-1"><a href="#加法操作符-1" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ol><li><p> 如果两个操作数都是数值，则执行数学减法运算并返回结果。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 减 Infinity，则返回 NaN。</p></li><li><p>如果是-Infinity 减-Infinity，则返回 NaN。</p></li><li><p>如果是 Infinity 减-Infinity，则返回 Infinity。</p></li><li><p>如果是-Infinity 减 Infinity，则返回-Infinity。</p></li><li><p>如果是+0 减+0，则返回+0。</p></li><li><p>如果是+0 减-0，则返回-0。</p></li><li><p>如果是-0 减-0，则返回+0。</p></li><li><p>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</p></li></ol><p>以下示例演示了上面的规则：</p><pre><code>let result1 = 5 - true; // true 被转换为 1，所以结果是 4let result2 = NaN - 1; // NaNlet result3 = 5 - 3; // 2let result4 = 5 - ""; // ""被转换为 0，所以结果是 5let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3let result6 = 5 - null; // null 被转换为 0，所以结果是 5 </code></pre><hr><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ol><li><p>如果操作数都是数值，则执行数值比较。</p></li><li><p>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</p></li><li><p>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p><p> let result = “23” &lt; “3”; // true</p></li></ol><p>这里在比较字符串”23”和”3”时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p><pre><code>let result = "23" &lt; 3; // false</code></pre><p>因为这次会将字符串”23”转换为数值 23，然后再跟 3 比较。但如果字符串不能转换成数值呢？比如下面这个例子：</p><pre><code>let result = "a" &lt; 3; // 因为"a"会转换为 NaN，所以结果是 false</code></pre><p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。</p><hr><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ol><li><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</p></li><li><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</p></li><li><p>如果一个操作数是对象，另，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</p></li></ol><p>在进行比较时，这两个操作符会遵循如下规则:</p><ol><li><p>null 和 undefined 相等。</p></li><li><p>null 和 undefined 不能转换为其他类型的值再进行比较。</p></li><li><p>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</p></li><li><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</p></li></ol><p>下表总结了一些特殊情况及比较的结果</p><table><thead><tr><th align="left">表 达 式</th><th align="left">结 果</th></tr></thead><tbody><tr><td align="left">null == undefined</td><td align="left">true</td></tr><tr><td align="left">“NaN” == NaN</td><td align="left">false</td></tr><tr><td align="left">5 == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN != NaN</td><td align="left">true</td></tr><tr><td align="left">false == 0</td><td align="left">true</td></tr><tr><td align="left">true == 1</td><td align="left">true</td></tr><tr><td align="left">true == 2</td><td align="left">false</td></tr><tr><td align="left">undefined == 0</td><td align="left">false</td></tr><tr><td align="left">null == 0</td><td align="left">false</td></tr><tr><td align="left">“5” == 5</td><td align="left">true</td></tr></tbody></table><h4 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</p><pre><code>let result1 = ("55" == 55); // true，转换后相等let result2 = ("55" === 55); // false，不相等，因为数据类型不同</code></pre><p>不全等操作符用一个叹号和两个等于号（!==）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：</p><pre><code>let result1 = ("55" != 55); // false，转换后相等let result2 = ("55" !== 55); // true，不相等，因为数据类型不同</code></pre><p>另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。</p><p>注意 由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</p><pre><code>variable = boolean_expression ? true_value : false_value;</code></pre><p>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果boolean_expression 是 false，则赋值 false_value。</p><hr><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><pre><code>let num1 = 1, num2 = 2, num3 = 3;</code></pre><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><pre><code>let num = (5, 1, 4, 8, 0); // num 的值为 0 </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a7.html"/>
      <url>posts/8a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="85be">语言基础(二)变量</a></strong><br>本篇: <strong>[语言基础(三)数据类型]</strong><br>下篇: <strong><a href="873e">语言基础(四)操作符</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。</p><hr><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p><p> “undefined”表示值未定义；<br> “boolean”表示值为布尔值；<br> “string”表示值为字符串；<br> “number”表示值为数值；<br> “object”表示值为对象（而不是函数）或 null；<br> “function”表示值为函数；<br> “symbol”表示值为符号。</p><p>下面是使用 typeof 操作符的例子：</p><pre><code>let message = "some string";console.log(typeof message); // "string"console.log(typeof(message)); // "string"console.log(typeof 95); // "number"</code></pre><p>在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><p>注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull 返回的是”object”。这是因为特殊值 null 被认为是一个对空对象的引用。</p><hr><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：</p><pre><code>let message;console.log(message == undefined); // true </code></pre><p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined // let age 确保没有声明过这个变量console.log(message); // "undefined"console.log(age); // 报错</code></pre><p>在上面的例子中，第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。</p><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// let age  确保没有声明过这个变量console.log(typeof message); // "undefined"console.log(typeof age); // "undefined"</code></pre><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// age 没有声明if (message) {// 这个块不会执行}if (!message) {// 这个块会执行}if (age) {// 这里会报错} </code></pre><hr><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：</p><pre><code>let car = null;console.log(typeof car); // "object" </code></pre><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后被重新赋予了一个对象的引用，比如：</p><pre><code>if (car != null) {// car 是一个对象的引用} </code></pre><p>undefined 值是由 null 值派生而来的<br>    console.log(null == undefined); // true </p><p>永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><pre><code>    let message = null;    let age;    if (message) {    // 这个块不会执行    }    if (!message) {    // 这个块会执行    }     if (age) {    // 这个块不会执行    }    if (!age) {    // 这个块会执行    } </code></pre><hr><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0</p><table><thead><tr><th align="left">数据类型</th><th align="left">转换为 true 的值</th><th align="left">转换为 false 的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">true</td><td align="left">false</td></tr><tr><td align="left">String</td><td align="left">非空字符串</td><td align="left">“”（空字符串）</td></tr><tr><td align="left">Number</td><td align="left">非零数值（包括无穷值）</td><td align="left">0、NaN（参见后面的相关内容）</td></tr><tr><td align="left">Object</td><td align="left">任意对象</td><td align="left">null</td></tr><tr><td align="left">Undefined</td><td align="left">N/A（不存在）</td><td align="left">undefined</td></tr></tbody></table><p>理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p><pre><code>let message = "Hello world!";if (message) {console.log("Value is true");}</code></pre><p>在这个例子中，console.log 会输出字符串”Value is true”，因为字符串 message 会被自动转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><hr><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><pre><code>let intNum = 55; // 整数</code></pre><p>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><pre><code>let octalNum1 = 070; // 八进制的 56let octalNum2 = 079; // 无效的八进制值，当成 79 处理let octalNum3 = 08; // 无效的八进制值，当成 8 处理</code></pre><p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p><p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0<del>9 以及 A</del>F）。十六进制数字中的字母大小写均可。下面是几个例子：</p><pre><code>let hexNum1 = 0xA; // 十六进制 10let hexNum2 = 0x1f; // 十六进制 31</code></pre><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><pre><code>let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐</code></pre><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：</p><pre><code>let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</code></pre><hr><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN：</p><pre><code>console.log(0/0); // NaNconsole.log(-0/+0); // NaN</code></pre><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：</p><pre><code>console.log(5/0); // Infinityconsole.log(5/-0); // -Infinity </code></pre><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><pre><code>console.log(NaN == NaN); // false </code></pre><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回<br>true。举例如下：</p><pre><code>console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false，10 是数值console.log(isNaN("10")); // false，可以转换为数值 10console.log(isNaN("blue")); // true，不可以转换为数值console.log(isNaN(true)); // false，可以转换为数值 1</code></pre><hr><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p><p>Number()函数基于如下规则执行转换。</p><p> 布尔值，true 转换为 1，false 转换为 0。<br> 数值，直接返回。<br> null，返回 0。<br> undefined，返回 NaN。<br> 字符串，应用以下规则。</p><ol><li><p>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面的零）。</p></li><li><p> 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p></li><li><p>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p></li><li><p>如果是空字符串（不包含字符），则返回 0。</p></li><li><p>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</p></li></ol><p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用<br>toString()方法，再按照转换字符串的规则转换。</p><pre><code>let num1 = Number("Hello world!"); // NaNlet num2 = Number(""); // 0let num3 = Number("000011"); // 11let num4 = Number(true); // 1</code></pre><p>可以看到，字符串”Hello world”转换之后是 NaN，因为它找不到对应的数值。</p><p>考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。下面几个转换示例有助于理解上述规则：</p><pre><code>let num1 = parseInt("1234blue"); // 1234let num2 = parseInt(""); // NaNlet num3 = parseInt("0xA"); // 10，解释为十六进制整数let num4 = parseInt(22.5); // 22let num5 = parseInt("70"); // 70，解释为十进制值let num6 = parseInt("0xf"); // 15，解释为十六进制整数</code></pre><p>通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p><pre><code>let num1 = parseInt("10", 2); // 2，按二进制解析let num2 = parseInt("10", 8); // 8，按八进制解析let num3 = parseInt("10", 10); // 10，按十进制解析let num4 = parseInt("10", 16); // 16，按十六进制解析</code></pre><p>parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p>parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。下面是几个示例：</p><pre><code>let num1 = parseFloat("1234blue"); // 1234，按整数解析let num2 = parseFloat("0xA"); // 0let num3 = parseFloat("22.5"); // 22.5let num4 = parseFloat("22.34.5"); // 22.34let num5 = parseFloat("0908.5"); // 908.5let num6 = parseFloat("3.125e7"); // 31250000</code></pre><hr><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的：</p><pre><code>    let firstName = "John";    let lastName = 'Jacob';    let lastName = `Jingleheimerschmidt`; </code></pre><h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="left">字 面 量</th><th align="left">含 义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\t</td><td align="left">制表</td></tr><tr><td align="left">\b</td><td align="left">退格</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\f</td><td align="left">换页</td></tr><tr><td align="left">\\</td><td align="left">反斜杠（\）</td></tr><tr><td align="left">\‘</td><td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, 'hey.'‘</td></tr><tr><td align="left">\“</td><td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, "hey."“</td></tr><tr><td align="left">\ `</td><td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td></tr><tr><td align="left">\xnn</td><td align="left">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td align="left">\unnnn</td><td align="left">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符”Σ”</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><pre><code>let text = "This is the letter sigma: \u03a3.";</code></pre><p>在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。</p><p>字符串的长度可以通过其 length 属性获取：</p><pre><code>console.log(text.length); // 28 </code></pre><h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><pre><code>let lang = "Java";lang = lang + "Script"; </code></pre><p>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”</p><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><pre><code>let age = 11;let ageAsString = age.toString(); // 字符串"11"let found = true;let foundAsString = found.toString(); // 字符串"true"</code></pre><p>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。</p><p>默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>String()函数遵循如下规则:</p><p> 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。<br> 如果值是 null，返回”null”。<br> 如果值是 undefined，返回”undefined”。</p><p>下面看几个例子：</p><pre><code>let value1 = 10;let value2 = true;let value3 = null;let value4;console.log(String(value1)); // "10"console.log(String(value2)); // "true"console.log(String(value3)); // "null"console.log(String(value4)); // "undefined" </code></pre><hr><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><pre><code>let myMultiLineString = 'first line\nsecond line';let myMultiLineTemplateLiteral = `first linesecond line`;console.log(myMultiLineString);// first line// second lineconsole.log(myMultiLineTemplateLiteral);// first line // second lineconsole.log(myMultiLineString === myMultiLinetemplateLiteral); // true </code></pre><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><pre><code>        let pageHTML = `        &lt;div&gt;        &lt;a href="#"&gt;        &lt;span&gt;Jake&lt;/span&gt;        &lt;/a&gt;        &lt;/div&gt;`;</code></pre><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><pre><code>// 这个模板字面量在换行符之后有 25 个空格符let myTemplateLiteral = `first line                        second line`;console.log(myTemplateLiteral.length); // 47// 这个模板字面量以一个换行符开头let secondTemplateLiteral = `first linesecond line`;console.log(secondTemplateLiteral[0] === '\n'); // true// 这个模板字面量没有意料之外的字符let thirdTemplateLiteral = `first linesecond line`;console.log(thirdTemplateLiteral);// first line// second line </code></pre><hr><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在${}中使用一个 JavaScript 表达式实现：</p><pre><code>let value = 5;let exponent = 'second';// 以前，字符串插值是这样实现的：let interpolatedString =value + ' to the ' + exponent + ' power is ' + (value * value);// 现在，可以用模板字面量这样实现：let interpolatedTemplateLiteral =`${ value } to the ${ exponent } power is ${ value * value }`;console.log(interpolatedString); // 5 to the second power is 25console.log(interpolatedTemplateLiteral); // 5 to the second power is 25</code></pre><p>嵌套的模板字符串无须转义：</p><pre><code>console.log(`Hello, ${ `World` }!`); // Hello, World! </code></pre><p>将表达式转换为字符串时会调用 toString()：</p><pre><code>let foo = { toString: () =&gt; 'World' };console.log(`Hello, ${ foo }!`); // Hello, World! </code></pre><p>在插值表达式中可以调用函数和方法：</p><pre><code>function capitalize(word) {return `${ word[0].toUpperCase() }${ word.slice(1) }`;}console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!</code></pre><p>此外，模板也可以插入自己之前的值：</p><pre><code>let value = '';function append() {value = `${value}abc`console.log(value);}append(); // abcappend(); // abcabcappend(); // abcabcabc </code></pre><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><pre><code>let o = new Object(); </code></pre><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ol><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。</p></li><li><p>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</p></li><li><p>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 6 章将详细介绍原型。）</p></li><li><p>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</p></li></ol><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。</p><hr><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>挖个坑~QvQ<br>此坑挖于: 2020/11/19<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/85be.html"/>
      <url>posts/85be.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="14a5">语言基础(一)语法</a></strong><br>本篇: <strong>语言基础(二)变量</strong><br>下篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量是松散类型的，意思是可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有三个关键字可以声明变量：var、const、let。其中，var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更高版本中使用。</p><hr><h4 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h4><p>要定义变量可以用操作符var，后跟变量名。<br>var message;</p><p>变量可以保存任何类型的值。不初始会保存一个特殊值undefined。</p><hr><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用var操作符定义的变量会成为包含它的函数的局部变量。比如使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过，在函数内部定义变量时省略var操作符，可以创建一个全局变量，只要调用一次函数，可以在函数外部引用: (不推荐这么做:省略var)</p><pre><code>            function test(){                message="hi";   //全局变量            }            test();            console.log(message); </code></pre><hr><h4 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h4><p>let跟var的作用差不多，但有个明显区别，var声明的范围是函数作用域，而let声明的范围是块作用域</p><pre><code>    if(true){        var name = 'M';        console.log(name); // M    }    console.log(name); // M    if(true){        let age = 'A';        console.log(age); // A    }    console.log(age); // 未定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也试用let</p><p>let也不允许同一个块作用域中出现重复声明</p><pre><code>    var name;    var name;    let age;    let age; //标识符age已经声明过了</code></pre><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><pre><code>    var name;    let name; // 错误    let age;    var age; // 错误 </code></pre><hr><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><pre><code>    var name="M";    console.log(name); // M    console.log(name02); //undefined    var name02="M";     console.log(name02); //报错    let name02="M"; </code></pre><hr><h5 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h5><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><pre><code>    var name = 'Matt';    console.log(window.name); // 'Matt'    let age = 26;    console.log(window.age); // undefined </code></pre><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><hr><h5 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h5><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {    // 循环逻辑    }    console.log(i); // 5</code></pre><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    // 循环逻辑    }     console.log(i); // ReferenceError: i 没有定义</code></pre><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {        setTimeout(() =&gt; console.log(i), 0)    }</code></pre><p>// 你可能以为会输出 0、1、2、3、4<br>// 实际上会输出 5、5、5、5、5 </p><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)    }    // 会输出 0、1、2、3、4 </code></pre><hr><h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 36; // TypeError: 给常量赋值// const 也不允许重复声明const name = 'Matt';const name = 'Nicholas'; // SyntaxError// const 声明的作用域也是块const name = 'Matt';if (true) {const name = 'Nicholas';}console.log(name); // Matt </code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = {};person.name = 'Matt'; // ok </code></pre><p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p><pre><code>for (const i = 0; i &lt; 10; ++i) {} // TypeError：给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p><pre><code>let i = 0;for (const j = 7; i &lt; 5; ++i) {console.log(j);}// 7, 7, 7, 7, 7for (const key in {a: 1, b: 2}) {console.log(key);}// a, bfor (const value of [1,2,3,4,5]) {console.log(value);}// 1, 2, 3, 4, 5 </code></pre><hr><h4 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h4><ol><li><p>不使用var，限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置以及不变的值。</p></li><li><p>const优先，let次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/14a5.html"/>
      <url>posts/14a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>本篇:<strong>语言基础(一)语法</strong><br>下篇:<strong><a href="85be">语言基础(二)变量</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h4><p>首先要知道,<strong>ECMAScript</strong>中一切都区分大小写。无论是<strong>变量</strong>、<strong>函数名</strong>还是<strong>操作符</strong>。换句话说<strong>变量test</strong>和<strong>变量Test</strong>是俩个不同的变量。类似的，<strong>typeof</strong>不能作为函数名，因为它是一个<strong>关键字</strong>。但是<strong>Typeof</strong>是一个完全有效的函数名。</p><hr><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>所谓<strong>标识符</strong>，就是<strong>变量</strong>、<strong>函数</strong>、<strong>属性</strong>或<strong>函数参数</strong>的名称。标识符可以由一或多个下列字符组成：</p><ol><li><p>第一个字符必须是一个<strong>字母</strong>、<strong>下划线</strong>(_)或<strong>美元符号</strong>($);</p></li><li><p>剩下的其他字符可以是<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>或<strong>数字</strong>。</p></li></ol><p>按照惯例，标识符使用<strong>驼峰大小写</strong>形式，即第一个单词首字母小写，后面每个单词的首字母大写。</p><p><strong>注意</strong> 关键字、保留字、true、false和null不能作为标识符。</p><hr><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>ECMAScript采用C语言风格的注释，包括单行注释和块注释。</p><p>单行注释以俩个斜杠字符开头， // 单行注释</p><p>块注释以一个斜杠和一个星号开头，以它们的反向组合结尾， /* 块注释 */</p><hr><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ECMAScript5增加了严格模式的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><p><code>"use strict"</code></p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p><pre><code>        function doSomething(){            "use strict";            //函数体        }</code></pre><p>所有现代浏览器都支持严格模式</p><hr><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>ECMASCript中语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><pre><code>        let sum = a + b   //没有分号也有效，但不推荐        let diff = a - b; //加分号有效，推荐</code></pre><p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号({)开始，右花括号(})结束。</p><p>if之类的控制语句只在执行多条语句要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即便只有一条语句。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="posts/c06f.html"/>
      <url>posts/c06f.html</url>
      
        <content type="html"><![CDATA[<p>网址在这里:</p><p>版本0.5:<br><a href="https://yanyanzio.top/Project/One/YYZMusic">https://yanyanzio.top/Project/One/YYZMusic</a></p><p>要源码可以联系我,有QQ</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗忘的HTML&amp;&amp;CSS</title>
      <link href="posts/e31c.html"/>
      <url>posts/e31c.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS溢出属性-overflow"><a href="#CSS溢出属性-overflow" class="headerlink" title="CSS溢出属性 overflow"></a>CSS溢出属性 overflow</h3><p>该overflow属性指定如果内容溢出元素框会发生什么情况。</p><p>此属性指定在元素的内容太大而无法放入指定区域时是剪辑内容还是添加滚动条。</p><p>/* 默认值。内容不会被修剪，会呈现在元素框之外 */<br>overflow: visible;</p><p>/* 内容会被修剪，并且其余内容不可见 */<br>overflow: hidden;</p><p>/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */<br>overflow: scroll;</p><p>/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */<br>overflow: auto;</p><p>/* 规定从父元素继承overflow属性的值 */<br>overflow: inherit;</p><hr><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。 </p><p>border 和 outline<br>border 和 outline 很类似，但有如下区别：</p><p>outline不占据空间，绘制于元素内容周围。<br>根据规范，outline通常是矩形，但也可以是非矩形的。</p><p>&lt;’outline-color’&gt;<br>设置轮廓的颜色。没有设置时默认值为 currentcolor。<br>&lt;’outline-style’&gt;<br>设置轮廓的样式。没有设置时默认值为 none。<br>&lt;’outline-width’&gt;<br>设置轮廓的宽度。没有设置时默认值为 medium</p><p>outline:none; 取消选中边框</p><hr><h3 id="选择器-交集选择器"><a href="#选择器-交集选择器" class="headerlink" title="选择器: 交集选择器"></a>选择器: 交集选择器</h3><p>我主要用在绑定一个标签, 如: .Old.Xin  有一个源 <code>&lt;div class="Old"&gt;&lt;/div&gt;</code></p><p>想要在这个<strong>div</strong>中添加一个新的类,即<code>&lt;div class="Old Xin"&gt;&lt;/div&gt;</code></p><p>就用 <strong>.Old.Xin</strong> 交集选择器</p><hr><h3 id="webkit-scrollbar-滚轮样式"><a href="#webkit-scrollbar-滚轮样式" class="headerlink" title="::-webkit-scrollbar 滚轮样式"></a>::-webkit-scrollbar 滚轮样式</h3><p>::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样</p><p>::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分</p><hr><h3 id="img的边框"><a href="#img的边框" class="headerlink" title="img的边框"></a>img的边框</h3><ol><li><code>&lt;img&gt;</code> 标签的 border 属性规定图像周围的边框的宽度</li></ol><p><code>border: none;</code> // css属性</p><ol start="2"><li><p>当img没有接收到src属性的时候会自动出现边框，border:0/none都不管用的情况下，解决方法：</p><pre><code> img[src=""],img:not([src]){     opacity:0; }</code></pre></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="posts/e0b8.html"/>
      <url>posts/e0b8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js是一套构建用户界面的渐进式框架</p><p>Vue.js 只关注视图层， 设计时采用自底向上渐进式开发的构架，核心部件只关注用户界面的构建</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p><p><strong>注意</strong>： Vue.js 不支持 IE8 及其以下 IE 版本</p><h3 id="为什么要使用Vue"><a href="#为什么要使用Vue" class="headerlink" title="为什么要使用Vue"></a>为什么要使用Vue</h3><p>1.轻量级,体积小是一个重要指标,Vue.Js压缩后只有20多KB<br>2.移动优先,更适合移动端,比如移动端的Touch事件<br>3.易上手,学习曲线平稳,文档齐全<br>4.吸收了Angular(模块化)和React(虚拟DOM的长处),并拥有自己独特的功能<br>5.开源,社区活跃度高<br>…</p><h3 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h3><p>在我们继续学习 Vue.js 2 之前，希望对以下知识有一定的了解<br><strong>HTML</strong><br><strong>CSS</strong><br><strong>JavaScript</strong></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><strong>Vue.js</strong> 是一个 <strong>JavaScript</strong> 脚本库，所以安装起来非常简单，只要引用 <strong>vue.min.js</strong> 脚本就可以了</p><p>可以在 Vue.js 的官网上直接下载 vue.min.js 然后使用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li><p><strong>安装 cnpm</strong><br><code>npm install --global cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p><strong>全局安装 vue-cli</strong><br><code>$ cnpm install --global vue-cli</code></p></li><li><p><strong>创建一个基于 webpack 模板的新项目</strong><br><code>$ vue init webpack yyzvue</code></p></li><li><p>这里需要你进行一些配置，如果不想更改，可以直接回车</p></li></ol><p><code>$ vue init webpack yyzvue</code>  </p><p><code>? Project name yyzvue</code><br><code>? Project description A Vue.js project</code><br><code>? Author sense &lt;yu.fei@gmail.com&gt;</code><br><code>? Vue build standalone</code><br><code>? Install vue-router? Yes</code><br><code>? Use ESLint to lint your code? Yes</code><br><code>? Pick an ESLint preset Standard</code><br><code>? Set up unit tests Yes</code><br><code>? Pick a test runner jest</code><br><code>? Setup e2e tests with Nightwatch? Yes</code></p><p>   <code>vue-cli · Generated "webapp".</code></p><p>   <code>To get started:</code><br>     <code>cd webapp</code><br>     <code>npm install</code><br>     <code>npm run dev</code><br>   <code>Documentation can be found at https://vuejs-templates.github.io/webpack</code></p><ol start="3"><li>安装依赖并运行<br>配置配置完成后，可以进入项目，然后执行以下命令</li></ol><p><code>$ cd webapp</code><br><code>$ cnpm install</code><br>先去喝杯茶，然后调戏小孩，再回来看看是否安装好了…</p><p><code>$ npm run dev</code></p><p> <code>DONE  Compiled successfully in </code></p><p> <code>I  Your application is running here: http://localhost:8080</code></p><p> 成功执行以上命令后访问 <a href="http://localhost:8080/%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">http://localhost:8080/，输出结果如下所示</a></p><p> <img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_1.png"></p><hr><h2 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h2><p>上一章节中，我们使用 vue-cli 工具创建了一个 webapp 的项目</p><p>如果我们使用 IDE（Eclipse、Atom）打开该目录，显示目录结构如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_2.png"></p><h3 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h3><table><thead><tr><th align="left">目录/文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">build</td><td align="left">最终发布的代码存放位置</td></tr><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的</td></tr><tr><td align="left">node_modules</td><td align="left">npm 加载的项目依赖模块</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里里面包含了几个目录及文件assets: 放置一些图片，如logo等components: 目录里面放了一个组件文件，可以不用App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录main.js: 项目的核心文件</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">.xxxx文件</td><td align="left">这些是一些配置文件，包括语法配置，git配置等</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或同统计代码啥的</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><h3 id="用vue写一个hello-word"><a href="#用vue写一个hello-word" class="headerlink" title="用vue写一个hello word"></a>用vue写一个hello word</h3><p>代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id="app"&gt;        {{message}}    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_3.png"></p><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>&lt;div id="app_01"&gt;    {{mes+'!'}}    &lt;h2 v-text="mes+'!'"&gt;iii&lt;/h2&gt;    &lt;h2&gt;hah{{mes}}iii&lt;/h2&gt;&lt;/div&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>    &lt;div id="app_01"&gt;    &lt;span v-text="mes"&gt;&lt;/span&gt;    &lt;span v-html="mes"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm= new Vue({        el: '#app_01' ,        data:{            mes: '&lt;p style="color:red;font-size:30px;"&gt;言言子&lt;/p&gt;'        }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>设置元素属性值,如: v-bind:src=”imgSrc”,v-bind:title=”arcTit”<br>其中 v-bind 可以省略</p><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-bind:title="message"&gt;HHHHH&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>当把鼠标放到<strong>HHHHH</strong>上时,鼠标下会有个标记</p><p>你看到的 <strong>v-bind</strong> 等被称为标记,指令带有前缀<strong>v-</strong>,以示他们是<strong>Vue</strong>提供的特殊特性</p><p>他们会在渲染的<strong>DOM</strong>上应用特殊的响应式行为。在这里,指令的意思为：将这个元素节点的<strong>title</strong></p><p>特性和<strong>Vue</strong>实例的<strong>message</strong>属性保持一致。</p><p>如果打开浏览器的控制台，输入<code>vue.message="哦哦哦哦哦"</code>,就会看到绑定了<strong>title</strong>特性的HTML</p><p>已经进行了更新</p><h3 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h3><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok"&gt;YES&lt;/span&gt;        &lt;span v-else&gt;NONONO&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: true            }        } );    &lt;/script&gt;&lt;/body&gt;&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok==='A'"&gt;这是A&lt;/span&gt;        &lt;span v-else-if="ok==='B'"&gt;这是B&lt;/span&gt;        &lt;span v-else&gt;啥也不是&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: 'A'            }        } );    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>&lt;div id="app"&gt;        &lt;p v-for="item in items"&gt;            {{item.message}}        &lt;/p&gt;&lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: "#app",            data: {                items: [                    {message: '言言子好可爱!'},                    {message: '言言子好萌!'}                ]            }        });    &lt;/script&gt;</code></pre><p>在控制台里，输入 vm.items.push({ message: ‘芜湖！好耶！’ })，你会发现列表最后添加了一个新项目</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><pre><code>&lt;div id="app_01"&gt;    &lt;p @click="func"&gt;{{message}}&lt;/p&gt;    &lt;input type="button" value="事件绑定-点击" v-on:click="func"&gt;    &lt;input type="button" value="事件绑定-点击" @click="func"&gt;    &lt;input type="button" value="事件绑定-" v-on:monseenter="func"&gt;    &lt;input type="button" value="事件绑定-双击" v-on:dblclick="func"&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app_01",            data: {                message: "ABC"            },            methods: {                func() {                    this.message = this.message.split('').reverse().join('');                }            }    }); &lt;/script&gt;</code></pre><p><strong>split() 方法用于把一个字符串分割成字符串数组</strong><br><strong>reverse() 方法用于颠倒数组中元素的顺序</strong><br><strong>join() 方法用于把数组中的所有元素放入一个字符串</strong></p><p>注意在 <strong>reverseMessage</strong> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><h3 id="用Vue做简单计数器"><a href="#用Vue做简单计数器" class="headerlink" title="用Vue做简单计数器"></a>用Vue做简单计数器</h3><pre><code>    &lt;div id="app"&gt;    &lt;button @click="add"&gt;+&lt;/button&gt;    &lt;span&gt;{{num}}&lt;/span&gt;    &lt;button @click="jian"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app",            data: {                num: 0            },            methods: {                add(){                    if(this.num&lt;10){                        this.num+=1;                    }else{                        alert("最大为10!");                    }                },                jian(){                    if(this.num&gt;0){                        this.num-=1;                    }else{                        alert("最小为0!");                    }                }            }    });&lt;/script&gt;</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达式的真假切换元素的显示和隐藏</p><pre><code>&lt;div id="app"&gt;    &lt;button @click="q"&gt;点击隐藏图片&lt;/button&gt;    &lt;img src="./1.jpg" v-show="isShow"&gt;    &lt;img src="./1.jpg" v-if="isShow"&gt;    &lt;img src="./1.jpg" v-show="age&gt;20"&gt;&lt;/div&gt;&lt;script&gt;    var vm =new Vue({        el: "#app",    data: {            isShow: true,            age: 18    },    methods: {            q(){                this.isShow= !this.isShow;            }    }    });&lt;/script&gt;</code></pre><p>频繁切换的元素用 <strong>v-show</strong>,反之用 <strong>v-if</strong></p><p>因为操作DOM数对性能的消耗比较大(<strong>v-if</strong>)</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue 还提供了 <strong>v-model</strong> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><pre><code>&lt;div id="app-6"&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单</p><pre><code>&lt;div class="app"&gt;    &lt;yan&gt;&lt;/yan&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个Vue组件    Vue.component('yan',{        template: '&lt;p&gt;言言子努力加油&lt;/p&gt;'    })     var vm= new Vue({         el: "#app"     }); &lt;/script&gt;</code></pre><h3 id="用Vue切换图片"><a href="#用Vue切换图片" class="headerlink" title="用Vue切换图片"></a>用Vue切换图片</h3><pre><code>&lt;div id="app"&gt;    &lt;div&gt;            &lt;img :src="img[index]" alt=""&gt;            &lt;a href="##" @click="sub" v-show="index!=0"&gt;&lt;&lt;/a&gt;            &lt;a href="##" @click="add" v-show="index&lt;img.length-1"&gt;&gt;&lt;/a&gt;        &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: '#app',        data:{                img: ['./1.jpg','./2.jpg','./3.png'],                index: 0        },        methods:{            add(){                    this.index++;            },            sub(){                    this.index--;            }        }    });&lt;/script&gt;</code></pre><h3 id="用Vue做一个记录本功能"><a href="#用Vue做一个记录本功能" class="headerlink" title="用Vue做一个记录本功能"></a>用Vue做一个记录本功能</h3><pre><code>&lt;div id="app"&gt;    &lt;header&gt;        &lt;h1&gt;记事本&lt;/h1&gt;        &lt;input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;ul&gt;            &lt;li v-for="(item,index) in arr"&gt;                &lt;div&gt;                    &lt;span&gt;{{index+1}}.&lt;/span&gt;                    &lt;label&gt;{{item}}&lt;/label&gt;                    &lt;button @click="sub(index)"&gt;&lt;/button&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;footer v-show="arr.length!=0" &gt;        &lt;span&gt;            &lt;strong  &gt;{{arr.length}}&lt;/strong&gt;        &lt;/span&gt;        &lt;button @click="clear"&gt;Clear&lt;/button&gt;    &lt;/footer&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: "#app",        data: {            arr: [                "ABC",                "QWE",                "ZXC"            ],            inputValue: ""        },        methods: {            add(){                this.arr.push(this.inputValue);            },            sub(index){                this.arr.splice(index,1);            },            clear(){                this.arr= []            }        }    });&lt;/script&gt;</code></pre><hr><h2 id="AXIOS的基本使用-实例"><a href="#AXIOS的基本使用-实例" class="headerlink" title="AXIOS的基本使用(实例)"></a>AXIOS的基本使用(实例)</h2><pre><code>&lt;input type="button"  id="get" value="get请求"&gt;&lt;input type="button" id="post" value="post请求"&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script&gt;    document.querySelector("#get").onclick= function(){        axios.get("https://autumnfish.cn/api/joke/listsadsad?num=1")        .then(function (response){            console.log(response);        },function(err){            console.log(err);        })    }    document.querySelector("#post").onclick=function(){        axios.post("https://autumnfish.cn/api/user/reg",        {username: "言言子"})        .then(function(re){            console.log(re);        },function(err){            console.log(err);        })    }&lt;/script&gt;</code></pre><h3 id="AXIOS-Vue-获取笑话"><a href="#AXIOS-Vue-获取笑话" class="headerlink" title="AXIOS+Vue:获取笑话"></a>AXIOS+Vue:获取笑话</h3><pre><code>&lt;div id="app"&gt;    &lt;input type="button" value="获取笑话" @click="getJoke"&gt;    &lt;p&gt;{{Joke}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm=new Vue({        el: "#app",        data: {            Joke: ""        },        methods: {            getJoke(){                var that= this;                axios.get("https://autumnfish.cn/api/joke")                .then(function(resq){                                            that.Joke= resq.data;                })            }        }    });&lt;/script&gt;</code></pre><h3 id="网络应用-天气查询"><a href="#网络应用-天气查询" class="headerlink" title="网络应用:天气查询"></a>网络应用:天气查询</h3><pre><code>HTML&lt;div id="app"&gt;        &lt;div&gt;            &lt;p&gt;天知道&lt;/p&gt;            &lt;div&gt;                &lt;input type="text" placeholder="请输入查询天气"                 @keyup.enter="searchTQ" v-model="city"&gt;                &lt;input type="button" value="搜索"&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;a href="##" @click="changeCity('北京')"&gt;北京&lt;/a&gt;                &lt;a href="##" @click="changeCity('上海')"&gt;上海&lt;/a&gt;                &lt;a href="##" @click="changeCity('广州')"&gt;广州&lt;/a&gt;                &lt;a href="##" @click="changeCity('深圳')"&gt;深圳&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li v-for="item in weatherList"&gt;                &lt;div&gt;{{item.date}}&lt;/div&gt;                &lt;span&gt;{{item.low}} ~ {{item.high}}&lt;/span&gt;                &lt;span&gt;{{item.type}}&lt;/span&gt;                &lt;span&gt;{{item.fengxiang}}&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;     &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;     JS    window.onload=function(){        var vm=new Vue({            el: "#app",            data: {                city: "",                weatherList: []            },            methods: {                searchTQ(){                    var that=this;                    axios.get("http://wthrcdn.etouch.cn/weather_mini?city="                    +this.city).then(function(resq){                        that.weatherList=resq.data.data.forecast;                    },function(err){                        alert(err);                    })                },                changeCity(city){                    this.city=city;                    this.searchTQ();                }            }        });    };</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/f7d3.html"/>
      <url>posts/f7d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id="Canvas-平移-translate"><a href="#Canvas-平移-translate" class="headerlink" title="Canvas 平移 translate()"></a>Canvas 平移 translate()</h2><p>平移 (translate) 就是将一个图形往水平方向和垂直方向移动一定的距离 <strong>(dx,dy)</strong></p><p>但是，Canvas 中的所有几何变换针对的不是绘制的图形，而是针对画布本身</p><p>例如刚开始的时候在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_42.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>translate(50,50)</strong> 将画布水平和垂直方向各移动 50</p><p>然后在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_43.png"></p><p>此时矩形的起点距离屏幕左上角就已经是 <strong>(100,100)</strong> 了</p><p><strong>语法</strong><br><code>void ctx.translate(dx, dy);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的移动距离</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的移动距离</td></tr></tbody></table><p>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后平移 canvas (50,50) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.translate(50,50);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_44.png"></p><hr><h2 id="Canvas-缩放-scale"><a href="#Canvas-缩放-scale" class="headerlink" title="Canvas 缩放 scale()"></a>Canvas 缩放 scale()</h2><p>缩放 (scale) 就是将一个图形围绕中心点，然后将宽和高分别乘以一定的因子(sx,sy)</p><p>但是，Canvas 中的缩放 (scale) 针对的不是绘制的图形，而是针对画布本身</p><p>画布缩放了，那么画在画布上的图形自然也就缩放了</p><p>例如刚开始的时候在 <strong>(100,100)</strong> 绘制一个 <strong>25x25</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_45.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>scale(0.5,2)</strong> 将画布水平方向缩小一倍和垂直方向放大一倍的时候</p><p>这是什么意思呢？</p><p>就是原来水平方向的 1 个单位现在变成了 0.5 个单位了，垂直方向的 1 个单位现在变成了 2 个单位了</p><p>然后在 <strong>(100,100)</strong> 绘制一个 <strong>5x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_46.png"></p><p><strong>ctx.scale()</strong> 将 <strong>canvas</strong> 水平方向和垂直方向的单位各乘以一定的因子(sx,sy)</p><p>从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离</p><p><strong>语法</strong><br><code>void ctx.scale(sx, sy)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的缩放因子</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的缩放因子</td></tr></tbody></table><p>dx 和 dy 的值可以是负数，负数是啥意思呢？就是想把整个 canvas 翻转，然后再缩放</p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后缩放画布 canvas <strong>(0.5,2)</strong> 最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_47.png"></p><p>如果缩放因子是负数，那么先镜像 (也就是先翻转)，然后再缩放</p><p>如果 sx 是负数，则先按照 Y 轴镜像，然后再缩放<br>如果 sy 是负数，则先按照 X 轴镜像，然后再缩放<br>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后缩放画布 canvas (-0.5,2) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_48.png"></p><p>哎呀，为什么绿色的没掉了呢？因为，因为垂直镜像了之后，x 轴正方向已经从水平向左改成水平向右了</p><p>如果此时还在 <strong>(50,50)</strong> 的位置画画，肯定是看不到啊，因为它已经跑到另一边去了，而屏幕的位置没变啊，于是就看不到了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_49.png"><br>绿色边框是我们的屏幕显示范围</p><p>如果此时还要看到它，就要把绘制起始点的 x 坐标也翻转下，然后再 x 2 就是变成 (-50)x2=-100 就好了</p><p>如果不 x 2 ，结果还是看不到的，因为 -50 也只是把矩形往右移动了 50 像素，到哪里了？ 贴边了…</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-3");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(-100,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_50.png"></p><hr><h2 id="Canvas-旋转-rotate"><a href="#Canvas-旋转-rotate" class="headerlink" title="Canvas 旋转 rotate()"></a>Canvas 旋转 rotate()</h2><p>旋转 ( rotate ) 就是将图形围绕一个中心点(0,0)，顺时针或者逆时针旋转一定的弧度 ( angle )</p><p>但是，Canvas 中的旋转 ( rotate ) 针对的不是绘制的图形，而是针对画布本身</p><p>画布旋转了，带来最直接的结果是什么呢？ 就是某个点与屏幕上边之间的夹角改变了</p><p>我们看一个正常情况下的笛卡尔坐标体系，某个点(50,50) 与屏幕上边和 X 轴正方向之间的夹角都是 45 度</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_51.png"></p><p><strong>绿色</strong> 的是屏幕</p><p><strong>灰色</strong> 的是画布</p><p>当我们画布顺时针旋转 30 度后，就变成了下图这样了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_52.png"></p><p>点还是那个点，点与画布之间的夹角还是 <strong>45°</strong>，但点与屏幕间的夹角已经变成了 <strong>75°</strong></p><p>最直观的感受是啥？ 就是点往左下移了那么一点点，我们去掉各种辅助线，大家看看</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_53.png"></p><p>一个点已经是这样了，如果我们画的是一个图形，那么图形上的所有点都移动了，那么直观看起来，就是图形旋转了</p><p><strong>语法</strong><br><code>void ctx.rotate(angle);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">angle</td><td align="left">顺时针旋转的弧度。可以通过角度值计算：degree * Math.PI / 180</td></tr></tbody></table><p><strong>弧度 angle</strong><br>我们特别说明下 <strong>angle</strong> 这个参数，它是一个弧度</p><p>如果我们要顺时针旋转<strong>30°</strong>，那么</p><p><code>angle = 30 * Math.PI / 180</code><br>如果想要逆时针旋转 <strong>30°</strong> 怎么办呢？逆时针旋转 30°，其实就是顺时针旋转 -30°，也就是</p><p><code>angle = 360 + ( -30 * Math.PI / 180 )</code></p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后顺时针旋转画布 <strong>30°</strong></p><p>最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.rotate(30 * Math.PI / 180);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_54.png"></p><p>我们利用多次旋转画一个折扇图</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var colors = ['#D0021B','#F5A623','#8B572A','#417505','#9013FE','#000000']for ( var i = 0; i &lt; colors.length; i++ ){    ctx.fillStyle = colors[i];    ctx.fillRect(0,0,200,50);    ctx.rotate(15 * Math.PI / 180);}&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_55.png"></p><hr><h2 id="Canvas-橡皮擦-clearRect"><a href="#Canvas-橡皮擦-clearRect" class="headerlink" title="Canvas 橡皮擦 clearRect()"></a>Canvas 橡皮擦 clearRect()</h2><p><strong>ctx.clearRect()</strong> 方法设置指定矩形区域内（以点 (x, y) 为起点，范围是 (width, height) ）所有像素变成透明，并擦除之前绘制的所有内容</p><p><strong>语法</strong><br><code>void ctx.clearRect(x, y, width, height);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">矩形起点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">矩形起点的 y 轴坐标</td></tr><tr><td align="left">width</td><td align="left">矩形的宽度</td></tr><tr><td align="left">height</td><td align="left">矩形的高度</td></tr></tbody></table><p>我们先从 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形，然后再使用 clearRect() 擦出这个矩形的 1/4</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);ctx.clearRect(50,50,200/2,50/2);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_56.png"></p><hr><h2 id="Canvas-绘图上下文-save"><a href="#Canvas-绘图上下文-save" class="headerlink" title="Canvas 绘图上下文 save()"></a>Canvas 绘图上下文 save()</h2><p>Canvas 为我们提供了 图层(Layer) 的支持，Layer(图层) 是按 “栈结构” 来进行管理的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_57.png"></p><p>当我们调用<strong>save()</strong> 方法，会保存当前 Canvas 的状态然后作为一个 Layer(图层)，添加到 Canvas栈 中，</p><p>而当我们调用 <strong>restore()</strong> 方法的时候，会恢复之前 Canvas 的状态，而此时 Canvas 的图层栈 会弹出栈顶的那个 Layer，后继的 Layer 来到栈顶，此时的 Canvas 回复到此栈顶时保存的 Canvas 状态</p><p>简单说就是 <strong>save() 往栈压入一个 Layer，restore()弹出栈顶的一个Layer，这个 Layer 代表Canvas的 状态</strong>！</p><p>也就是说可以 <strong>save()</strong> 多次，也可以 <strong>restore()</strong> 多次，但是 <strong>restore()</strong> 的调用次数 不能大于 <strong>save()</strong> 否则会引发错误</p><p><code>ctx.save()</code> 方法用于将画布的当前状态保存到栈中</p><p>下面的代码使用 save() 方法保存默认的状态，然后平移 (100,100) 绘制一个绿色矩形后，恢复之前的状态，最后再使用默认的设置绘制一个矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.save();ctx.translate(100,100);ctx.fillStyle = "green"ctx.fillRect(50,50,100,50);ctx.restore();ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_58.png"></p><hr><h2 id="Canvas-恢复画板状态-restore"><a href="#Canvas-恢复画板状态-restore" class="headerlink" title="Canvas 恢复画板状态 restore()"></a>Canvas 恢复画板状态 restore()</h2><p><code>ctx.restore()</code> 方法用于将画布恢复到最近一次的保存状态</p><p>如果没有保存状态，此方法不做任何改变</p><hr><h2 id="Canvas-图像混排模式"><a href="#Canvas-图像混排模式" class="headerlink" title="Canvas 图像混排模式"></a>Canvas 图像混排模式</h2><p>首先绘制一个蓝色的矩形，然后绘制一个红色矩形和它重叠，看看不同的图形混排模式带来的效果</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_59.png"></p><p><strong>所有代码如下</strong></p><pre><code>&lt;canvas id="canvas-1" width="500" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var gco = [ 'source-over','source-in','source-out','source-atop',            'destination-over','destination-in','destination-out','destination-atop',            'lighter', 'copy','xor', 'multiply', 'screen', 'overlay', 'darken',            'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'        ];var canvas = document.getElementById("canvas-1");canvas.width = 500;canvas.height = 2700;var ctx = canvas.getContext("2d");function draw(){    for (var i = 0; i &lt; gco.length; i++ )    {        ctx.font = "16px Microsoft YaHei"        ctx.textBaseline = "middle";        ctx.fillStyle="#333"        ctx.save();        ctx.fillText(gco[i],10,15);        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.translate(70,0)        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.fillStyle = "red";        ctx.fillRect(25, 50, 50, 50);        var canvas2 = document.createElement("canvas");        ctx2 = canvas2.getContext("2d");        ctx2.fillStyle = "blue";        ctx2.fillRect(10, 35, 50, 50);        ctx2.globalCompositeOperation = gco[i];        ctx2.fillStyle = "red";        ctx2.fillRect(25, 50, 50, 50);        ctx2.globalCompositeOperation = "source-over";        ctx.drawImage(canvas2,85,0);        ctx.restore();        ctx.translate(0,100);    }}draw();&lt;/script&gt;</code></pre><hr><h2 id="Canvas-图像裁剪"><a href="#Canvas-图像裁剪" class="headerlink" title="Canvas 图像裁剪"></a>Canvas 图像裁剪</h2><p>裁剪用于隐藏部分我们不想看到的图形</p><p>Canvas 中的裁剪和 Photoshop 中的裁剪不一样，Photoshop 中的裁剪针对的是图形，而 Canvas 中的裁剪针对的是画布本身</p><p>Canvas 中的裁剪只有一种方法，就是根据路径来裁剪</p><p>比如我们有一个画布，画布上有一张图片和一个五角星的路径</p><p><strong>语法</strong><br><code>void ctx.clip();</code><br><code>void ctx.clip(fillRule);</code><br><code>void ctx.clip(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">裁剪算法，用于设置判断一个点是在路径内还是在路径外，可选的值有</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕原则，默认的原则</td></tr><tr><td align="left">“evenodd”: 奇偶环绕原则</td><td align="left"></td></tr><tr><td align="left">path</td><td align="left">需要剪切的 Path2D 路径</td></tr></tbody></table><p>先画一个路径，然后调用 clip() 说我要裁剪接下来的图形，而且终身有效</p><p>如果不需要了，那么可以在调用 clip() 前先调用 save() 保存状态，然后再使用完后调用 </p><p>restore() 恢复状态</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c2   = document.getElementById("canvas-2");var ctx2 = c2.getContext("2d");ctx2.save();ctx2.arc(100, 100, 75, 0, Math.PI*2, false);ctx2.clip();ctx2.fillRect(0, 0, 100,100);ctx2.fillStyle="green";ctx2.fillRect(100, 100, 100,100);ctx2.restore();ctx2.fillStyle="red";ctx2.fillRect(40, 40, 30,30);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_60.png"></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
