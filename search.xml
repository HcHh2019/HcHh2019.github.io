<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>I3</title>
      <link href="posts/8577.html"/>
      <url>posts/8577.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I2</title>
      <link href="posts/45b6.html"/>
      <url>posts/45b6.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I1</title>
      <link href="posts/44f6.html"/>
      <url>posts/44f6.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(十二)</title>
      <link href="posts/a0038.html"/>
      <url>posts/a0038.html</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>上篇： <strong><a href="a0037">BOM(二)：location对象</a></strong><br>本篇： <strong>BOM(三)：history对象</strong><br>下篇： <strong><a href="a0039"></a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h1><p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退。</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。这个方法只接收一个参数，这个参数可以是一个整数，表示前进或后退多少步。负值表示在历史记录中后退（类似点击浏览器的“后退”按钮），而正值表示在历史记录中前进（类似点击浏览器的“前进”按钮）。下面来看几个例子：</p><pre><code>// 后退一页history.go(-1);// 前进一页history.go(1);// 前进两页history.go(2); </code></pre><p>在旧版本的一些浏览器中，go()方法的参数也可以是一个字符串，这种情况下浏览器会导航到历<br>史中包含该字符串的第一个位置。最接近的位置可能涉及后退，也可能涉及前进。如果历史记录中没有匹配的项，则这个方法什么也不做，如下所示：</p><pre><code>// 导航到最近的 wrox.com 页面history.go("wrox.com");// 导航到最近的 nczonline.net 页面history.go("nczonline.net"); </code></pre><p>go()有两个简写方法：back()和 forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮：</p><pre><code>// 后退一页history.back();// 前进一页history.forward(); </code></pre><p>history 对象还有一个 length 属性，表示历史记录中有多个条目。这个属性反映了历史记录的数量，包括可以前进和后退的页面。对于窗口或标签页中加载的第一个页面，history.length 等于 1。通过以下方法测试这个值，可以确定用户浏览器的起点是不是你的页面：</p><pre><code>if (history.length == 1){// 这是用户窗口中的第一个页面} </code></pre><p>history 对象通常被用于创建“后退”和“前进”按钮，以及确定页面是不是用户历史记录中的第一条记录。</p><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><p>现代 Web 应用程序开发中最难的环节之一就是历史记录管理。用户每次点击都会触发页面刷新的时代早已过去，“后退”和“前进”按钮对用户来说就代表“帮我切换一个状态”的历史也就随之结束了。为解决这个问题，首先出现的是 hashchange 事件（第 17 章介绍事件时会讨论）。HTML5 也为history 对象增加了方便的状态管理特性。</p><p>hashchange 会在页面 URL 的散列变化时被触发，开发者可以在此时执行某些操作。而状态管理API 则可以让开发者改变浏览器 URL 而不会加载新页面。为此，可以使用 history.pushState()方法。这个方法接收 3 个参数：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。例如：</p><pre><code>let stateObject = {foo:"bar"};history.pushState(stateObject, "My title", "baz.html");</code></pre><p>pushState()方法执行后，状态信息就会被推到历史记录中，浏览器地址栏也会改变以反映新的相对 URL。除了这些变化之外，即使 location.href 返回的是地址栏中的内容，浏览器页不会向服务器发送请求。第二个参数并未被当前实现所使用，因此既可以传一个空字符串也可以传一个短标题。第一个参数应该包含正确初始化页面状态所必需的信息。为防止滥用，这个状态的对象大小是有限制的，通常在 500KB～1MB 以内。</p><p>因为 pushState()会创建新的历史记录，所以也会相应地启用“后退”按钮。此时单击“后退”按钮，就会触发 window 对象上的 popstate 事件。popstate 事件的事件对象有一个 state 属性，其中包含通过 pushState()第一个参数传入的 state 对象：</p><pre><code>window.addEventListener("popstate", (event) =&gt; {    let state = event.state;    if (state) { // 第一个页面加载时状态是 null        processState(state);    }}); </code></pre><p>基于这个状态，应该把页面重置为状态对象所表示的状态（因为浏览器不会自动为你做这些）。记住，页面初次加载时没有状态。因此点击“后退”按钮直到返回最初页面时，event.state 会为 null。</p><p>可以通过 history.state 获取当前的状态对象，也可以使用 replaceState()并传入与pushState()同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态：</p><p><code>history.replaceState({newFoo: "newBar"}, "New title");</code></p><p>传给 pushState()和 replaceState()的 state 对象应该只包含可以被序列化的信息。因此，DOM 元素之类并不适合放到状态对象里保存。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(十二)</title>
      <link href="posts/a0037.html"/>
      <url>posts/a0037.html</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>上篇： <strong><a href="a0036">BOM(一)：window对象</a></strong><br>本篇： <strong>BOM(二)：location对象</strong><br>下篇： <strong><a href="a0038">BOM(三)：navigator对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h1><p>location 是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性。也就是说，window.location 和 document.location 指向同一个对象。location 对象不仅保存着当前加载文档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息。这些解析后的属性在下表中有详细说明（location 前缀是必需的）。</p><p>假设浏览器当前加载的 URL 是 <a href="http://foouser:barpassword@www.wrox.com:80WileyCDA/?q=javascript#contents，location">http://foouser:barpassword@www.wrox.com:80WileyCDA/?q=javascript#contents，location</a> 对象的内容如下表所示。</p><table><thead><tr><th align="left">属 性</th><th align="left">值</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">location.hash</td><td align="left">“#contents”</td><td align="left">URL 散列值（井号后跟零或多个字符），如果没有则</td></tr><tr><td align="left">为空字符串</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">location.host</td><td align="left">“<a href="http://www.wrox.com:80&quot;">www.wrox.com:80"</a></td><td align="left">服务器名及端口号</td></tr><tr><td align="left">location.hostname</td><td align="left">“<a href="http://www.wrox.com&quot;/">www.wrox.com"</a></td><td align="left">服务器名</td></tr><tr><td align="left">location.href</td><td align="left">“<a href="http://www.wrox.com/WileyCDA/?q=javascript#contents&quot;">http://www.wrox.com:80/WileyCDA/?q=javascript#contents"</a></td><td align="left">当前加载页面的完整 URL。location 的 toString()方法返回这个值</td></tr><tr><td align="left">location.pathname</td><td align="left">“/WileyCDA/“</td><td align="left">URL 中的路径和（或）文件名</td></tr><tr><td align="left">location.port</td><td align="left">“80”</td><td align="left">请求的端口。如果 URL中没有端口，则返回空字符串</td></tr><tr><td align="left">location.protocol</td><td align="left">“http:”</td><td align="left">页面使用的协议。通常是”http:”或”https:”</td></tr><tr><td align="left">location.search</td><td align="left">“?q=javascript”</td><td align="left">URL 的查询字符串。这个字符串以问号开头</td></tr><tr><td align="left">location.username</td><td align="left">“foouser”</td><td align="left">域名前指定的用户名</td></tr><tr><td align="left">location.password</td><td align="left">“barpassword”</td><td align="left">域名前指定的密码</td></tr><tr><td align="left">location.origin</td><td align="left">“<a href="http://www.wrox.com&quot;/">http://www.wrox.com"</a></td><td align="left">URL 的源地址。只读</td></tr></tbody></table><h2 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h2><p>location 的多数信息都可以通过上面的属性获取。但是 URL 中的查询字符串并不容易使用。虽然location.search 返回了从问号开始直到 URL 末尾的所有内容，但没有办法逐个访问每个查询参数。下面的函数解析了查询字符串，并返回一个以每个查询参数为属性的对象：</p><pre><code>let getQueryStringArgs = function() {    // 取得没有开头问号的查询字符串    let qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""),    // 保存数据的对象    args = {};    // 把每个参数添加到 args 对象    for (let item of qs.split("&amp;").map(kv =&gt; kv.split("="))) {        let name = decodeURIComponent(item[0]),        value = decodeURIComponent(item[1]);        if (name.length) {            args[name] = value;        }    }     return args;} </code></pre><p>这个函数首先删除了查询字符串开头的问号，当然前提是 location.search 必须有内容。解析后的参数将被保存到 args 对象，这个对象以字面量形式创建。接着，先把查询字符串按照&amp;分割成数组，每个元素的形式为 name=value。for 循环迭代这个数组，将每一个元素按照=分割成数组，这个数组第一项是参数名，第二项是参数值。参数名和参数值在使用 decodeURIComponent()解码后（这是因为查询字符串通常是被编码后的格式）分别保存在 name 和 value 变量中。最后，name 作为属性而 value作为该属性的值被添加到 args 对象。这个函数可以像下面这样使用：</p><pre><code>// 假设查询字符串为?q=javascript&amp;num=10let args = getQueryStringArgs();alert(args["q"]); // "javascript"alert(args["num"]); // "10"</code></pre><p>现在，查询字符串中的每个参数都是返回对象的一个属性，这样使用起来就方便了。</p><p>URLSearchParams 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串。给URLSearchParams 构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了 get()、set()和 delete()等方法，可以对查询字符串执行相应操作。下面来看一个例子：</p><pre><code>let qs = "?q=javascript&amp;num=10";let searchParams = new URLSearchParams(qs);alert(searchParams.toString()); // " q=javascript&amp;num=10"searchParams.has("num"); // truesearchParams.get("num"); // 10searchParams.set("page", "3");alert(searchParams.toString()); // " q=javascript&amp;num=10&amp;page=3"searchParams.delete("q");alert(searchParams.toString()); // " num=10&amp;page=3" </code></pre><p>大多数支持 URLSearchParams 的浏览器也支持将 URLSearchParams 的实例用作可迭代对象：</p><pre><code>let qs = "?q=javascript&amp;num=10";let searchParams = new URLSearchParams(qs);for (let param of searchParams) {console.log(param);}// ["q", "javascript"]// ["num", "10"] </code></pre><h2 id="操作地址"><a href="#操作地址" class="headerlink" title="操作地址"></a>操作地址</h2><p>可以通过修改 location 对象修改浏览器的地址。首先，最常见的是使用 assign()方法并传入一个 URL，如下所示：</p><p><code>location.assign("http://www.wrox.com"); </code></p><p>这行代码会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录。如果给location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign()方法。比如，下面两行代码都会执行与显式调用 assign()一样的操作：</p><pre><code>window.location = "http://www.wrox.com";location.href = "http://www.wrox.com";</code></pre><p>在这 3 种修改浏览器地址的方法中，设置 location.href 是最常见的。</p><p>修改 location 对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和 port 属性被设置为新值之后都会修改当前 URL，如下面的例子所示：</p><pre><code>// 假设当前 URL 为 http://www.wrox.com/WileyCDA/// 把 URL 修改为 http://www.wrox.com/WileyCDA/#section1location.hash = "#section1";// 把 URL 修改为 http://www.wrox.com/WileyCDA/?q=javascriptlocation.search = "?q=javascript";// 把 URL 修改为 http://www.somewhere.com/WileyCDA/location.hostname = "www.somewhere.com";// 把 URL 修改为 http://www.somewhere.com/mydir/location.pathname = "mydir";// 把 URL 修改为 http://www.somewhere.com:8080/WileyCDA/location.port = 8080; </code></pre><p>除了 hash 之外，只要修改 location 的一个属性，就会导致页面重新加载新 URL。</p><p>在以前面提到的方式修改 URL 之后，浏览器历史记录中就会增加相应的记录。当用户单击“后退”按钮时，就会导航到前一个页面。如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace()之后，用户不能回到前一页。比如下面的例子：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;You won't be able to get back here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Enjoy this page for a second, because you won't be coming back here.&lt;/p&gt;&lt;script&gt;setTimeout(() =&gt; location.replace("http://www.wrox.com/"), 1000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; </code></pre><p>浏览器加载这个页面 1 秒之后会重定向到 <a href="http://www.wrox.com.此时,“后退”按钮是禁用状态,即不能返回这个示例页面,除非手动输入完整的/">www.wrox.com。此时，“后退”按钮是禁用状态，即不能返回这个示例页面，除非手动输入完整的</a> URL。</p><p>最后一个修改地址的方法是 reload()，它能重新加载当前显示的页面。调用 reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true：</p><pre><code>location.reload(); // 重新加载，可能是从缓存加载location.reload(true); // 重新加载，从服务器加载</code></pre><p>脚本中位于 reload()调用之后的代码可能执行也可能不执行，这取决于网络延迟和系统资源等因素。为此，最好把 reload()作为最后一行代码。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(十二)</title>
      <link href="posts/a0036.html"/>
      <url>posts/a0036.html</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>上篇： <strong><a href="a0035">函数(十六) 私有变量</a></strong><br>本篇： <strong>BOM(一)：window对象</strong><br>下篇： <strong><a href="a0037">BOM(二)：location对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h1><p>BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。这意味着网页中定义的所有对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法。</p><h2 id="Global-作用域"><a href="#Global-作用域" class="headerlink" title="Global 作用域"></a>Global 作用域</h2><p>因为 window 对象被复用为 ECMAScript 的 Global 对象，所以通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法。比如：</p><pre><code>var age = 29;var sayAge = () =&gt; alert(this.age);alert(window.age); // 29 sayAge(); // 29window.sayAge(); // 29 </code></pre><p>这里，变量 age 和函数 sayAge()被定义在全局作用域中，它们自动成为了 window 对象的成员。因此，变量 age 可以通过 window.age 来访问，而函数 sayAge()也可以通过 window.sayAge()来访问。因为 sayAge()存在于全局作用域，this.age 映射到 window.age，所以就可以显示正确的结果了。</p><p>如果在这里使用 let 或 const 替代 var，则不会把变量添加给全局对象：</p><pre><code>let age = 29;const sayAge = () =&gt; alert(this.age);alert(window.age); // undefinedsayAge(); // undefinedwindow.sayAge(); // TypeError: window.sayAge is not a function</code></pre><p>另外，访问未声明的变量会抛出错误，但是可以在 window 对象上查询是否存在可能未声明的变量。比如：</p><pre><code>// 这会导致抛出错误，因为 oldValue 没有声明var newValue = oldValue;// 这不会抛出错误，因为这里是属性查询// newValue 会被设置为 undefinedvar newValue = window.oldValue;</code></pre><p>记住，JavaScript 中有很多对象都暴露在全局作用域中，比如 location 和 navigator（本章后面都会讨论），因而它们也是 window 对象的属性。</p><h2 id="窗口关系"><a href="#窗口关系" class="headerlink" title="窗口关系"></a>窗口关系</h2><p>top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top（都等于 window）。最上层的 window如果不是通过 window.open()打开的，那么其 name 属性就不会包含值，本章后面会讨论。</p><p>还有一个 self 对象，它是终极 window 属性，始终会指向 window。实际上，self 和 window 就是同一个对象。之所以还要暴露 self，就是为了和 top、parent 保持一致。</p><p>这些属性都是 window 对象的属性，因此访问 window.parent、window.top 和 window.self都可以。这意味着可以把访问多个窗口的 window 对象串联起来，比如 window.parent.parent。</p><h2 id="窗口位置与像素比"><a href="#窗口位置与像素比" class="headerlink" title="窗口位置与像素比"></a>窗口位置与像素比</h2><p>window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 screenLeft 和screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素。</p><p>可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接收要移动到的新位置的绝对坐标 x 和 y；而 moveBy()则接收相对当前位置在两个方向上移动的像素数。比如：</p><pre><code>// 把窗口移动到左上角window.moveTo(0,0);// 把窗口向下移动 100 像素window.moveBy(0, 100); // 把窗口移动到坐标位置(200, 300)window.moveTo(200, 300);// 把窗口向左移动 50 像素window.moveBy(-50, 0); </code></pre><p>依浏览器而定，以上方法可能会被部分或全部禁用。</p><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>在不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持 4 个属性：innerWidth、innerHeight、outerWidth 和 outerHeight。outerWidth 和 outerHeight 返回浏览器窗口自身的大小（不管是在最外层 window 上使用，还是在窗格中使用）。</p><p>innerWidth和 innerHeight 返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。document.documentElement.clientWidth 和 document.documentElement.clientHeight返回页面视口的宽度和高度。</p><p>浏览器窗口自身的精确尺寸不好确定，但可以确定页面视口的大小，如下所示：</p><pre><code>let pageWidth = window.innerWidth,pageHeight = window.innerHeight;if (typeof pageWidth != "number") {    if (document.compatMode == "CSS1Compat"){        pageWidth = document.documentElement.clientWidth;        pageHeight = document.documentElement.clientHeight;    } else {        pageWidth = document.body.clientWidth;        pageHeight = document.body.clientHeight;    }} </code></pre><p>这里，先将 pageWidth 和 pageHeight 的值分别设置为 window.innerWidth 和 window.innerHeight。然后，检查 pageWidth 是不是一个数值，如果不是则通过 document.compatMode来检查页面是否处于标准模式。如果是，则使用 document.documentElement.clientWidth 和document.documentElement.clientHeight；否则，就使用 document.body.clientWidth 和document.body.clientHeight。</p><p>在移动设备上，window.innerWidth 和 window.innerHeight 返回视口的大小，也就是屏幕上页面可视区域的大小。Mobile Internet Explorer 支持这些属性，但在 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中提供了相同的信息。在放大或缩小页面时，这些值也会相应变化。</p><p>在其他移动浏览器中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回的布局视口的大小，即渲染页面的实际大小。布局视口是相对于可见视口的概念，可见视口只能显示整个页面的一小部分。Mobile Internet Explorer 把布局视口的信息保存在document.body.clientWidth 和 document.body.clientHeight 中。在放大或缩小页面时，这些值也会相应变化。</p><p>因为桌面浏览器的差异，所以需要先确定用户是不是在使用移动设备，然后再决定使用哪个属性。</p><p>可以使用resizeTo()和resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo()接收新的宽度和高度值，而 resizeBy()接收宽度和高度各要缩放多少。下面看个例子：</p><pre><code>// 缩放到 100×100window.resizeTo(100, 100);// 缩放到 200×150window.resizeBy(100, 50);// 缩放到 300×300window.resizeTo(300, 300); </code></pre><p>与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的 window 对象。</p><h2 id="视口位置"><a href="#视口位置" class="headerlink" title="视口位置"></a>视口位置</h2><p>浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文<br>档。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX 和 window.pageYoffset/window.scrollY。</p><p>可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对视口距离的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p><p>// 相对于当前视口向下滚动 100 像素<br>window.scrollBy(0, 100);<br>// 相对于当前视口向右滚动 40 像素<br>window.scrollBy(40, 0);<br>// 滚动到页面左上角<br>window.scrollTo(0, 0);<br>// 滚动到距离屏幕左边及顶边各 100 像素的位置<br>window.scrollTo(100, 100); </p><p>这几个方法也都接收一个 ScrollToOptions 字典，除了提供偏移值，还可以通过 behavior 属性告诉浏览器是否平滑滚动。</p><pre><code>// 正常滚动window.scrollTo({    left: 100,    top: 100,    behavior: 'auto'});// 平滑滚动window.scrollTo({    left: 100,    top: 100,    behavior: 'smooth'}); </code></pre><h2 id="导航与打开新窗口"><a href="#导航与打开新窗口" class="headerlink" title="导航与打开新窗口"></a>导航与打开新窗口</h2><p>window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。这个方法接收 4个参数：要加载的 URL、目标窗口、特性字符串和表示新窗口在浏览器历史记录中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 3 个参数，最后一个参数只有在不打开新窗口时才会使用。</p><p>如果 window.open()的第二个参数是一个已经存在的窗口或窗格（frame）的名字，则会在对应的窗口或窗格中打开 URL。下面是一个例子：</p><pre><code>// 与&lt;a href="http://www.wrox.com" target="topFrame"/&gt;相同window.open("http://www.wrox.com/", "topFrame"); </code></pre><p>执行这行代码的结果就如同用户点击了一个 href 属性为”<a href="http://www.wrox.com&quot;,target/">http://www.wrox.com"，target</a> 属性为”topFrame”的链接。如果有一个窗口名叫”topFrame”，则这个窗口就会打开这个 URL；否则就会打开一个新窗口并将其命名为”topFrame”。第二个参数也可以是一个特殊的窗口名，比如_self、_parent、_top 或_blank。</p><h3 id="弹出窗口"><a href="#弹出窗口" class="headerlink" title="弹出窗口"></a>弹出窗口</h3><p>如果 window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口（或标签页）会带有所有默认的浏览器特性（工具栏、地址栏、状态栏等都是默认配置）。如果打开的不是新窗口，则忽略第三个参数。</p><p>特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项。</p><table><thead><tr><th align="left">设 置</th><th align="left">值</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">fullscreen</td><td align="left">“yes”或”no”</td><td align="left">表示新窗口是否最大化。仅限 IE 支持</td></tr><tr><td align="left">height</td><td align="left">数值</td><td align="left">新窗口高度。这个值不能小于 100</td></tr><tr><td align="left">left</td><td align="left">数值</td><td align="left">新窗口的 x 轴坐标。这个值不能是负值</td></tr><tr><td align="left">location</td><td align="left">“yes”或”no”</td><td align="left">表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为”no”时，地址栏可能隐藏或禁用（取决于浏览器）</td></tr><tr><td align="left">Menubar</td><td align="left">“yes”或”no”</td><td align="left">表示是否显示菜单栏。默认为”no”</td></tr><tr><td align="left">resizable</td><td align="left">“yes”或”no”</td><td align="left">表示是否可以拖动改变新窗口大小。默认为”no”</td></tr><tr><td align="left">scrollbars</td><td align="left">“yes”或”no”</td><td align="left">表示是否可以在内容过长时滚动。默认为”no”</td></tr><tr><td align="left">status</td><td align="left">“yes”或”no”</td><td align="left">表示是否显示状态栏。不同浏览器的默认值也不一样</td></tr><tr><td align="left">toolbar</td><td align="left">“yes”或”no”</td><td align="left">表示是否显示工具栏。默认为”no”</td></tr><tr><td align="left">top</td><td align="left">数值</td><td align="left">新窗口的 y 轴坐标。这个值不能是负值</td></tr><tr><td align="left">width</td><td align="left">数值</td><td align="left">新窗口的宽度。这个值不能小于 100</td></tr></tbody></table><p>这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接。（特性字符串中不能包含空格。）来看下面的例子：</p><pre><code>window.open("http://www.wrox.com/","wroxWindow","height=400,width=400,top=10,left=10,resizable=yes"); </code></pre><p>这行代码会打开一个可缩放的新窗口，大小为 400 像素×400 像素，位于离屏幕左边及顶边各 10 像素的位置。</p><p>window.open()方法返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别，只是为控制新窗口提供了方便。例如，某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过window.open()创建的窗口。跟使用任何 window 对象一样，可以使用这个对象操纵新打开的窗口。</p><pre><code>let wroxWin = window.open("http://www.wrox.com/","wroxWindow","height=400,width=400,top=10,left=10,resizable=yes");// 缩放wroxWin.resizeTo(500, 500);// 移动wroxWin.moveTo(100, 100); </code></pre><p>还可以使用 close()方法像这样关闭新打开的窗口：<code>wroxWin.close();</code></p><p>这个方法只能用于 window.open()创建的弹出窗口。虽然不可能不经用户确认就关闭主窗口，但弹出窗口可以调用 top.close()来关闭自己。关闭窗口以后，窗口的引用虽然还在，但只能用于检查其 closed 属性了：</p><pre><code>wroxWin.close();alert(wroxWin.closed); // true </code></pre><p>新创建窗口的 window 对象有一个属性 opener，指向打开它的窗口。这个属性只在弹出窗口的最上层 window 对象（top）有定义，是指向调用 window.open()打开它的窗口或窗格的指针。例如：</p><pre><code>let wroxWin = window.open("http://www.wrox.com/","wroxWindow","height=400,width=400,top=10,left=10,resizable=yes");alert(wroxWin.opener === window); // true </code></pre><p>虽然新建窗口中有指向打开它的窗口的指针，但反之则不然。窗口不会跟踪记录自己打开的新窗口，因此开发者需要自己记录。</p><p>在某些浏览器中，每个标签页会运行在独立的进程中。如果一个标签页打开了另一个，而 window对象需要跟另一个标签页通信，那么标签便不能运行在独立的进程中。在这些浏览器中，可以将新打开的标签页的 opener 属性设置为 null，表示新打开的标签页可以运行在独立的进程中。比如：</p><pre><code>let wroxWin = window.open("http://www.wrox.com/","wroxWindow","height=400,width=400,top=10,left=10,resizable=yes");wroxWin.opener = null; </code></pre><p>把 opener 设置为 null 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。这个连接一旦切断，就无法恢复了。</p><h3 id="弹窗屏蔽程序"><a href="#弹窗屏蔽程序" class="headerlink" title="弹窗屏蔽程序"></a>弹窗屏蔽程序</h3><p>所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么 window.open()很可能会返回 null。此时，只要检查这个方法的返回值就可以知道弹窗是否被屏蔽了，比如：</p><pre><code>let wroxWin = window.open("http://www.wrox.com", "_blank");if (wroxWin == null){    alert("The popup was blocked!");}</code></pre><p>在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误。因此要准确检测弹窗是否被屏蔽，除了检测 window.open()的返回值，还要把它用 try/catch 包装起来，像这样：</p><pre><code>let blocked = false;try {    let wroxWin = window.open("http://www.wrox.com", "_blank");    if (wroxWin == null){         blocked = true;    }} catch (ex){    blocked = true;}if (blocked){    alert("The popup was blocked!");}</code></pre><p>无论弹窗是用什么方法屏蔽的，以上代码都可以准确判断调用 window.open()的弹窗是否被屏蔽了。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>JavaScript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而 setInterval()用于指定每隔一段时间执行某些代码。</p><p>setTimeout()方法通常接收两个参数：要执行的代码和在执行回调函数前等待的时间（毫秒）。第一个参数可以是包含 JavaScript 代码的字符串（类似于传给 eval()的字符串）或者一个函数，比如：</p><pre><code>// 在 1 秒后显示警告框setTimeout(() =&gt; alert("Hello world!"), 1000); </code></pre><p>第二个参数是要等待的毫秒数，而不是要执行代码的确切时间。JavaScript 是单线程的，所以每次只能执行一段代码。为了调度不同代码的执行，JavaScript 维护了一个任务队列。其中的任务会按照添加到队列的先后顺序执行。setTimeout()的第二个参数只是告诉 JavaScript 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完才能执行。</p><p>调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID，如下面的例子所示：</p><p>调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID，如下面的例子所示：</p><pre><code>// 设置超时任务let timeoutId = setTimeout(() =&gt; alert("Hello world!"), 1000);// 取消超时任务clearTimeout(timeoutId);</code></pre><p>只要是在指定时间到达之前调用 clearTimeout()，就可以取消超时任务。在任务执行后再调用clearTimeout()没有效果。</p><p>setInterval()与 setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。setInterval()同样可以接收两个参数：要执行的代码（字符串或函数），以及把下一次执行定时代码的任务添加到队列要等待的时间（毫秒）。下面是一个例子：</p><p><code>setInterval(() =&gt; alert("Hello world!"), 10000); </code></p><p>setInterval()方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时。要取消循环定时，可以调用 clearInterval()并传入定时 ID。相对于 setTimeout()而言，取消定时的能力对 setInterval()更加重要。毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。下面是一个常见的例子：</p><pre><code>let num = 0, intervalId = null;let max = 10;let incrementNumber = function() {    num++;    // 如果达到最大值，则取消所有未执行的任务    if (num == max) {    clearInterval(intervalId);        alert("Done");    }}intervalId = setInterval(incrementNumber, 500); </code></pre><p>在这个例子中，变量 num 会每半秒递增一次，直至达到最大限制值。此时循环定时会被取消。这个模式也可以使用 setTimeout()来实现，比如：</p><pre><code>let num = 0;let max = 10;let incrementNumber = function() {    num++;    // 如果还没有达到最大值，再设置一个超时任务    if (num &lt; max) {        setTimeout(incrementNumber, 500);    } else {        alert("Done");    }}setTimeout(incrementNumber, 500); </code></pre><p>注意在使用 setTimeout()时，不一定要记录超时 ID，因为它会在条件满足时自动停止，否则会自动设置另一个超时任务。这个模式是设置循环任务的推荐做法。setIntervale()在实践中很少会在生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的，有些循环定时任务可能会因此而被跳过。而像前面这个例子中一样使用 setTimeout()则能确保不会出现这种情况。一般来说，最好不要使用 setInterval()。</p><h2 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h2><p>使用 alert()、confirm()和 prompt()方法，可以让浏览器调用系统对话框向用户显示消息。这些对话框与浏览器中显示的网页无关，而且也不包含 HTML。它们的外观由操作系统或者浏览器决定，无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，即在它们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。</p><p>alert()方法在本书示例中经常用到。它接收一个要显示给用户的字符串。与 console.log 可以接收任意数量的参数且能一次性打印这些参数不同，alert()只接收一个参数。调用 alert()时，传入的字符串会显示在一个系统对话框中。对话框只有一个“OK”（确定）按钮。如果传给 alert()的参数不是一个原始字符串，则会调用这个值的 toString()方法将其转换为字符串。</p><p>警告框（alert）通常用于向用户显示一些他们无法控制的消息，比如报错。用户唯一的选择就是在看到警告框之后把它关闭。</p><p>第二种对话框叫确认框，通过调用 confirm()来显示。确认框跟警告框类似，都会向用户显示消息。但不同之处在于，确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。用户通过单击不同的按钮表明希望接下来执行什么操作。比如，confirm(“Are you sure?”)</p><p>要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击了 OK 按钮，false 表示单击了 Cancel 按钮或者通过单击某一角上的 X 图标关闭了确认框。确认框的典型用法如下所示：</p><pre><code>if (confirm("Are you sure?")) {    alert("I'm so glad you're sure!");} else {    alert("I'm sorry to hear you're not sure.");}</code></pre><p>在这个例子中，第一行代码向用户显示了确认框，也就是 if 语句的条件。如果用户单击了 OK 按钮，则会弹出警告框显示”I’m so glad you’re sure!”。如果单击了 Cancel，则会显示”I’m sorry tohear you’re not sure.”。确认框通常用于让用户确认执行某个操作，比如删除邮件等。因为这种对话框会完全打断正在浏览网页的用户，所以应该在必要时再使用。 </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+CSS3权威指南</title>
      <link href="posts/d0004.html"/>
      <url>posts/d0004.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-CSS3权威指南"><a href="#HTML5-CSS3权威指南" class="headerlink" title="HTML5+CSS3权威指南"></a>HTML5+CSS3权威指南</h1><p>上篇: <strong><a href="d0003">HTML5的结构</a></strong><br>本篇: <strong>表单与文件</strong><br>下篇: <strong><a href="d0005"></a></strong></p><p><strong><a href="categories/HTML/HTML5-CSS3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">HTML5+CSS3权威指南</a></strong> 全部合集</p><hr><h1 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h1><h2 id="新增元素与属性"><a href="#新增元素与属性" class="headerlink" title="新增元素与属性"></a>新增元素与属性</h2><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h2 id="增强页面元素"><a href="#增强页面元素" class="headerlink" title="增强页面元素"></a>增强页面元素</h2><h2 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h2><h2 id="拖放API"><a href="#拖放API" class="headerlink" title="拖放API"></a>拖放API</h2>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> HTML5+CSS3权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水涨船高技术栈</title>
      <link href="posts/f0003.html"/>
      <url>posts/f0003.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 水涨船高技术集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水涨船高技术集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5+CSS3权威指南</title>
      <link href="posts/d0003.html"/>
      <url>posts/d0003.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-CSS3权威指南"><a href="#HTML5-CSS3权威指南" class="headerlink" title="HTML5+CSS3权威指南"></a>HTML5+CSS3权威指南</h1><p>上篇: <strong><a href="d0002">HTML基础</a></strong><br>本篇: <strong>HTML5的结构</strong><br>下篇: <strong><a href="d0004">表单与文件</a></strong></p><p><strong><a href="categories/HTML/HTML5-CSS3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">HTML5+CSS3权威指南</a></strong> 全部合集</p><hr><h1 id="HTML5的结构"><a href="#HTML5的结构" class="headerlink" title="HTML5的结构"></a>HTML5的结构</h1><h2 id="新增的主体结构元素"><a href="#新增的主体结构元素" class="headerlink" title="新增的主体结构元素"></a>新增的主体结构元素</h2><h3 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h3><p><code>article</code> 元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个 <code>article</code> 元素通常有它自己的标题（一般放在一个<code> header</code> 元素里面） , 有时还有自己的脚注。现在，让我们以博客为例来看一段关于 <code>article</code> 元素的代码示例</p><pre><code>&lt;article&gt;    &lt;header&gt;        &lt;h1&gt;苹果&lt;/h1&gt;        &lt;p&gt;发表日期:2020/11/26&lt;/p&gt;    &lt;/header&gt;    &lt;p&gt;苹果，我爱吃&lt;/p&gt;    &lt;footer&gt;        &lt;small&gt;著作归我所有&lt;/small&gt;    &lt;/footer&gt;&lt;/article&gt;</code></pre><p>这个示例是一篇讲述苹果的博客文章，在 <code>header</code> 元素中嵌入了文章的标题部分，在这部分中，文章的标题“苹果”被镶嵌在 <code>hl</code> 元素中，文章的发表日期镶嵌在 <code>p</code> 元素中。在标题下部的 <code>p</code> 元素中，嵌入了一大段该博客文章的正文，在结尾处的 <code>footer</code> 元素中，嵌入了文章的著作权，作为脚注。整个示例的内容相对比较独立、完整，因此，对这部分内容使用了 <code>article</code> 元素。</p><p> <code>article</code> 元素是可以嵌套用的，内层的内容在原则上需要与外层的内容相关联．例如，一篇博客文章中，针对该文章的评论就可以使用嵌套 <code>article</code> 元素的方式．用来呈现评论的 <code>article</code> 元素被包含在表示整体内容的 <code>article</code> 元素里面。</p><pre><code>&lt;article&gt;    &lt;header&gt;        &lt;h1&gt;苹果&lt;/h1&gt;        &lt;p&gt;发表日期:2020/11/26&lt;/p&gt;    &lt;/header&gt;    &lt;p&gt;苹果，我爱吃&lt;/p&gt;    &lt;footer&gt;        &lt;small&gt;著作归我所有&lt;/small&gt;    &lt;/footer&gt;    &lt;section&gt;        &lt;h2&gt;评论&lt;/h2&gt;        &lt;article&gt;            &lt;header&gt;                &lt;h3&gt;发表者:QA&lt;/h3&gt;            &lt;/header&gt;            &lt;p&gt;我喜欢苹果&lt;/p&gt;        &lt;/article&gt;    &lt;/section&gt;&lt;/article&gt;</code></pre><h3 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h3><p><code>section</code> 元素用于对网站或应用程序中页面上的内容进行分块，一个<code> sectinn</code> 元素通常由内容及其标题组成。但 <code>section</code> 元素并非一个普通的容器元素．当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用 <code>div</code> 而非 <code>section</code> 元素。我们可以这样理解： <code>section</code> 元素中的内容可以单独存储到数据库中或输出到 W6rd 文档中。</p><p><code>section</code>元素的作用是对页面上的内容进行分块，或者说对文章进行分段，不要与”有独立自己的完整的内容”的article元素混淆。下面，我们来看 <code>article</code> 元素与 <code>section</code> 元素结合使用的两个示例，希望能够帮助你更好地理解 <code>article</code> 元素与 <code>section</code> 元素的区别。首先来看一个带有 <code>section</code> 元素的 <code>artide</code> 元素示例</p><pre><code>&lt;article&gt;    &lt;header&gt;        &lt;h1&gt;苹果&lt;/h1&gt;        &lt;p&gt;发表日期:2020/11/26&lt;/p&gt;    &lt;/header&gt;    &lt;p&gt;苹果，我爱吃&lt;/p&gt;    &lt;section&gt;        &lt;h2&gt;富士康&lt;/h2&gt;        &lt;p&gt;富士康的红苹果好好吃&lt;/p&gt;    &lt;/section&gt;    &lt;section&gt;        &lt;h2&gt;国光&lt;/h2&gt;        &lt;p&gt;又叫小国光，原产美国，不好吃&lt;/p&gt;    &lt;/section&gt;    &lt;footer&gt;        &lt;small&gt;著作归我所有&lt;/small&gt;    &lt;/footer&gt;&lt;/article&gt;</code></pre><p>上面内容首先是一段独立的、完整的内容，因此使用<code> article</code> 元素。该内容是一篇关于苹果的文章，该文章分为 3 段，每一段都有一个独立的标题，因此使用了两个 <code>section</code> 元素。请记住，对<strong>文章分段的工作</strong>也是使用 <code>section</code> 元素完成的。可能有人会问，为什么没有对第一段使用 <code>section</code> 元素，这里其实是可以使用 <code>section</code> 元素的，但是由于其结构比较清晰，分析器可以识别第一段内容在一个<code> section</code> 元素里，所以也可以将第一个 section 元素略，但是如果第一个 <code>scction</code> 元素里还要包含子 <code>section</code> 元素或子<code> article</code> 元素，那么就必须写明第一个 <code>section</code> 元素了。接着，我们来看一个包含叭 <code>article</code> 元素的 <code>section</code> 元素示例</p><pre><code>&lt;section&gt;    &lt;h1&gt;水果&lt;/h1&gt;    &lt;article&gt;        &lt;h2&gt;苹果&lt;/h2&gt;        &lt;p&gt;我爱吃苹果&lt;/p&gt;    &lt;/article&gt;    &lt;article&gt;        &lt;h2&gt;橘子&lt;/h2&gt;        &lt;p&gt;我爱吃橘子&lt;/p&gt;    &lt;/article&gt;&lt;/section&gt;</code></pre><p>这个示例首先是一篇文章中的一段，一次最初没有使用<code>article</code>元素。但是在这段中有几块独立的内容，因此嵌入了几个独立的<code>article</code>元素。这俩个元素能相互使用吗?实际上，在HTML5中，<code>article</code>元素可以看成是一种特殊种类的<code>section</code>元素，它比<code>section</code>元素更强调独立性。即<code>section</code>元素强调分段或分块，<code>article</code>强调独立性。具体来说，如果一块内容相对来说比较独立、完整的时候用<code>article</code>，但是如果你想将一块内容分成几段的时候用<code>section</code>。</p><p>另外，HTML5中div变成了一种容器，当使用CSS样式1的时候，可以对这个容器进行一个总体的CSS样式调用。</p><p>可以将所有页面的从属部分，譬如导航条、菜单、版权说明等包含在一个统一的页面中，方便使用CSS样式来进行调整。</p><p><strong>注意</strong></p><ol><li>不要将<code>section</code>元素用作1设置样式的页面容器，那是<code>div</code>元素的工作</li><li>如果<code>article</code>、<code>aside</code>、<code>nav</code>更适合，不要使用<code>section</code></li><li>不要为没有标题的内容区块使用<code>section</code>元素</li></ol><h3 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a>nav元素</h3><p><code>nav</code>元素是一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。</p><pre><code>&lt;nav&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href="/"&gt;主页&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="/"&gt;标签&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="/"&gt;分类&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/nav&gt;&lt;article&gt;    &lt;header&gt;&lt;/header&gt;    &lt;p&gt;&lt;/p&gt;    &lt;footer&gt;&lt;/footer&gt;&lt;/article&gt;</code></pre><p>具体来说，<code>nav</code>元素可以用于以下这些场合： </p><ol><li><p>传统导航条。现在主流网站上都有不同层级的导航条，其作用是将当前画面跳转到网站的其他主要页面上去。 </p></li><li><p>侧边栏导航。现在主流博客网站及商品网站上都有侧边栏导航，其作用是将页面从当前文章或当前商品跳转到其他文章或其他商品页面上去。 </p></li><li><p>页内导航。页内导航的作用是在本页面儿个主要的组成部分之间进行跳转。 </p></li><li><p>翻页操作。翻页操作是指在多个页面的前后页或博客网站的前后篇文章滚动。 </p></li><li><p>除此之外，<code>nav</code>元素也可以用于其他所有你觉得是重要的、基本的导航链接组中。 </p></li></ol><h3 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a>aside元素</h3><p><code>aside</code>元素用来表示当前页面或文章的附属信息部分，它可以包含当前页面或主要内容相关的引用、侧边栏、广告、导航栏，以及其他类似的有别于主要内容的部分。</p><p>有种使用方法：</p><ol><li><p>被包含在article元素中作为主要内容的附属信息部分，其中的内容可能是与当前文章有关的参考资料、名词解释等等。</p></li><li><p>在article元素之外使用，作为页面或站点全局的附属信息部分。最典型的是侧边栏，如友情链接，博客中其他文章列表、广告单元等。</p></li></ol><h2 id="新增的非主体结构元素"><a href="#新增的非主体结构元素" class="headerlink" title="新增的非主体结构元素"></a>新增的非主体结构元素</h2><h3 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h3><p><code>header</code>元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含其他内容，例如数据列表、搜索表单或相关的logo图片。</p><p>一个网页并未限制<code>header</code>元素的个数，可以拥有多个，可以为每个内容区块加一个<code>header</code>元素。<br>一个<code>haeder</code>元素包括至少一个(h1~h6)元素，也可以包括<code>table</code>元素、<code>form</code>元素、<code>nav</code>元素。</p><h3 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h3><p><code>footer</code>元素可以作为其上层父级内容内容区块或是一个根区块的脚注。<code>footer</code>通常包括其相关区块的脚注信息，如作者、相关阅读链接及版本信息等。与<code>header</code>元素一样，一个页面中也未限制<code>footer</code>元素的个数。</p><h3 id="address元素"><a href="#address元素" class="headerlink" title="address元素"></a>address元素</h3><p><code>address</code>元素用来在文档中呈现联系信息，包括文档作者或者文档维护者的信息、他们的网站链接、电子邮箱、真实地址、电话号码等。</p><h2 id="HTML5结构"><a href="#HTML5结构" class="headerlink" title="HTML5结构"></a>HTML5结构</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>通过使用HTML5的文档结构比大量使用HTML4的文档结构清晰、明确了很多。</p><p>所谓大纲简单说就是文档中各个内容区块的结构编排。内容块的编排可以分为“显示编排”和“隐式编排”俩种方式。</p><p>显示编排是指明确使用section等元素创建文档结构。<br>隐式编排就是不明确使用section等元素，而是根据页面中所书写的各级标题(h1~h6)等自动创建</p><pre><code>&lt;body&gt;    &lt;header&gt;        &lt;!--网站导航链接--&gt;        &lt;nav&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href="##"&gt;首页&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href="##"&gt;帮助&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/nav&gt;    &lt;/header&gt;    &lt;!--文章正文--&gt;&gt;    &lt;article&gt;        &lt;header&gt;            &lt;h1&gt;HHH&lt;/h1&gt;            &lt;h2&gt;hhh&lt;/h2&gt;        &lt;/header&gt;        &lt;p&gt;为什么为什么&lt;/p&gt;        &lt;section class="comments"&gt;            &lt;article&gt;                &lt;h1&gt;评论&lt;/h1&gt;                &lt;p&gt;很好啊&lt;/p&gt;            &lt;/article&gt;        &lt;/section&gt;    &lt;/article&gt;    &lt;!--版权信息--&gt;&gt;    &lt;footer&gt;        &lt;small&gt;版权所有归我&lt;/small&gt;    &lt;/footer&gt;&lt;/body&gt;</code></pre><h3 id="对新的结构元素使用样式"><a href="#对新的结构元素使用样式" class="headerlink" title="对新的结构元素使用样式"></a>对新的结构元素使用样式</h3><p>因为很多浏览器尚未对HTML5中新增的结构元素提供支持，多以需要使用CSS追加如下声明，目的是通知浏览器页面中使用的新元素都是以块方式显示的。</p><p><code>artical、aside、footer、header、nav、section {display: block;}</code></p><p>另外，IE8及之前浏览器是不支持用CSS的方法来使用这些尚未支持的结构元素的，需要使用JS脚本如下：</p><pre><code>&lt;script&gt;    document.createElement("header");    document.createElement("footer");    document.createElement("nav");    document.createElement("article");&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> HTML5+CSS3权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础</title>
      <link href="posts/d0002.html"/>
      <url>posts/d0002.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-CSS3权威指南"><a href="#HTML5-CSS3权威指南" class="headerlink" title="HTML5+CSS3权威指南"></a>HTML5+CSS3权威指南</h1><p>本篇: <strong>HTML基础</strong><br>下篇: <strong><a href="d0003">HTML5的结构</a></strong></p><p><strong><a href="categories/HTML/HTML5-CSS3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">HTML5+CSS3权威指南</a></strong> 全部合集</p><hr><h1 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h1><h2 id="常用标签语法"><a href="#常用标签语法" class="headerlink" title="常用标签语法"></a>常用标签语法</h2><h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><p>以下代码标记了一个段落：<br><code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code></p><p><code>&lt;p&gt;</code> 标签定义段落。</p><p><code>&lt;p&gt;</code>元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。</p><p><code>&lt;p&gt;</code> 标签支持全局属性<br><code>&lt;p&gt;</code> 标签支持所有 HTML事件属性</p><h3 id="h1-h6"><a href="#h1-h6" class="headerlink" title="h1~h6"></a>h1~h6</h3><p>六个不同的 HTML 标题：</p><p><code>&lt;h1&gt;这是标题 1&lt;/h1&gt;</code><br><code>&lt;h2&gt;这是标题 2&lt;/h2&gt; </code><br><code>&lt;h3&gt;这是标题 3&lt;/h3&gt; </code><br><code>&lt;h4&gt;这是标题 4&lt;/h4&gt; </code><br><code>&lt;h5&gt;这是标题 5&lt;/h5&gt; </code><br><code>&lt;h6&gt;这是标题 6&lt;/h6&gt;</code></p><p><code>&lt;h1&gt; - &lt;h6&gt;</code> 标签被用来定义 HTML 标题。</p><p><code>&lt;h1&gt;</code> 定义重要等级最高的标题。<code>&lt;h6&gt;</code> 定义重要等级最低的标题。</p><p><code>&lt;h1&gt; - &lt;h6&gt;</code> 标签支持 HTML 的全局属性。<br><code>&lt;h1&gt; - &lt;h6&gt;</code> 标签支持 HTML 的事件属性。</p><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>使用 <code>&lt;span&gt;</code> 元素对文本中的一部分进行着色：<br><code>&lt;p&gt;我的母亲有 &lt;span style="color:blue"&gt;蓝色&lt;/span&gt; 的眼睛。&lt;/p&gt;</code></p><p><code>&lt;span&gt;</code> 用于对文档中的行内元素进行组合。</p><p><code>&lt;span&gt;</code> 标签没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。如果不对 <code>&lt;span&gt;</code> 应用样式，那么 <code>&lt;span&gt;</code> 元素中的文本与其他文本不会任何视觉上的差异。</p><p><code>&lt;span&gt;</code> 标签提供了一种将文本的一部分或者文档的一部分独立出来的方式。</p><p>被 <code>&lt;span&gt;</code> 元素包含的文本，您可以使用 CSS 对它定义样式，或者使用 JavaScript 对它进行操作。</p><p><code>&lt;span&gt;</code> 标签支持 HTML 的全局属性<br><code>&lt;span&gt;</code> 标签支持 HTML 的事件属性。</p><h3 id="img"><a href="#img" class="headerlink" title="img"></a>img</h3><p>如何插入图像：</p><p><code>&lt;img loading="lazy" src="smiley-2.gif" alt="Smiley face" width="42" height="42"&gt;</code></p><p><code>&lt;img&gt;</code> 标签定义 HTML 页面中的图像。</p><p><code>&lt;img&gt;</code> 标签有两个必需的属性：<code>src</code> 和 <code>alt</code>。</p><p>注释：从技术上讲，图像并不会插入 HTML 页面中，而是链接到 HTML 页面上。<code>&lt;img&gt;</code> 标签的作用是为被引用的图像创建占位符。</p><p><strong>提示</strong>：通过在 <code>&lt;a&gt;</code> 标签中嵌套 <code>&lt;img&gt;</code> 标签，给图像添加到另一个文档的链接。</p><h4 id="alt属性"><a href="#alt属性" class="headerlink" title="alt属性"></a>alt属性</h4><p><code>alt</code> 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p><p>假设由于一些原因（比如网速太慢、<code>src</code> 属性中的错误、浏览器禁用图像、用户使用的是屏幕阅读器）用户无法查看图像，<code>alt</code> 属性可以为图像提供替代的信息。</p><h4 id="src属性"><a href="#src属性" class="headerlink" title="src属性"></a>src属性</h4><p>图像的 URL。<br>可能的值：</p><p>绝对 URL - 指向另一个网站（比如 <code>src="http://www.example.com/image.gif"</code>）<br>相对 URL - 指向网站内的一个文件（比如 <code>src="image.gif"</code>）</p><h4 id="height属性"><a href="#height属性" class="headerlink" title="height属性"></a>height属性</h4><p>height 属性规定图像的高度，以像素计。</p><p>提示：为图像指定 <code>height</code> 和 <code>width</code> 属性是一个好习惯。如果设置了这些属性，就可以在页面加载时为图像预留空间。如果没有这些属性，浏览器就无法了解图像的尺寸，也就无法为图像保留合适的空间，因此当图像加载时，页面的布局就会发生变化。</p><p>提示：请不要通过 <code>height</code> 和 <code>width</code> 属性来缩放图像。如果通过 <code>height</code> 和 <code>width</code> 属性来缩小图像，那么用户就必须下载大容量的图像（即使图像在页面上看上去很小）。正确的做法是，在网页上使用图像之前，应该通过软件把图像处理为合适的尺寸。</p><h4 id="width"><a href="#width" class="headerlink" title="width"></a>width</h4><p><code>width</code> 属性规定图像的宽度，以像素计。</p><h3 id="a"><a href="#a" class="headerlink" title="a"></a>a</h3><p>链接到菜鸟教程 ：<br><code>&lt;a href=""&gt;访问xxx!&lt;/a&gt;</code></p><p><code>&lt;a&gt;</code> 标签定义超链接，用于从一个页面链接到另一个页面。</p><p><code>&lt;a&gt;</code> 元素最重要的属性是<code> href</code> 属性，它指定链接的目标。</p><p>在所有浏览器中，链接的默认外观如下：</p><ol><li>未被访问的链接带有下划线而且是蓝色的</li><li>已被访问的链接带有下划线而且是紫色的</li><li>活动链接带有下划线而且是红色的</li></ol><p>提示：如果没有使用 <code>href</code> 属性，则不能使用 hreflang、media、rel、target 以及 type 属性。</p><p>提示：通常在当前浏览器窗口中显示被链接页面，除非规定了其他 target。</p><p>提示：请使用 CSS 来改变链接的样式。</p><h4 id="download属性"><a href="#download属性" class="headerlink" title="download属性"></a>download属性</h4><p><code>download</code> 属性定义了下载链接的地址。</p><p>href 属性必须在 <code>&lt;a&gt;</code> 标签中指定。</p><p>属性同样可以指定下载文件的名称。文件名称没有限定值，浏览器会自动在文件名称末尾添加该下载文件的后缀 (.img, .pdf, .txt, .html, 等)。</p><p>语法<br><code>&lt;a download="filename"&gt;</code></p><h4 id="href属性"><a href="#href属性" class="headerlink" title="href属性"></a>href属性</h4><p><code>a</code> 标签的 <code>href</code> 属性用于指定超链接目标的 URL。</p><p>如果 <code>href</code> 属性没有被指定链接，<code>&lt;a&gt;</code> 标签将不是一个链接。</p><p>超链接的 URL。可能的值：</p><ol><li>绝对 URL - 指向另一个站点（比如 href=”<a href="http://www.example.com/index.htm&quot;%EF%BC%89">http://www.example.com/index.htm"）</a></li><li>相对 URL - 指向站点内的某个文件（href=”index.htm”）</li><li>锚 URL - 指向页面中的锚（href=”#top”）</li></ol><h4 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h4><p><code>&lt;a&gt;</code> 标签的 <code>target</code> 属性规定在何处打开链接文档。</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_blank</td><td align="left">在新窗口中打开被链接文档。</td></tr><tr><td align="left">_self</td><td align="left">默认。在相同的框架中打开被链接文档。</td></tr><tr><td align="left">_parent</td><td align="left">在父框架集中打开被链接文档。</td></tr><tr><td align="left">_top</td><td align="left">在整个窗口中打开被链接文档。</td></tr><tr><td align="left">framename</td><td align="left">在指定的框架中打开被链接文档。</td></tr></tbody></table><h3 id="div"><a href="#div" class="headerlink" title="div"></a>div</h3><p>文档中的一个区域将显示为蓝色：</p><pre><code>&lt;div style="color:#0000FF"&gt;&lt;h3&gt;这是一个在 div 元素中的标题。&lt;/h3&gt;&lt;p&gt;这是一个在 div 元素中的文本。&lt;/p&gt;&lt;/div&gt;</code></pre><p><code>&lt;div&gt;</code> 标签定义 HTML 文档中的一个分隔区块或者一个区域部分。</p><p><code>&lt;div&gt;</code>标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化。</p><p><strong>提示</strong>：<code>&lt;div&gt;</code> 元素经常与 CSS 一起使用，用来布局网页。</p><p><strong>注释</strong>：默认情况下，浏览器通常会在 <code>&lt;div&gt;</code> 元素前后放置一个换行符。然而，您可以通过使用 CSS 改变这种情况</p><h3 id="ul"><a href="#ul" class="headerlink" title="ul"></a>ul</h3><p>无序 HTML 列表：</p><pre><code>&lt;ul&gt;    &lt;li&gt;Coffee&lt;/li&gt;    &lt;li&gt;Tea&lt;/li&gt;    &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;</code></pre><p><code>&lt;ul&gt;</code> 标签定义无序列表。</p><p>将 <code>&lt;ul&gt;</code> 标签与 <code>&lt;li&gt;</code> 标签一起使用，创建无序列表。</p><p><strong>提示</strong>：使用<code>&lt;ol&gt;</code> 标签创建有序列表。</p><h3 id="li"><a href="#li" class="headerlink" title="li"></a>li</h3><p><code>&lt;li&gt;</code> 标签定义列表项目。</p><p><code>&lt;li&gt;</code> 标签可用在有序列表<code>&lt;ol&gt;</code>、无序列表<code>&lt;ul&gt;</code>和菜单列表<code>&lt;menu&gt;</code> 中。</p><h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><p>带有两个输入字段和一个提交按钮的 HTML 表单：</p><pre><code>&lt;form action="demo_form.php" method="get"&gt;First name: &lt;input type="text" name="fname"&gt;&lt;br&gt;Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt;&lt;input type="submit" value="提交"&gt;&lt;/form&gt;</code></pre><p><code>&lt;form&gt;</code> 标签用于创建供用户输入的 HTML 表单。</p><p><code>&lt;form&gt; </code>元素包含一个或多个如下的表单元素：</p><ol><li><code>&lt;input&gt;</code></li><li><code>&lt;textarea&gt;</code></li><li><code>&lt;button&gt;</code></li><li><code>&lt;select&gt;</code></li><li><code>&lt;option&gt;</code></li><li><code>&lt;optgroup&gt;</code></li><li><code>&lt;fieldset&gt;</code></li><li><code>&lt;label&gt;</code></li></ol><h4 id="action属性"><a href="#action属性" class="headerlink" title="action属性"></a>action属性</h4><p><code>action</code> 属性规定当提交表单时，向何处发送表单数据。</p><p>URL    当表单提交时向何处发送表单数据。<br>可能的值：<br>绝对 URL - 指向另一个网站（比如 <code>action="http://www.example.com/example.htm"</code>）<br>相对 URL - 指向网站内的一个文件（比如 <code>action="example.htm"</code>）</p><h4 id="autocomplete"><a href="#autocomplete" class="headerlink" title="autocomplete"></a>autocomplete</h4><p><code>autocomplete</code> 属性规定表单是否应该启用自动完成功能。</p><p>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</p><p>提示：<code>autocomplete</code> <strong>“on”</strong> 适用于表单，**”off”** 适用于特定的输入字段，反之亦然。</p><p>语法<br><code>&lt;form autocomplete="on|off"&gt;</code></p><h4 id="method属性"><a href="#method属性" class="headerlink" title="method属性"></a>method属性</h4><p><code>method</code> 方法规定如何发送表单数据（form-data）（表单数据会被发送到在 <code>action</code> 属性中规定的页面中）。</p><p>表单数据可被作为 URL 变量的形式来发送（method=”get”）或者作为 HTTP post 事务的形式来发送（method=”post”）。</p><h4 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4><p><code>name</code> 属性规定表单的名称。</p><p><code>name</code> 属性用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据</p><h4 id="novalidate属性"><a href="#novalidate属性" class="headerlink" title="novalidate属性"></a>novalidate属性</h4><p>novalidate 属性是一个布尔属性。</p><p>novalidate 属性规定当提交表单时不对表单数据（输入）进行验证。</p><h4 id="target属性-1"><a href="#target属性-1" class="headerlink" title="target属性"></a>target属性</h4><p>规定在何处打开 <code>action</code> URL。</p><p>语法<br><code>&lt;form target="_blank|_self|_parent|_top|framename"&gt;</code></p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_blank</td><td align="left">在新窗口/选项卡中打开。</td></tr><tr><td align="left">_self</td><td align="left">在同一框架中打开。（默认）</td></tr><tr><td align="left">_parent</td><td align="left">在父框架中打开。</td></tr><tr><td align="left">_top</td><td align="left">在整个窗口中打开。</td></tr><tr><td align="left">framename</td><td align="left">在指定的 iframe 中打开。</td></tr></tbody></table><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p><code>&lt;input&gt;</code> 标签规定了用户可以在其中输入数据的输入字段。</p><p><code>&lt;input&gt;</code> 元素在 <code>&lt;form&gt;</code> 元素中使用，用来声明允许用户输入数据的 input 控件。</p><p>输入字段可通过多种方式改变，取决于 <code>type</code> 属性。</p><p><strong>注意</strong>: <code>&lt;input&gt;</code> 元素是空的,它只包含标签属性。</p><p><strong>提示</strong>: 你可以使用 <code>&lt;label&gt;</code> 元素来定义 <code>&lt;input&gt;</code> 元素的标注。</p><p><code>&lt;input&gt;</code> 标签支持所有 HTML事件属性。</p><h4 id="accept属性"><a href="#accept属性" class="headerlink" title="accept属性"></a>accept属性</h4><p><code>accept</code> 属性规定了可通过文件上传提交的服务器接受的文件类型。</p><p>注意：<code>accept</code> 属性仅适用于 <code>&lt;input type="file"&gt;</code>。</p><p>语法<br><code>&lt;input accept="audio/*|video/*|image/*|MIME_type"&gt;</code></p><h4 id="alt属性-1"><a href="#alt属性-1" class="headerlink" title="alt属性"></a>alt属性</h4><p>定义图像输入的替代文本。 (只针对type=”image”)</p><h4 id="autocomplete属性"><a href="#autocomplete属性" class="headerlink" title="autocomplete属性"></a>autocomplete属性</h4><p>on/off</p><p><code>autocomplete</code> 属性规定 <code>&lt;input&gt;</code> 元素输入字段是否应该启用自动完成功能。</p><h4 id="autofocus属性"><a href="#autofocus属性" class="headerlink" title="autofocus属性"></a>autofocus属性</h4><p>语法</p><p><code>&lt;input autofocus&gt;</code></p><p><code>autofocus</code> 属性规定当页面加载时 <code>&lt;input&gt;</code> 元素应该自动获得焦点。</p><h4 id="checked属性"><a href="#checked属性" class="headerlink" title="checked属性"></a>checked属性</h4><p><code>checked</code> 属性规定在页面加载时应该被预先选定的 <code>&lt;input&gt;</code> 元素。</p><p><code>checked</code> 属性适用于 <code>&lt;input type="checkbox"&gt;</code> 和 <code>&lt;input type="radio"&gt;</code>。</p><p><code>checked</code> 属性也可以在页面加载后，通过 JavaScript 代码进行设置。</p><h4 id="max属性"><a href="#max属性" class="headerlink" title="max属性"></a>max属性</h4><p>属性规定 <code>&lt;input&gt;</code> 元素的最大值。</p><h4 id="maxlength属性"><a href="#maxlength属性" class="headerlink" title="maxlength属性"></a>maxlength属性</h4><p>属性规定 <code>&lt;input&gt;</code> 元素中允许的最大字符数</p><h4 id="min属性"><a href="#min属性" class="headerlink" title="min属性"></a>min属性</h4><p>属性规定 <code>&lt;input&gt;</code>元素的最小值。</p><h4 id="name属性-1"><a href="#name属性-1" class="headerlink" title="name属性"></a>name属性</h4><p>name 属性规定 <code>&lt;input&gt;</code> 元素的名称。</p><h4 id="placeholder属性"><a href="#placeholder属性" class="headerlink" title="placeholder属性"></a>placeholder属性</h4><p>placeholder 属性规定可描述输入 <code>&lt;input&gt;</code> 字段预期值的简短的提示信息 。</p><h4 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h4><p>属性规定必需在提交表单之前填写输入字段</p><h4 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h4><p>size 属性规定以字符数计的 <code>&lt;input&gt;</code> 元素的可见宽度。</p><h4 id="src属性-1"><a href="#src属性-1" class="headerlink" title="src属性"></a>src属性</h4><p><code>src</code> 属性规定显示为提交按钮的图像的 URL。 (只针对 type=”image”)</p><h4 id="value-属性"><a href="#value-属性" class="headerlink" title="value 属性"></a>value 属性</h4><p><code>value</code> 属性对于不同 input 类型，用法也不同：</p><p>对于 “button”、”reset”、”submit” 类型 - 定义按钮上的文本<br>对于 “text”、”password”、”hidden” 类型 - 定义输入字段的初始（默认）值<br>对于 “checkbox”、”radio”、”image” 类型 - 定义与 input 元素相关的值，当提交表单时该值会发送到表单的 action URL。<br>注意：value 属性对于 <code>&lt;input type="checkbox"&gt;</code> 和 <code>&lt;input type="radio"&gt;</code> 是必需的。</p><h4 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h4><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">button</td><td align="left">定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）。</td></tr><tr><td align="left">checkbox</td><td align="left">定义复选框。</td></tr><tr><td align="left">colorNew</td><td align="left">定义拾色器。</td></tr><tr><td align="left">dateNew</td><td align="left">定义 date 控件（包括年、月、日，不包括时间）。</td></tr><tr><td align="left">datetimeNew</td><td align="left">定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）。</td></tr><tr><td align="left">datetime-localNew</td><td align="left">定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）。</td></tr><tr><td align="left">emailNew</td><td align="left">定义用于 e-mail 地址的字段。</td></tr><tr><td align="left">file</td><td align="left">定义文件选择字段和 “浏览…” 按钮，供文件上传。</td></tr><tr><td align="left">hidden</td><td align="left">定义隐藏输入字段。</td></tr><tr><td align="left">image</td><td align="left">定义图像作为提交按钮。</td></tr><tr><td align="left">monthNew</td><td align="left">定义 month 和 year 控件（不带时区）。</td></tr><tr><td align="left">numberNew</td><td align="left">定义用于输入数字的字段。</td></tr><tr><td align="left">password</td><td align="left">定义密码字段（字段中的字符会被遮蔽）。</td></tr><tr><td align="left">radio</td><td align="left">定义单选按钮。</td></tr><tr><td align="left">rangeNew</td><td align="left">定义用于精确值不重要的输入数字的控件（比如 slider 控件）。</td></tr><tr><td align="left">reset</td><td align="left">定义重置按钮（重置所有的表单值为默认值）。</td></tr><tr><td align="left">searchNew</td><td align="left">定义用于输入搜索字符串的文本字段。</td></tr><tr><td align="left">submit</td><td align="left">定义提交按钮。</td></tr><tr><td align="left">telNew</td><td align="left">定义用于输入电话号码的字段。</td></tr><tr><td align="left">text</td><td align="left">默认。定义一个单行的文本字段（默认宽度为 20 个字符）。</td></tr><tr><td align="left">timeNew</td><td align="left">定义用于输入时间的控件（不带时区）。</td></tr><tr><td align="left">urlNew</td><td align="left">定义用于输入 URL 的字段。</td></tr><tr><td align="left">weekNew</td><td align="left">定义 week 和 year 控件（不带时区）。</td></tr></tbody></table><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p><code>&lt;label&gt; </code>标签为 <code>input</code> 元素定义标注（标记）。</p><p><code>label</code> 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 <code>label</code> 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</p><p><code>&lt;label&gt; </code>标签的 <code>for</code> 属性应当与相关元素的 <code>id</code> 属性相同。</p><h4 id="for属性"><a href="#for属性" class="headerlink" title="for属性"></a>for属性</h4><p>规定 label 与哪个表单元素绑定</p><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p><code>&lt;textarea&gt;</code> 标签定义一个多行的文本输入控件。</p><p>文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。</p><h4 id="autofocus属性-1"><a href="#autofocus属性-1" class="headerlink" title="autofocus属性"></a>autofocus属性</h4><p>规定当页面加载时，文本区域自动获得焦点。</p><h4 id="maxlength属性-1"><a href="#maxlength属性-1" class="headerlink" title="maxlength属性"></a>maxlength属性</h4><p>规定文本区域允许的最大字符数</p><h4 id="name属性-2"><a href="#name属性-2" class="headerlink" title="name属性"></a>name属性</h4><p>规定文本区域的名称</p><h4 id="placeholder属性-1"><a href="#placeholder属性-1" class="headerlink" title="placeholder属性"></a>placeholder属性</h4><p>规定一个简短的提示，描述文本区域期望的输入值</p><h4 id="readonly属性"><a href="#readonly属性" class="headerlink" title="readonly属性"></a>readonly属性</h4><p>规定文本区域为只读</p><h4 id="required属性-1"><a href="#required属性-1" class="headerlink" title="required属性"></a>required属性</h4><p>规定文本区域是必需的/必填的</p><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p><code>&lt;button&gt;</code> 标签定义一个按钮。</p><p>在 <code>&lt;button&gt;</code> 元素内部，您可以放置内容，比如文本或图像。这是该元素与使用 <code>&lt;input&gt;</code> 元素创建的按钮之间的不同之处。</p><p>提示：请始终为 <code>&lt;button&gt;</code> 元素规定 type 属性。不同的浏览器对 <code>&lt;button&gt;</code> 元素的 type 属性使用不同的默认值。</p><h4 id="name属性-3"><a href="#name属性-3" class="headerlink" title="name属性"></a>name属性</h4><p>规定按钮的名称。</p><h4 id="type属性-1"><a href="#type属性-1" class="headerlink" title="type属性"></a>type属性</h4><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">submit</td><td align="left">该按钮是提交按钮（除了 Internet Explorer，该值是其他浏览器的默认值）</td></tr><tr><td align="left">button</td><td align="left">该按钮是可点击的按钮（Internet Explorer 的默认值）。</td></tr><tr><td align="left">reset</td><td align="left">该按钮是重置按钮（清除表单数据）。</td></tr></tbody></table><h4 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h4><p>规定按钮的初始值。可由脚本进行修改</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>&lt;select&gt;</code> 元素用来创建下拉列表。</p><p><code>&lt;select&gt;</code> 元素中的 <code>&lt;option&gt;</code> 标签定义了列表中的可用选项。</p><p><strong>提示</strong>：<code>&lt;select&gt;</code> 元素是一种表单控件，可用于在表单中接受用户输入</p><h4 id="name属性-4"><a href="#name属性-4" class="headerlink" title="name属性"></a>name属性</h4><p>定义下拉列表的名称</p><h4 id="required属性-2"><a href="#required属性-2" class="headerlink" title="required属性"></a>required属性</h4><p>规定用户在提交表单前必须选择一个下拉列表中的选项</p><h4 id="size属性-1"><a href="#size属性-1" class="headerlink" title="size属性"></a>size属性</h4><p>规定下拉列表中可见选项的数目</p><h4 id="multiple属性"><a href="#multiple属性" class="headerlink" title="multiple属性"></a>multiple属性</h4><p>当该属性为 true 时，可选择多个选项。</p><h4 id="autofocus属性-2"><a href="#autofocus属性-2" class="headerlink" title="autofocus属性"></a>autofocus属性</h4><p>规定在页面加载时下拉列表自动获得焦点。</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p><code>&lt;table&gt; </code>标签定义 HTML 表格</p><p>一个 HTML 表格包括 <code>&lt;table&gt;</code> 元素，一个或多个 <code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code> 以及 <code>&lt;td&gt;</code> 元素。</p><p><code>&lt;tr&gt; </code>元素定义表格行，<code>&lt;th&gt;</code> 元素定义表头，<code>&lt;td&gt;</code> 元素定义表格单元。</p><h4 id="border属性"><a href="#border属性" class="headerlink" title="border属性"></a>border属性</h4><p><code>border</code> 属性规定表格单元周围是否显示边框。</p><p>值 “1” 指示应该显示边框，且表格不用于布局目的。</p><h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p><code>&lt;b&gt;</code> 标签定义粗体的文本</p><p>注释：根据 HTML 5 的规范，<code>&lt;b&gt;</code> 标签应该做为最后的选择，只有在没有其他标记比较合适时才使用它。HTML 5 规范声明：标题应该用 <code>&lt;h1&gt; - &lt;h6&gt;</code> 标签表示，被强调的文本应该用 <code>&lt;em&gt;</code> 标签表示，重要的文本应该用 <code>&lt;strong&gt;</code> 标签表示，被标记的或者高亮显示的文本应该用 <code>&lt;mark&gt;</code> 标签表示。</p><p>提示：您也可以使用 CSS 的 <code>"font-weight"</code> 属性设置粗体文本。</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p><code>&lt;em&gt;</code> 标签是一个短语标签，用来呈现为被强调的文本。</p><p>提示：我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。</p><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><p><code>&lt;i&gt;</code> 定义与文本中其余部分不同的部分，并把这部分文本呈现为斜体文本。</p><p><code>&lt;i&gt;</code> 标签被用来表示科技术语、其他语种的成语俗语、想法、宇宙飞船的名字等等。</p><p>在没有其他适当语义的元素可以使用时，请使用 <code>&lt;i&gt;</code> 元素。</p><h3 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h3><p><code>&lt;strong&gt;</code> 标签是一个短语标签，用来定义计算机程序的样本重要的文本。</p><p>提示：我们并不反对使用这个标签，但是如果您只是为了达到某种视觉效果而使用这个标签的话，我们建议您使用 CSS ，这样可能会取得更丰富的效果。</p><h3 id="small"><a href="#small" class="headerlink" title="small"></a>small</h3><p><code>&lt;small&gt;</code> 标签定义小型文本（和旁注）</p><h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p><code>&lt;style&gt;</code> 标签定义 HTML 文档的样式信息。</p><p>在 <code>&lt;style&gt;</code> 元素中，您可以规定在浏览器中如何呈现 HTML 文档。</p><p>每个 HTML 文档能包含多个 <code>&lt;style&gt;</code> 标签。</p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p><code>&lt;link&gt;</code> 标签定义文档与外部资源的关系。</p><p><code>&lt;link&gt;</code> 标签最常见的用途是链接样式表。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> HTML5+CSS3权威指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0035.html"/>
      <url>posts/a0035.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0034">函数(十五) 立即调用的函数表达式</a></strong><br>本篇： <strong>函数(十六) 私有变量</strong><br>下篇： <strong><a href="a0036">BOM(一)：window对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0034.html"/>
      <url>posts/a0034.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0033">函数(十四) 闭包</a></strong><br>本篇： <strong>函数(十五) 立即调用的函数表达式</strong><br>下篇： <strong><a href="a0035">函数(十六) 私有变量</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h1><p>立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately Invoked Function<br>Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子：</p><pre><code>(function() {    // 块级作用域})(); </code></pre><p>使用 IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE模拟块级作用域是相当普遍的。比如下面的例子：</p><pre><code>// IIFE(function () {    for (var i = 0; i &lt; count; i++) {        console.log(i);    }})();console.log(i); // 抛出错误</code></pre><p>前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。</p><p>这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。</p><p>在 ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离。下面展示了两种不同的块级作用域形式：</p><pre><code>// 内嵌块级作用域{    let i;    for (i = 0; i &lt; count; i++) {        console.log(i);    }}console.log(i); // 抛出错误// 循环的块级作用域for (let i = 0; i &lt; count; i++) {    console.log(i);}console.log(i); // 抛出错误</code></pre><p>说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如：</p><pre><code>let divs = document.querySelectorAll('div');// 达不到目的！for (var i = 0; i &lt; divs.length; ++i) {    divs[i].addEventListener('click', function() {        console.log(i);    });}</code></pre><p>这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。因此，渲染到页面上之后，点击每个<code>&lt;div&gt;</code>都会弹出元素总数。这是因为在执行单击处理程序时，迭代变量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。</p><p>以前，为了实现点击第几个<code>&lt;div&gt;</code>就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传入每次循环的当前索引，从而“锁定”点击时应该显示的索引值： </p><pre><code>let divs = document.querySelectorAll('div');for (var i = 0; i &lt; divs.length; ++i) {    divs[i].addEventListener('click', (function(frozenCounter) {        return function() {            console.log(frozenCounter);        };    })(i));} </code></pre><p>而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：</p><pre><code>let divs = document.querySelectorAll('div');for (let i = 0; i &lt; divs.length; ++i) {    divs[i].addEventListener('click', function() {         console.log(i);    });} </code></pre><p>这样就可以让每次点击都显示正确的索引了。这里，事件处理程序执行时就会引用 for 循环块级作用域中的索引值。这是因为在 ECMAScript 6 中，如果对 for 循环使用块级作用域变量关键字，在这里就是 let，那么循环就会为每个循环创建独立的变量，从而让每个单击处理程序都能引用特定的索引。</p><p>但要注意，如果把变量声明拿到 for 循环外部，那就不行了。下面这种写法会碰到跟在循环中使用var i = 0 同样的问题：</p><pre><code>let divs = document.querySelectorAll('div');// 达不到目的！let i;for (i = 0; i &lt; divs.length; ++i) {    divs[i].addEventListener('click', function() {        console.log(i);    });} </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0033.html"/>
      <url>posts/a0033.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0032">函数(十三) 尾调用优化</a></strong><br>本篇： <strong>函数(十四) 闭包</strong><br>下篇： <strong><a href="a0034">函数(十五) 立即调用的函数表达式</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数，注意其中加粗的代码：</p><pre><code>function createComparisonFunction(propertyName) {    return function(object1, object2) {        **let value1 = object1[propertyName];**        **let value2 = object2[propertyName];**        if (value1 &lt; value2) {            return -1;        } else if (value1 &gt; value2) {            return 1;        } else {            return 0;        }    };} </code></pre><p>这里加粗的代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含createComparisonFunction()函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。</p><p>本书在第 4 章曾介绍过作用域链的概念。理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：</p><pre><code>function compare(value1, value2) {    if (value1 &lt; value2) {        return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }}let result = compare(5, 10); </code></pre><p>这里定义的 compare()函数是在全局上下文中调用的。第一次调用 compare()时，会为它创建一个包含 arguments、value1 和 value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 compare()作用域链上的第二个对象，其中包含 this、result 和 compare。</p><p>图 A 展示了以上关系。</p><p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[ Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[ Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201127072822.png" alt="A"></p><p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。</p><p>在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在createComparisonFunction()函数中，匿名函数的作用域链中实际上包含createComparisonFunction()的活动对象。</p><p>图 B 展示了以下代码执行后的结果。</p><pre><code>let compare = createComparisonFunction('name');let result = compare({ name: 'Nicholas' }, { name: 'Matt' }); </code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201127081252.png" alt="B"></p><p>在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：</p><pre><code>// 创建比较函数let compareNames = createComparisonFunction('name');// 调用函数let result = compareNames({ name: 'Nicholas' }, { name: 'Matt' });// 解除对函数的引用，这样就可以释放内存了compareNames = null;</code></pre><p>这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。</p><p><strong>注意</strong> 因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。</p><h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p>在闭包中使用 this 会让代码变复杂。如果内部函数没有使用箭头函数定义，则 this 对象会在运行时绑定到执行函数的上下文。如果在全局函数中调用，则 this 在非严格模式下等于 window，在严格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。匿名函数在这种情况下不会绑定到某个对象，这就意味着 this 会指向 window，除非在严格模式下 this 是 undefined。</p><p>不过，由于闭包的写法所致，这个事实有时候没有那么容易看出来。来看下面的例子：</p><pre><code>window.identity = 'The Window';let object = {    identity: 'My Object',        getIdentityFunc() {            return function() {                return this.identity;            };    }};console.log(object.getIdentityFunc()()); // 'The Window' </code></pre><p>这里先创建了一个全局变量 identity，之后又创建一个包含 identity 属性的对象。这个对象还包含一个 getIdentityFunc()方法，返回一个匿名函数。这个匿名函数返回 this.identity。因为getIdentityFunc()返回函数，所以 object.getIdentityFunc()()会立即调用这个返回的函数，从而得到一个字符串。可是，此时返回的字符串是”The Winodw”，即全局变量 identity 的值。为什么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？</p><p>前面介绍过，每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。但是，如果把 this 保存到闭包可以访问的另一个变量中，则是行得通的。比如：</p><pre><code>window.identity = 'The Window';let object = {    identity: 'My Object',    getIdentityFunc() {        let that = this;            return function() {                return that.identity;            };    }};console.log(object.getIdentityFunc()()); // 'My Object' </code></pre><p>这里加粗的代码展示了与前面那个例子的区别。在定义匿名函数之前，先把外部函数的 this 保存到变量 that 中。然后在定义闭包时，就可以让它访问 that，因为这是包含函数中名称没有任何冲突的一个变量。即使在外部函数返回之后，that 仍然指向 object，所以调用 object.getIdentityFunc()()就会返回”My Object”。</p><p><strong>注意</strong> this 和 arguments 都是不能直接在内部函数中访问的。如果想访问包含作用域中的 arguments 对象，则同样需要将其引用先保存到闭包能访问的另一个变量中。</p><p>在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：</p><pre><code>window.identity = 'The Window';let object = {    identity: 'My Object',    getIdentity () {        return this.identity;    }}; </code></pre><p>getIdentity()方法就是返回 this.identity 的值。以下是几种调用 object.getIdentity()的方式及返回值：</p><pre><code>object.getIdentity(); // 'My Object'(object.getIdentity)(); // 'My Object'(object.getIdentity = object.getIdentity)(); // 'The Window' </code></pre><p>第一行调用 object.getIdentity()是正常调用，会返回”My Object”，因为 this.identity就是 object.identity。第二行在调用时把 object.getIdentity 放在了括号里。虽然加了括号之后看起来是对一个函数的引用，但 this 值并没有变。这是因为按照规范，object.getIdentity 和(object.getIdentity)是相等的。第三行执行了一次赋值，然后再调用赋值后的结果。因为赋值表达式的值是函数本身，this 值不再与任何对象绑定，所以返回的是”The Window”。</p><p>一般情况下，不大可能像第二行和第三行这样调用对象上的方法。但通过这个例子，我们可以知道，即使语法稍有不同，也可能影响 this 的值。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>由于 IE 在 IE9 之前对 JScript 对象和 COM 对象使用了不同的垃圾回收机制（第 4 章讨论过），所以闭包在这些旧版本 IE 中可能会导致问题。在这些版本的 IE 中，把 HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。来看下面的例子：</p><pre><code>function assignHandler() {    let element = document.getElementById('someElement');    element.onclick = () =&gt; console.log(element.id);}</code></pre><p>以上代码创建了一个闭包，即 element 元素的事件处理程序（事件处理程序将在第 13 章讨论）。而这个处理程序又创建了一个循环引用。匿名函数引用着 assignHandler()的活动对象，阻止了对element 的引用计数归零。只要这个匿名函数存在，element 的引用计数就至少等于 1。也就是说，内存不会被回收。其实只要这个例子稍加修改，就可以避免这种情况，比如：</p><pre><code>function assignHandler() {    let element = document.getElementById('someElement');    let id = element.id;    element.onclick = () =&gt; console.log(id);    element = null;}</code></pre><p>在这个修改后的版本中，闭包改为引用一个保存着 element.id 的变量 id，从而消除了循环引用。不过，光有这一步还不足以解决内存问题。因为闭包还是会引用包含函数的活动对象，而其中包含element。即使闭包没有直接引用 element，包含函数的活动对象上还是保存着对它的引用。因此，必须再把 element 设置为 null。这样就解除了对这个 COM 对象的引用，其引用计数也会减少，从而确保其内存可以在适当的时候被回收</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0032.html"/>
      <url>posts/a0032.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0031">函数(十二) 递归</a></strong><br>本篇： <strong>函数(十三) 尾调用优化</strong><br>下篇： <strong><a href="a0033">函数(十四) 闭包</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><p>ECMAScript 6 规范新增了一项内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：</p><pre><code>function outerFunction() {    return innerFunction(); // 尾调用} </code></pre><p>在ES6 优化之前，执行这个例子会在内存中发生如下操作。</p><p>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。<br>(2) 执行 outerFunction 函数体，到 return 语句。计算返回值必须先计算 innerFunction。<br>(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。<br>(4) 执行 innerFunction 函数体，计算其返回值。<br>(5) 将返回值传回 outerFunction，然后 outerFunction 再返回值。<br>(6) 将栈帧弹出栈外。</p><p>ES6 优化之后，执行这个例子会在内存中发生如下操作。</p><p>(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。<br>(2) 执行 outerFunction 函数体，到达 return 语句。为求值返回语句，必须先求值 innerFunction。<br>(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为 innerFunction 的返回值也是 outerFunction的返回值。<br>(4) 弹出 outerFunction 的栈帧。<br>(5) 执行到 innerFunction 函数体，栈帧被推到栈上。<br>(6) 执行 innerFunction 函数体，计算其返回值。<br>(7) 将 innerFunction 的栈帧弹出栈外。</p><p>很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是 ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。</p><h2 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h2><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及的条件如下：</p><ol><li>代码在严格模式下执行；</li><li>外部函数的返回值是对尾调用函数的调用；</li><li>尾调用函数返回后不需要执行额外的逻辑；</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包。</li></ol><p>下面展示了几个违反上述条件的函数，因此都不符号尾调用优化的要求：</p><pre><code>"use strict";// 无优化：尾调用没有返回function outerFunction() {    innerFunction();}// 无优化：尾调用没有直接返回function outerFunction() {    let innerFunctionResult = innerFunction();    return innerFunctionResult;}// 无优化：尾调用返回后必须转型为字符串function outerFunction() {    return innerFunction().toString();}// 无优化：尾调用是一个闭包function outerFunction() {    let foo = 'bar';    function innerFunction() { return foo; }    return innerFunction();} </code></pre><p>下面是几个符合尾调用优化条件的例子：</p><pre><code>"use strict";// 有优化：栈帧销毁前执行参数计算function outerFunction(a, b) {    return innerFunction(a + b);}// 有优化：初始返回值不涉及栈帧function outerFunction(a, b) {if (a &lt; b) {    return a;}return innerFunction(a + b);}// 有优化：两个内部函数都在尾部function outerFunction(condition) {    return condition ? innerFunctionA() : innerFunctionB();} </code></pre><p>差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。</p><p><strong>注意</strong> 之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 f.arguments和 f.caller，而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。</p><h2 id="尾调用优化的代码"><a href="#尾调用优化的代码" class="headerlink" title="尾调用优化的代码"></a>尾调用优化的代码</h2><p>可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归计算斐波纳契数列的函数：</p><pre><code>function fib(n) {    if (n &lt; 2) {        return n;    }    return fib(n - 1) + fib(n - 2);}console.log(fib(0)); // 0console.log(fib(1)); // 1console.log(fib(2)); // 1console.log(fib(3)); // 2console.log(fib(4)); // 3console.log(fib(5)); // 5console.log(fib(6)); // 8 </code></pre><p>显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈<br>帧数的内存复杂度是 O(2n)。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：</p><p><code>fib(1000); </code></p><p>当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归：</p><pre><code>"use strict";// 基础框架function fib(n) {    return fibImpl(0, 1, n);}// 执行递归function fibImpl(a, b, n) {    if (n === 0) {        return a;    }    return fibImpl(b, a + b, n - 1);}</code></pre><p>这样重构之后，就可以满足尾调用优化的所有条件，再调用 fib(1000)就不会对浏览器造成威胁了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0031.html"/>
      <url>posts/a0031.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0030">函数(十一) 函数表达式</a></strong><br>本篇： <strong>函数(十二) 递归</strong><br>下篇： <strong><a href="a0032">函数(十三) 尾调用优化</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示：</p><pre><code>function factorial(num) {    if (num &lt;= 1) {        return 1;    } else {        return num * factorial(num - 1);    }} </code></pre><p>这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题：</p><pre><code>let anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4)); // 报错</code></pre><p>这里把 factorial()函数保存在了另一个变量 anotherFactorial 中，然后将 factorial 设置为 null，于是只保留了一个对原始函数的引用。而在调用 anotherFactorial()时，要递归调用factorial()，但因为它已经不是函数了，所以会出错。在写递归函数时使用 arguments.callee 可以避免这个问题。arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：</p><pre><code>function factorial(num) {    if (num &lt;= 1) {        return 1;    } else {        return num * arguments.callee(num - 1);    }} </code></pre><p>把函数名称替换成 arguments.callee，可以确保无论通过什么变量调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee 是引用当前函数的首选。</p><p>不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的。比如：</p><pre><code>const factorial = (function f(num) {    if (num &lt;= 1) {        return 1;    } else {        return num * f(num - 1);    }}); </code></pre><p>这里创建了一个命名函数表达式 f()，然后将它赋值给了变量 factorial。即使把函数赋值给另一个变量，函数表达式的名称 f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0030.html"/>
      <url>posts/a0030.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0029">函数(十) 函数属性与方法</a></strong><br>本篇： <strong>函数(十一) 函数表达式</strong><br>下篇： <strong><a href="a0031">函数(十二) 递归</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>函数表达式虽然更强大，但也更容易让人迷惑。我们知道，定义函数有两种方式：函数声明和函数表达式。函数声明是这样的：</p><pre><code>function functionName(arg0, arg1, arg2) {// 函数体} </code></pre><p>函数声明的关键特点是函数声明提升，即函数声明会在代码执行之前获得定义。这意味着函数声明可以出现在调用它的代码之后：</p><pre><code>sayHi();function sayHi() {    console.log("Hi!");}</code></pre><p>这个例子不会抛出错误，因为 JavaScript 引擎会先读取函数声明，然后再执行代码。第二种创建函数的方式就是函数表达式。函数表达式有几种不同的形式，最常见的是这样的：</p><pre><code>let functionName = function(arg0, arg1, arg2) {// 函数体}; </code></pre><p>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量<br>functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串。</p><p>函数表达式跟 JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误：</p><pre><code>sayHi(); // Error! function doesn't exist yetlet sayHi = function() {    console.log("Hi!");}; </code></pre><p>理解函数声明与函数表达式之间的区别，关键是理解提升。比如，以下代码的执行结果可能会出乎意料：</p><pre><code>// 千万别这样做！if (condition) {    function sayHi() {        console.log('Hi!');    }} else {    function sayHi() {        console.log('Yo!');    }} </code></pre><p>这段代码看起来很正常，就是如果 condition 为 true，则使用第一个 sayHi()定义；否则，就使用第二个。事实上，这种写法在 ECAMScript 中不是有效的语法。JavaScript 引擎会尝试将其纠正为适当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览器会忽略 condition 直接返回第二个声明。Firefox 会在 condition 为 true 时返回第一个声明。这种写法很危险，不要使用。不过，如果把上面的函数声明换成函数表达式就没问题了：</p><pre><code>// 没问题let sayHi;if (condition) {    sayHi = function() {        console.log("Hi!");    };} else {    sayHi = function() {        console.log("Yo!");    };}</code></pre><p>这个例子可以如预期一样，根据 condition 的值为变量 sayHi 赋予相应的函数。创建函数并赋值给变量的能力也可以用于在一个函数中把另一个函数当作值返回： </p><pre><code>function createComparisonFunction(propertyName) {     return function(object1, object2) {        let value1 = object1[propertyName];        let value2 = object2[propertyName];        if (value1 &lt; value2) {            return -1;        } else if (value1 &gt; value2) {            return 1;        } else {             return 0;        }    };}</code></pre><p>这里的 createComparisonFunction()函数返回一个匿名函数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在 createComparisonFunction()内部，那个函数是匿名的。任何时候，只要函数被当作值来使用，它就是一个函数表达式。本章后面会介绍，这并不是使用函数表达式的唯一方式。 </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0029.html"/>
      <url>posts/a0029.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0028">函数(九) 函数内部</a></strong><br>本篇： <strong>函数(十) 函数属性与方法</strong><br>下篇： <strong><a href="a0030">函数(十一) 函数表达式</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h1><p>前面提到过，ECMAScript 中的函数是对象，因此有属性和方法。每个函数都有两个属性：length和 prototype。其中，length 属性保存函数定义的命名参数的个数，如下例所示：</p><pre><code>function sayName(name) {    console.log(name);}function sum(num1, num2) {    return num1 + num2;}function sayHi() {    console.log("hi");}console.log(sayName.length); // 1console.log(sum.length); // 2console.log(sayHi.length); // 0 </code></pre><p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。这个属性在自定义类型时特别重要。（相关内容已经在第 6 章详细介绍过了。）在 ECMAScript 5中，prototype 属性是不可枚举的，因此使用 for-in 循环不会返回这个属性。</p><p>函数还有两个方法：apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值。apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。来看下面的例子：</p><pre><code>function sum(num1, num2) {    return num1 + num2;}function callSum1(num1, num2) {    return sum.apply(this, arguments); // 传入 arguments 对象}function callSum2(num1, num2) {    return sum.apply(this, [num1, num2]); // 传入数组}console.log(callSum1(10, 10)); // 20console.log(callSum2(10, 10)); // 20 </code></pre><p>在这个例子中，callSum1()会调用 sum()函数，将 this 作为函数体内的 this 值（这里等于window，因为是在全局作用域中调用的）传入，同时还传入了 arguments 对象。callSum2()也会调用 sum()函数，但会传入参数的数组。这两个函数都会执行并返回正确的结果。</p><p>注意 在严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。<br>除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。</p><p>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须将参数一个一个地列出来，比如：</p><pre><code>function sum(num1, num2) {    return num1 + num2;}    function callSum(num1, num2) {return sum.call(this, num1, num2);}console.log(callSum(10, 10)); // 20</code></pre><p>这里的 callSum()函数必须逐个地把参数传给 call()方法。结果跟 apply()的例子一样。到底是使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便。如果想直接传 arguments对象或者一个数组，那就用 apply()；否则，就用 call()。当然，如果不用给被调用的函数传参，则使用哪个方法都一样。</p><p>apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this值的能力。考虑下面的例子：</p><pre><code>window.color = 'red';    let o = {        color: 'blue'    };    function sayColor() {        console.log(this.color);    }sayColor(); // redsayColor.call(this); // redsayColor.call(window); // redsayColor.call(o); // blue </code></pre><p>这个例子是在之前那个关于 this 对象的例子基础上修改而成的。同样，sayColor()是一个全局函数，如果在全局作用域中调用它，那么会显示”red”。这是因为 this.color 会求值为 window.color。如果在全局作用域中显式调用 sayColor.call(this)或者 sayColor.call(window)，则同样都会显示”red”。而在使用 sayColor.call(o)把函数的执行上下文即 this 切换为对象 o 之后，结果就变成了显示”blue”了。</p><p>使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法。在前面例子最初的版本中，为切换上下文需要先把 sayColor()直接赋值为 o 的属性，然后再调用。而在这个修改后的版本中，就不需要这一步操作了。</p><p>ECMAScript 5 出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind()的对象。比如：</p><pre><code>window.color = 'red';var o = {    color: 'blue'};function sayColor() {    console.log(this.color);}let objectSayColor = sayColor.bind(o);objectSayColor(); // blue</code></pre><p>这里，在 sayColor()上调用 bind()并传入对象 o 创建了一个新函数 objectSayColor()。objectSayColor()中的 this 值被设置为 o，因此直接调用这个函数，即使是在全局作用域中调用，也会返回字符串”blue”。对函数而言，继承的方法 toLocaleString()和 toString()始终返回函数的代码。返回代码的具体格式因浏览器而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。继承的方法 valueOf()返回函数本身。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0028.html"/>
      <url>posts/a0028.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0027">函数(八) 函数作为值</a></strong><br>本篇： <strong>函数(九) 函数内部</strong><br>下篇： <strong><a href="a0029">函数(十) 函数属性与方法</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h1><p>在 ECMAScript 5 中，函数内部存在两个特殊的对象：arguments 和 this。ECMAScript 6 又新增了 new.target 属性。</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针。来看下面这个经典的阶乘函数：</p><pre><code>function factorial(num) {    if (num &lt;= 1) {        return 1;    } else {        return num * factorial(num - 1);    }} </code></pre><p>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial，从而导致了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数名解耦：</p><pre><code>function factorial(num) {    if (num &lt;= 1) {        return 1;    } else {        return num * arguments.callee(num - 1);    }} </code></pre><p>这个重写之后的 factorial()函数已经用 arguments.callee 代替了之前硬编码的 factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：</p><pre><code>let trueFactorial = factorial;factorial = function() {    return 0;};console.log(trueFactorial(5)); // 120console.log(factorial(5)); // 0 </code></pre><p>这里，trueFactorial 变量被赋值为 factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial 函数又被重写为一个返回 0 的函数。如果像 factorial()最初的版本那样不使用 arguments.callee，那么像上面这样调用 trueFactorial()就会返回 0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而 factorial()则只能返回 0。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>另一个特殊的对象是 this，它在标准函数和箭头函数中有不同的行为。在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在网页的全局上下文中调用函数时，this 指向 windows）。来看下面的例子：</p><pre><code>window.color = 'red';let o = {    color: 'blue'};function sayColor() {    console.log(this.color);}sayColor(); // 'red'o.sayColor = sayColor;o.sayColor(); // 'blue' </code></pre><p>定义在全局上下文中的函数 sayColor()引用了 this 对象。这个 this 到底引用哪个对象必须到函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用sayColor()，这结果会输出”red”，因为 this 指向 window，而 this.color 相当于 window.color。而在把 sayColor()赋值给 o 之后再调用 o.sayColor()，this 会指向 o，即 this.color 相当于o.color，所以会显示”blue”。</p><p>在箭头函数中，this引用的是定义箭头函数的上下文。下面的例子演示了这一点。在对sayColor()的两次调用中，this 引用的都是 window 对象，因为这个箭头函数是在 window 上下文中定义的：</p><pre><code>window.color = 'red';let o = {    color: 'blue'};let sayColor = () =&gt; console.log(this.color);sayColor(); // 'red'o.sayColor = sayColor;o.sayColor(); // 'red' </code></pre><p>在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：</p><pre><code>function King() {    this.royaltyName = 'Henry';    // this 引用 King 的实例    setTimeout(() =&gt; console.log(this.royaltyName), 1000);} function Queen() {     this.royaltyName = 'Elizabeth';    // this 引用 window 对象    setTimeout(function() { console.log(this.royaltyName); }, 1000);}new King(); // Henrynew Queen(); // undefined</code></pre><p><strong>注意</strong> 函数名只是保存指针的变量。因此全局定义的 sayColor()函数和 o.sayColor()是同一个函数，只不过执行的上下文不同。 </p><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><p>ECMAScript 5 也会给函数对象上添加一个属性：caller。虽然 ECMAScript 3 中并没有定义，但所有浏览器除了早期版本的 Opera 都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。比如：</p><pre><code>function outer() {    inner();}function inner() {    console.log(inner.caller);}outer();</code></pre><p>以上代码会显示 outer()函数的源代码。这是因为 ourter()调用了 inner()，inner.caller指向 outer()。如果要降低耦合度，则可以通过 arguments.callee.caller 来引用同样的值：</p><pre><code>function outer() {    inner();}function inner() {    console.log(arguments.callee.caller);}outer();</code></pre><p>在严格模式下访问 arguments.callee 会报错。ECMAScript 5 也定义了 arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是 undefined。这是为了分清 arguments.caller和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。</p><p>严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误。</p><h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p><pre><code>function King() {    if (!new.target) {        throw 'King must be instantiated using "new"'    }    console.log('King instantiated using "new"');}new King(); // King instantiated using "new"King(); // Error: King must be instantiated using "new" </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0027.html"/>
      <url>posts/a0027.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0026">函数(七) 函数声明与函数表达式</a></strong><br>本篇： <strong>函数(八) 函数作为值</strong><br>下篇： <strong><a href="a0028">函数(九) 函数内部</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h1><p>因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。来看下面的例子：</p><pre><code>function callSomeFunction(someFunction, someArgument) {    return someFunction(someArgument);}</code></pre><p>这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数传递：</p><pre><code>function add10(num) {    return num + 10;}let result1 = callSomeFunction(add10, 10);console.log(result1); // 20function getGreeting(name) {    return "Hello, " + name;}let result2 = callSomeFunction(getGreeting, "Nicholas");console.log(result2); // "Hello, Nicholas" </code></pre><p>callSomeFunction()函数是通用的，第一个参数传入的是什么函数都可以，而且它始终返回调用作为第一个参数传入的函数的结果。要注意的是，如果是访问函数而不是调用函数，那就必须不带括号，所以传给 callSomeFunction()的必须是 add10 和 getGreeting，而不能是它们的执行结果。</p><p>从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组进行排序。为此，可以定义一个 sort()方法需要的比较函数，它接收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较函数的函数来解决。比如：</p><pre><code>return function(object1, object2) {    let value1 = object1[propertyName];    let value2 = object2[propertyName];    if (value1 &lt; value2) {        return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }    };} </code></pre><p>这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返回另一个函数，注意那个 return操作符。内部函数可以访问 propertyName 参数，并通过中括号语法取得要比较的对象的相应属性值。取得属性值以后，再按照 sort()方法的需要返回比较值就行了。这个函数可以像下面这样使用：</p><pre><code>let data = [    {name: "Zachary", age: 28},    {name: "Nicholas", age: 29}];data.sort(createComparisonFunction("name"));console.log(data[0].name); // Nicholas data.sort(createComparisonFunction("age"));console.log(data[0].name); // Zachary </code></pre><p>在上面的代码中，数组 data 中包含两个结构相同的对象。每个对象都有一个 name 属性和一个 age属性。默认情况下，sort()方法要对这两个对象执行 toString()，然后再决定它们的顺序，但这样得不到有意义的结果。而通过调用 createComparisonFunction(“name”)来创建一个比较函数，就可以根据个对象 name 属性的值来排序，结果 name 属性值为”Nicholas”、age 属性值为 29 的对象会排在前面。而调用 createComparisonFunction(“age”)则会创建一个根据每个对象 age 属性的值来排序的比较函数，结果 name 属性值为”Zachary”、age 属性值为 28 的对象会排在前面。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0026.html"/>
      <url>posts/a0026.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0025">函数(六) 函数扩展与收集</a></strong><br>本篇： <strong>函数(七) 函数声明与函数表达式</strong><br>下篇： <strong><a href="a0027">函数(八) 函数作为值</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h1><p>本章到现在一直没有把函数声明和函数表达式区分得很清楚。事实上，JavaScript 引擎在加载数据时对它们是区别对待的。JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。来看下面的例子：</p><pre><code>// 没问题console.log(sum(10, 10));function sum(num1, num2) {    return num1 + num2;} </code></pre><p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作<strong>函数声明提升</strong>（function declaration hoisting）。在执行代码时，JavaScript 引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错：</p><pre><code>// 会出错console.log(sum(10, 10));let sum = function(num1, num2) {    return num1 + num2;}; </code></pre><p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰到同样的问题：</p><pre><code>console.log(sum(10, 10));var sum = function(num1, num2) {    return num1 + num2;}; </code></pre><p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p><p><strong>注意</strong> 在使用函数表达式初始化变量时，也可以给函数一个名称，比如 let sum =function sum() {}。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0025.html"/>
      <url>posts/a0025.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0024">函数(五) 默认参数值</a></strong><br>本篇： <strong>函数(六) 函数扩展与收集</strong><br>下篇： <strong><a href="a0026">函数(七) 函数声明与函数表达式</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数扩展与收集"><a href="#函数扩展与收集" class="headerlink" title="函数扩展与收集"></a>函数扩展与收集</h1><p>ECMAScript 6 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。</p><h2 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h2><p>在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。</p><p>假设有如下函数定义，它会将所有传入的参数累加起来：</p><pre><code>let values = [1, 2, 3, 4];function getSum() {    let sum = 0;    for (let i = 0; i &lt; arguments.length; ++i) {        sum += arguments[i];    }    return sum;} </code></pre><p>这个函数希望将所有加数逐个传进来，然后通过迭代 arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply()方法：</p><p><code>console.log(getSum.apply(null, values)); // 10</code></p><p>但在 ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。</p><p>比如，使用扩展操作符可以将前面例子中的数组像这样直接传给函数：</p><p><code>console.log(getSum(...values)); // 10</code></p><p>因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数：</p><pre><code>console.log(getSum(-1, ...values)); // 9console.log(getSum(...values, 5)); // 15console.log(getSum(-1, ...values, 5)); // 14console.log(getSum(...values, ...[5,6,7])); // 28 </code></pre><p>对函数中的 arguments 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参数接收每一个值：</p><pre><code>let values = [1,2,3,4]function countArguments() {    console.log(arguments.length);}countArguments(-1, ...values); // 5countArguments(...values, 5); // 5countArguments(-1, ...values, 5); // 6countArguments(...values, ...[5,6,7]); // 7 </code></pre><p>arguments 对象只是消费扩展操作符的一种方式。在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：</p><pre><code>function getProduct(a, b, c = 1) {    return a * b * c;}let getSum = (a, b, c = 0) =&gt; {    return a + b + c;}console.log(getProduct(...[1,2])); // 2console.log(getProduct(...[1,2,3])); // 6console.log(getProduct(...[1,2,3,4])); // 6console.log(getSum(...[0,1])); // 1console.log(getSum(...[0,1,2])); // 3console.log(getSum(...[0,1,2,3])); // 3 </code></pre><h2 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h2><p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。</p><pre><code>function getSum(...values) {    // 顺序累加 values 中的所有值    // 初始值的总和为 0    return values.reduce((x, y) =&gt; x + y, 0);}console.log(getSum(1,2,3)); // 6 </code></pre><p>收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：</p><pre><code>// 不可以function getProduct(...values, lastValue) {}// 可以function ignoreFirst(firstValue, ...values) {    console.log(values);}ignoreFirst(); // []ignoreFirst(1); // []ignoreFirst(1,2); // [2]ignoreFirst(1,2,3); // [2, 3] </code></pre><p>箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用arguments 一样的逻辑：</p><pre><code>let getSum = (...values) =&gt; {    return values.reduce((x, y) =&gt; x + y, 0);}console.log(getSum(1,2,3)); // 6 </code></pre><p>另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数：</p><pre><code>function getSum(...values) {    console.log(arguments.length); // 3    console.log(arguments); // [1, 2, 3]    console.log(values); // [1, 2, 3]}console.log(getSum(1,2,3)); </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0024.html"/>
      <url>posts/a0024.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇： <strong><a href="a0023">函数(四) 没有重载</a></strong><br>本篇： <strong>函数(五) 默认参数值</strong><br>下篇： <strong><a href="a0025">函数(六) 函数扩展与收集</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h1><p> ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined，如果是则意味着没有传这个参数，那就给它赋一个值：</p><pre><code>function makeKing(name) {    name = (typeof name !== 'undefined') ? name : 'Henry';    return `King ${name} VIII`;}console.log(makeKing()); // 'King Henry VIII'console.log(makeKing('Louis')); // 'King Louis VIII' </code></pre><p>ECMAScript 6 之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的 ES6 写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值：</p><pre><code>function makeKing(name = 'Henry') {    return `King ${name} VIII`;}console.log(makeKing('Louis')); // 'King Louis VIII'console.log(makeKing()); // 'King Henry VIII' </code></pre><p>给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：</p><pre><code>function makeKing(name = 'Henry', numerals = 'VIII') {    return `King ${name} ${numerals}`;}console.log(makeKing()); // 'King Henry VIII'console.log(makeKing('Louis')); // 'King Louis VIII'console.log(makeKing(undefined, 'VI')); // 'King Henry VI' </code></pre><p>在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟 ES5 严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：</p><pre><code>function makeKing(name = 'Henry') {    name = 'Louis';    return `King ${arguments[0]}`;}console.log(makeKing()); // 'King undefined'console.log(makeKing('Louis')); // 'King Louis' </code></pre><p>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p><pre><code>let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI'];let ordinality = 0;function getNumerals() {    // 每次调用后递增    return romanNumerals[ordinality++];}function makeKing(name = 'Henry', numerals = getNumerals()) {    return `King ${name} ${numerals}`;}console.log(makeKing()); // 'King Henry I' console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI'console.log(makeKing()); // 'King Henry II'console.log(makeKing()); // 'King Henry III' </code></pre><p>函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</p><p>箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了：</p><pre><code>let makeKing = (name = 'Henry') =&gt; `King ${name}`;console.log(makeKing()); // King Henry </code></pre><h2 id="默认参数作用域与暂时性死区"><a href="#默认参数作用域与暂时性死区" class="headerlink" title="默认参数作用域与暂时性死区"></a>默认参数作用域与暂时性死区</h2><p>给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。来看下面的例子：</p><pre><code>function makeKing(name = 'Henry', numerals = 'VIII') {    return `King ${name} ${numerals}`;}console.log(makeKing()); // King Henry VIII </code></pre><p>这里的默认参数会按照定义它们的顺序依次被初始化。可以依照如下示例想象一下这个过程：</p><pre><code>function makeKing() {    let name = 'Henry';    let numerals = 'VIII';    return `King ${name} ${numerals}`;} </code></pre><p>因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。看下面这个例子：</p><pre><code>function makeKing(name = 'Henry', numerals = name) {    return `King ${name} ${numerals}`;}console.log(makeKing()); // King Henry Henry </code></pre><p>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。像这样就会抛出错误：</p><pre><code>// 调用时不传第一个参数会报错function makeKing(name = numerals, numerals = 'VIII') {    return `King ${name} ${numerals}`;}</code></pre><p>参数也存在于自己的作用域中，它们不能引用函数体的作用域：</p><pre><code>// 调用时不传第二个参数会报错function makeKing(name = 'Henry', numerals = defaultNumeral) {    let defaultNumeral = 'VIII';    return `King ${name} ${numerals}`;}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0023.html"/>
      <url>posts/a0023.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇: <strong><a href="a0022">函数(三) 理解参数</a></strong><br>本篇: <strong>函数(四) 没有重载</strong><br>下篇: <strong><a href="a0024">函数(五) 默认参数值</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h1><p>ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）不同就行。如前所述，ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。</p><p>如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：</p><pre><code>function addSomeNumber(num) {    return num + 100;}function addSomeNumber(num) {    return num + 200;}let result = addSomeNumber(100); // 300 </code></pre><p>这里，函数 addSomeNumber()被定义了两次。第一个版本给参数加 100，第二个版本加 200。最后一行调用这个函数时，返回了 300，因为第二个定义覆盖了第一个定义。</p><p>前面也提到过，可以通过检查参数的类型和数量，然后分别执行不同的逻辑来模拟函数重载。把函数名当成指针也有助于理解为什么 ECMAScript 没有函数重载。在前面的例子中，定义两个同名的函数显然会导致后定义的重写先定义的。而那个例子几乎跟下面这个是一样的：</p><pre><code>let addSomeNumber = function(num) {    return num + 100;};addSomeNumber = function(num) {    return num + 200;};let result = addSomeNumber(100); // 300 </code></pre><p>看这段代码应该更容易理解发生了什么。在创建第二个函数时，变量 addSomeNumber 被重写成保存第二个函数对象了</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0022.html"/>
      <url>posts/a0022.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇: <strong><a href="a0021">函数(二) 函数名</a></strong><br>本篇: <strong>函数(三) 理解参数</strong><br>下篇: <strong><a href="a0023">函数(四) 没有重载</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h1><p>ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。</p><p>之所以会这样，主要是因为 ECMAScript 函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。</p><p>arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是 arguments[ 0]，第二个参数是 arguments[1]）。而要确定传进来多少个参数，可以访问 arguments.length 属性。</p><p>在下面的例子中，sayHi()函数的第一个参数叫 name：</p><pre><code>function sayHi(name, message) {    console.log("Hello " + name + ", " + message);}</code></pre><p>可以通过 arguments[ 0]取得相同的参数值。因此，把函数重写成不声明参数也可以：</p><pre><code>function sayHi() {    console.log("Hello " + arguments[0] + ", " + arguments[1]);} </code></pre><p>在重写后的代码中，没有命名参数。name 和 message 参数都不见了，但函数照样可以调用。这就表明，ECMAScript 函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在ECMAScript 中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。</p><p>也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：</p><pre><code>function howManyArgs() {     console.log(arguments.length);}howManyArgs("string", 45); // 2howManyArgs(); // 0howManyArgs(12); // 1 </code></pre><p>这个例子分别打印出 2、0 和 1（按顺序）。既然如此，那么开发者可以想传多少参数就传多少参数。比如：</p><pre><code>function doAdd() {    if (arguments.length === 1) {        console.log(arguments[0] + 10);    } else if (arguments.length === 2) {        console.log(arguments[0] + arguments[1]);    }}doAdd(10); // 20doAdd(30, 20); // 50 </code></pre><p>这个函数 doAdd()在只传一个参数时会加 10，在传两个参数时会将它们相加，然后返回。因此doAdd(10)返回 20，而 doAdd(30,20)返回 50。虽然不像真正的函数重载那么明确，但这已经足以弥补 ECMAScript 在这方面的缺失了。</p><p>还有一个必须理解的重要方面，那就是 arguments 对象可以跟命名参数一起使用，比如：</p><pre><code>function doAdd(num1, num2) {    if (arguments.length === 1) {        console.log(num1 + 10);    } else if (arguments.length === 2) {        console.log(arguments[0] + num2);    }} </code></pre><p>arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。来看下面的例子：</p><pre><code>function doAdd(num1, num2) {    arguments[1] = 10;    console.log(arguments[0] + num2); }</code></pre><p>这个 doAdd()函数把第二个参数的值重写为 10。因为 arguments 对象的值会自动同步到对应的命名参数，所以修改 arguments[ 1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把 arguments[ 1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。</p><p>对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是 undefined。这就类似于定义了变量而没有初始化。比如，如果只给 doAdd()传了一个参数，那么 num2 的值就是 undefined</p><p>严格模式下，arguments 会有一些变化。首先，像前面那样给 arguments[1]赋值不会再影响 num2的值。就算把 arguments[ 1]设置为 10，num2 的值仍然还是传入的值。其次，在函数中尝试重写arguments 对象会导致语法错误。（代码也不会执行。）</p><h2 id="箭头函数中的参数"><a href="#箭头函数中的参数" class="headerlink" title="箭头函数中的参数"></a>箭头函数中的参数</h2><p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p><pre><code>function foo() {    console.log(arguments[0]);}foo(5); // 5let bar = () =&gt; {    console.log(arguments[0]);};bar(5); // ReferenceError: arguments is not defined </code></pre><p>虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数：</p><pre><code>function foo() {    let bar = () =&gt; {    console.log(arguments[0]); // 5    };    bar();}foo(5); </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0021.html"/>
      <url>posts/a0021.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇: <strong><a href="a0020">函数(一) 箭头函数</a></strong><br>本篇: <strong>函数(二) 函数名</strong><br>下篇: <strong><a href="a0022">函数(三) 理解参数</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h1><p>因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示：</p><pre><code>function sum(num1, num2) {    return num1 + num2;}console.log(sum(10, 10)); // 20let anotherSum = sum;console.log(anotherSum(10, 10)); // 20sum = null;console.log(anotherSum(10, 10)); // 20 </code></pre><p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum，并将它的值设置为等于 sum。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时，anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。把 sum 设置为 null之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题。</p><p>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。多数情况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称，也会如实显示成空字符串。如果它是使用 Function 构造函数创建的，则会标识成”anonymous”：</p><pre><code>function foo() {}let bar = function() {};let baz = () =&gt; {};console.log(foo.name); // fooconsole.log(bar.name); // barconsole.log(baz.name); // bazconsole.log((() =&gt; {}).name); //（空字符串）console.log((new Function()).name); // anonymous </code></pre><p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p><pre><code>function foo() {}console.log(foo.bind(null).name); // bound foolet dog = {    years: 1,    get age() {        return this.years;    },    set age(newAge) {        this.years = newAge;    }}let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age');console.log(propertyDescriptor.get.name); // get ageconsole.log(propertyDescriptor.set.name); // set age </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(八)</title>
      <link href="posts/a0020.html"/>
      <url>posts/a0020.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>上篇: <strong><a href="a0019">代理与反射(二) 代理捕获器与反射方法</a></strong><br>本篇: <strong>函数(一) 箭头函数</strong><br>下篇: <strong><a href="a0021">函数(二) 函数名</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><p>函数是ECMAScript中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，比如：</p><pre><code>function sum (num1, num2) {    return num1 + num2;}</code></pre><p>注意函数定义最后没有加分号。</p><p>另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：</p><pre><code>let sum = function(num1, num2) {    return num1 + num2;};  </code></pre><p>这里，代码定义了一个变量 sum 并将其初始化为一个函数。注意 function 关键字后面没有名称，因为不需要。这个函数可以通过变量 sum 来引用。注意这里的函数末尾是有分号的，与任何变量初始化语句一样。</p><p>还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示：</p><pre><code>let sum = (num1, num2) =&gt; {    return num1 + num2;}; </code></pre><p>最后一种定义函数的方式是使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：</p><pre><code>let sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐</code></pre><p>我们不推荐使用这种语法来定义函数，因为这段代码会被解释两次：第一次是将它当作常规ECMAScript 代码，第二次是解释传给构造函数的字符串。这显然会影响性能。不过，把函数想象为对象，把函数名想象为指针是很重要的。而上面这种语法很好地诠释了这些概念。</p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ECMAScript 6 新增了使用胖箭头（=&gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：</p><pre><code>let arrowSum = (a, b) =&gt; {    return a + b;};let functionExpressionSum = function(a, b) {    return a + b;};console.log(arrowSum(5, 8)); // 13console.log(functionExpressionSum(5, 8)); // 13 </code></pre><p>箭头函数简洁的语法非常适合嵌入函数的场景：</p><pre><code>let ints = [1, 2, 3];console.log(ints.map(function(i) { return i + 1; })); // [2, 3, 4]console.log(ints.map((i) =&gt; { return i + 1 })); // [2, 3, 4] </code></pre><p>如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：</p><pre><code>// 以下两种写法都有效let double = (x) =&gt; { return 2 * x; };let triple = x =&gt; { return 3 * x; };// 没有参数需要括号let getRandom = () =&gt; { return Math.random(); };// 多个参数需要括号let sum = (a, b) =&gt; { return a + b; };// 无效的写法：let multiply = a, b =&gt; { return a * b; }; </code></pre><p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：</p><pre><code>// 以下两种写法都有效，而且返回相应的值let double = (x) =&gt; { return 2 * x; };let triple = (x) =&gt; 3 * x;// 可以赋值let value = {};let setName = (x) =&gt; x.name = "Matt";setName(value);console.log(value.name); // "Matt"// 无效的写法：let multiply = (a, b) =&gt; return a * b; </code></pre><p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super 和new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水涨船高技术栈</title>
      <link href="posts/f0002.html"/>
      <url>posts/f0002.html</url>
      
        <content type="html"><![CDATA[<h1 id="水涨船高技术集"><a href="#水涨船高技术集" class="headerlink" title="水涨船高技术集"></a>水涨船高技术集</h1><p><strong>世上的事，最令人回味的，是始和终这俩端，善终者寡，善始者众</strong></p><hr><h2 id="在github上在线演示项目"><a href="#在github上在线演示项目" class="headerlink" title="在github上在线演示项目"></a>在github上在线演示项目</h2><h3 id="一、创建一个新的项目"><a href="#一、创建一个新的项目" class="headerlink" title="一、创建一个新的项目"></a>一、创建一个新的项目</h3><p>首先点击右上角+号创建一个新的项目</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125103923.png"></p><p>再根据自己的需求填写相应的项目名称及简介</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/20190111104913413.png"></p><p>完成以上两步我们已经成功创建了一个名为project的项目，接下来我们就需要将远程仓库clone到我们本地来。</p><p>可以新建一个文件夹</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125104815.png"></p><p>点击文件夹右击，进入 <code>Git Bash Here</code></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125105034.png"></p><p>输入以下内容： <code>git clone git@github.com:github名称/刚刚新建的仓库名.git</code></p><p>例如我的是：<code> git clone git@github.com:HcHh2019/Project.git</code></p><p>因为我已经建过一次了，所以提示出错</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125105529.png"></p><p>发一下别的博主正常图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125105824.png"></p><p>这事我们就会多一个Project的文件夹，</p><p>将终端切换到Project文件夹下。执行    cd Project/</p><p>此时发现我们是在master(或者是main主分支)主分支上。（当前是只有master/main分支的）</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125110121.png"></p><p>接下来我们创建一个新的gh-pages分支</p><p>执行   git checkout –orphan gh-pages</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201125110337.png"></p><p>此时本地gh-pages分支已经创建好了，并且已经切换到了gh-pages分支上了。</p><p>接下来我们创建一个YYZMusic.html并写上内容测试一下。</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/20190111110430979.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;我成功的演示啦&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后我们将代码push到远程仓库.</p><p>在终端中依次执行（此时是在gh-pages分支上</p><pre><code>git add .git commit -m "demo"git push -u origin gh-pages</code></pre><p>接下来就可以成功访问啦!</p><p>访问地址:https://用户名.github.io/项目名称/文件路径</p><p>例如我的访问地址为      <a href="https://hchh2019.github.io/Project/One/YYZMusic.html">https://HcHh2019.github.io/Project/One/YYZMusic.html</a></p><p>买了域名之后可以：  <a href="https://yanyanzio.top/Project/One/YYZMusic.html">https://yanyanzio.top/Project/One/YYZMusic.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 水涨船高技术集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水涨船高技术集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS权威指南第三版(一)</title>
      <link href="posts/b0001.html"/>
      <url>posts/b0001.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS权威指南第三版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(七)</title>
      <link href="posts/a0019.html"/>
      <url>posts/a0019.html</url>
      
        <content type="html"><![CDATA[<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。对刚刚接触这个主题的开发者而言，代理是一个比较模糊的概念，而且还夹杂着很多新术语。其实只要看几个例子，就很容易理解了。</p><p>上篇: <strong><a href="a0018">代理与反射(一) 代理基础</a></strong><br>本篇: <strong>代理与反射(二) 代理捕获器与反射方法</strong><br>下篇: <strong><a href="a0020">函数(一) 箭头函数</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(七)</title>
      <link href="posts/a0018.html"/>
      <url>posts/a0018.html</url>
      
        <content type="html"><![CDATA[<h1 id="代理与反射"><a href="#代理与反射" class="headerlink" title="代理与反射"></a>代理与反射</h1><p>ECMAScript 6 新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。对刚刚接触这个主题的开发者而言，代理是一个比较模糊的概念，而且还夹杂着很多新术语。其实只要看几个例子，就很容易理解了。</p><p>上篇: <strong><a href="a0017">对象、类与面向对象编程(四) 类</a></strong><br>本篇: <strong>代理与反射(一) 代理基础</strong><br>下篇: <strong><a href="a0019">代理与反射(二) 代理捕获器与反射方法</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h1><p>正如本章开头所介绍的，代理是目标对象的抽象。从很多方面看，代理在概念上类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。</p><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出 TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。</p><p>如下面的代码所示，在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理对象。</p><pre><code>const target = {    id: 'target'};const handler = {};const proxy = new Proxy(target, handler);// id 属性会访问同一个值console.log(target.id); // targetconsole.log(proxy.id); // target// 给目标属性赋值会反映在两个对象上// 因为两个对象访问的是同一个值target.id = 'foo';console.log(target.id); // fooconsole.log(proxy.id); // foo// 给代理属性赋值会反映在两个对象上// 因为这个赋值会转移到目标对象proxy.id = 'bar';console.log(target.id); // barconsole.log(proxy.id); // bar// hasOwnProperty()方法在两个地方// 都会应用到目标对象console.log(target.hasOwnProperty('id')); // trueconsole.log(proxy.hasOwnProperty('id')); // true// Proxy.prototype 是 undefined// 因此不能使用 instanceof 操作符console.log(target instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof checkconsole.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype 'undefined' in instanceof check// 严格相等可以用来区分代理和目标console.log(target === proxy); // false</code></pre><h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><p>使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p><p><strong>注意</strong> 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的<br>一个同步中断，可以暂停程序流，转而执行一段子例程，之后再返回原始程序流</p><p>例如，可以定义一个 get()捕获器，在 ECMAScript 操作以某种形式调用 get()时触发。下面的例子定义了一个 get()捕获器：</p><pre><code>const target = {    foo: 'bar'};const handler = {    // 捕获器在处理程序对象中以方法名为键    get() {        return 'handler override';    }};const proxy = new Proxy(target, handler); </code></pre><p>这样，当通过代理对象执行 get()操作时，就会触发定义的 get()捕获器。当然，get()不是<br>ECMAScript 对象可以调用的方法。这个操作在 JavaScript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[ property]、proxy.property 或 Object.create(proxy)[ property]等操作都会触发基本的 get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get()捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。</p><pre><code>const target = {    foo: 'bar'};const handler = {    // 捕获器在处理程序对象中以方法名为键    get() {        return 'handler override';    }};const proxy = new Proxy(target, handler);console.log(target.foo); // barconsole.log(proxy.foo); // handler overrideconsole.log(target['foo']); // barconsole.log(proxy['foo']); // handler overrideconsole.log(Object.create(target)['foo']); // barconsole.log(Object.create(proxy)['foo']); // handler override </code></pre><h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。</p><pre><code>const target = {    foo: 'bar'};const handler = {     get(trapTarget, property, receiver) {        console.log(trapTarget === target);        console.log(property);        console.log(receiver === proxy);    }};const proxy = new Proxy(target, handler);proxy.foo;// true// foo// true</code></pre><p>有了这些参数，就可以重建被捕获方法的原始行为：</p><pre><code>const target = {    foo: 'bar'};const handler = {    get(trapTarget, property, receiver) {        return trapTarget[property];    }};const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar </code></pre><p>所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。</p><p>处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射 API 也可以像下面这样定义出空代理对象：</p><pre><code>const target = {foo: 'bar'};const handler = {    get() {        return Reflect.get(...arguments);    }};const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar</code></pre><p>甚至还可以写得更简洁一些：</p><pre><code>const target = {    foo: 'bar'}; const handler = {    get: Reflect.get};const proxy = new Proxy(target, handler);console.log(proxy.foo); // barconsole.log(target.foo); // bar </code></pre><p>事实上，如果真想创建一个可以捕获所有方法，然后将每个方法转发给对应反射 API 的空代理，那么甚至不需要定义处理程序对象：</p><pre><code>const target = {    foo: 'bar'};const proxy = new Proxy(target, Reflect);console.log(proxy.foo); // barconsole.log(target.foo); // bar </code></pre><p>反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，下面的代码在某个属性被访问时，会对返回的值进行一番修饰：</p><pre><code>const target = {    foo: 'bar',    baz: 'qux'};const handler = {    get(trapTarget, property, receiver) {        let decoration = '';        if (property === 'foo') {            decoration = '!!!';        }        return Reflect.get(...arguments) + decoration;    }};const proxy = new Proxy(target, handler);console.log(proxy.foo); // bar!!!console.log(target.foo); // barconsole.log(proxy.baz); // quxconsole.log(target.baz); // qux </code></pre><h2 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h2><p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。</p><p>比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError：</p><pre><code>const target = {};Object.defineProperty(target, 'foo', {    configurable: false,    writable: false,    value: 'bar'});const handler = {    get() {        return 'qux';    }};const proxy = new Proxy(target, handler);console.log(proxy.foo);// TypeError</code></pre><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>有时候可能需要中断代理对象与目标对象之间的联系。对于使用 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。</p><p>Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError。</p><p>撤销函数和代理对象是在实例化时同时生成的：</p><pre><code>const target = {    foo: 'bar'};const handler = {    get() {        return 'intercepted';    }};const { proxy, revoke } = Proxy.revocable(target, handler);console.log(proxy.foo); // interceptedconsole.log(target.foo); // barrevoke();console.log(proxy.foo); // TypeError </code></pre><h2 id="实用反射-API"><a href="#实用反射-API" class="headerlink" title="实用反射 API"></a>实用反射 API</h2><p>某些情况下应该优先使用反射 API，这是有一些理由的。</p><ol><li><strong>反射 API 与对象 API</strong></li></ol><p>在使用反射 API 时，要记住：<br>(1) 反射 API 并不限于捕获处理程序；<br>(2) 大多数反射 API 方法在 Object 类型上有对应的方法。通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。</p><ol start="2"><li> <strong>状态标记</strong></li></ol><p>很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射 API 方法更有用。例如，可以使用反射API 对下面的代码进行重构：</p><pre><code>// 初始代码const o = {};try {    Object.defineProperty(o, 'foo', 'bar');    console.log('success');} catch(e) {    console.log('failure');} </code></pre><p>在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：</p><pre><code>// 重构后的代码const o = {};if(Reflect.defineProperty(o, 'foo', {value: 'bar'})) {    console.log('success');} else {    console.log('failure');} </code></pre><p>以下反射方法都会提供状态标记：</p><p> Reflect.defineProperty()<br> Reflect.preventExtensions()<br> Reflect.setPrototypeOf()<br> Reflect.set()<br> Reflect.deleteProperty()</p><ol start="3"><li>用一等函数替代操作符</li></ol><p>以下反射方法提供只有通过操作符才能完成的操作。</p><p> Reflect.get()：可以替代对象属性访问操作符。<br> Reflect.set()：可以替代=赋值操作符。<br> Reflect.has()：可以替代 in 操作符或 with()。<br> Reflect.deleteProperty()：可以替代 delete 操作符。<br> Reflect.construct()：可以替代 new 操作符。</p><ol start="4"><li>安全地应用函数</li></ol><p>在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：</p><p><code>Function.prototype.apply.call(myFunc, thisVal, argumentList);</code></p><p>这种可怕的代码完全可以使用 Reflect.apply 来避免：</p><p><code>Reflect.apply(myFunc, thisVal, argumentsList); </code></p><h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：</p><pre><code>const target = {    foo: 'bar'};const firstProxy = new Proxy(target, {    get() {        console.log('first proxy');        return Reflect.get(...arguments);    }});const secondProxy = new Proxy(firstProxy, {    get() {        console.log('second proxy');        return Reflect.get(...arguments);    }});console.log(secondProxy.foo);// second proxy// first proxy// bar </code></pre><h2 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h2><p>代理是在 ECMAScript 现有基础之上构建起来的一套新 API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript机制很好地协同。</p><h3 id="代理中的-this"><a href="#代理中的-this" class="headerlink" title="代理中的 this"></a>代理中的 this</h3><p>代理潜在的一个问题来源是 this 值。我们知道，方法中的 this 通常指向调用这个方法的对象：</p><pre><code>const target = {    thisValEqualsProxy() {        return this === proxy;    }}const proxy = new Proxy(target, {});console.log(target.thisValEqualsProxy()); // falseconsole.log(proxy.thisValEqualsProxy()); // true</code></pre><p>从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如 proxy.outerMethod()，而这个<br>方法进而又会调用另一个方法，如 this.innerMethod()，实际上都会调用 proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题。</p><p>还记得第 4 章中通过 WeakMap 保存私有变量的例子吧，以下是它的简化版：</p><pre><code>const wm = new WeakMap();class User {    constructor(userId) {        wm.set(this, userId);    }    set id(userId) {        wm.set(this, userId);    }    get id() {        return wm.get(this);    }} </code></pre><p>由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：</p><pre><code>const user = new User(123);console.log(user.id); // 123const userInstanceProxy = new Proxy(user, {});console.log(userInstanceProxy.id); // undefined </code></pre><p>这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代理的实例就会以代理实例作为 WeakMap 的键了：</p><pre><code>const UserClassProxy = new Proxy(User, {});const proxyUser = new UserClassProxy(456);console.log(proxyUser.id); </code></pre><h3 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h3><p>代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。</p><p>一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[ NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：</p><pre><code>const target = new Date();const proxy = new Proxy(target, {});console.log(proxy instanceof Date); // trueproxy.getDate(); // TypeError: 'this' is not a Date object </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试专题</title>
      <link href="posts/g0001.html"/>
      <url>posts/g0001.html</url>
      
        <content type="html"><![CDATA[<h1 id="面试专题"><a href="#面试专题" class="headerlink" title="面试专题"></a>面试专题</h1><p><strong>人生得也罢，失也罢，成也罢，败也吧，只是心灵的那泓清泉不能没有月辉</strong></p><h2 id="HTML篇-更新至3"><a href="#HTML篇-更新至3" class="headerlink" title="HTML篇(更新至3)"></a>HTML篇(更新至3)</h2><ol><li><strong><code>DOCTYPE</code>有什么作用？标准模式与混杂模式如何区分？它们有何意义？</strong></li></ol><p>告诉浏览器使用哪些版本的HTML规范来渲染文档。<code>DOCTYPE</code>不存在或形式不正确会导致HTML文档混乱模式呈现。<br>标准模式以浏览器支持的最高标准运行；混杂模式中页面是一种比较宽松的向后兼容的方法显示。</p><ol start="2"><li><strong>HTML5为什么只需要写<code>&lt;!DOCTYPE HTML&gt;</code></strong></li></ol><p>HTML5不基于SGML，因此不需要对DTD进行引用，但需要DOCTYPE来规范浏览器行为。<br>HTML4.0基于SGML，所以需要引用DTD，才能告诉浏览器文档所使用的文档类型。</p><ol start="3"><li><strong>行内元素有哪些？块级元素有哪些？空元素有哪些？</strong></li></ol><p>行内元素: a span img input select<br>块级元素: div ul ol li dl dt dd h1~h6 p<br>空元素: <code>&lt;br&gt;</code> <code>&lt;hr&gt;</code> <code>&lt;link&gt;</code> <code>&lt;meta&gt;</code></p><ol start="4"><li><strong>在页面导入样式时，使用link与使用@import有什么区别？</strong></li></ol><p>相同的地方都是外部引用CSS，区别:</p><ol><li><p>link是xhtml标签，除了加载css外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS</p></li><li><p>link引用CSS时候，页面载入时同时加载；@import需要在页面完全加载以后加载，而且@import被引用的CSS会等到引用它的CSS文件被加载完才加载</p></li><li><p>link是xhtml标签，无兼容问题；@import是在css2.1提出来的，低版本的浏览器不支持</p></li><li><p>link支持使用javascript控制去改变样式，而@import不支持</p></li><li><p>link方式的样式的权重高于@import的权重</p></li><li><p>import在html使用时候需要<code>&lt;style type="text/css"&gt;</code>标签</p></li><li><p><strong>无样式内容闪烁（FOUC）Flash of Unstyle Content</strong></p></li></ol><p>@import导入CSS文件会等到文档加载完后再加载CSS样式表。因此，在页面DOM加载完成到CSS导入完成之间会有一段时间页面上的内容是没有样式的。</p><p>解决方法：使用link标签加载CSS样式文件。因为link是顺序加载的，这样页面会等到CSS下载完之后再下载HTML文件，这样先布局好，就不会出现FOUC问题</p><ol start="6"><li>介绍一下你对浏览器内核的理解？</li></ol><p>主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。</p><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。<br>JS引擎：解析和执行javascript来实现网页的动态效果。</p><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</p><ol start="7"><li>简述一下你对HTML语义化的理解？</li></ol><p><strong>1</strong> 去掉或丢失样式的时候能够让页面呈现出清晰的结构。<br><strong>2</strong> 有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。<br><strong>3</strong> 方便其它设备解析。<br><strong>4</strong> 便于团队开发和维护，语义化根据可读性。</p><ol start="8"><li>HTML5的文件离线储存怎么使用，工作原理是什么？</li></ol><p>在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。</p><p>在页面头部加入manifest属性<br><code>&lt;html manifest='cache.manifest'&gt;</code></p><ol start="9"><li> cookies，sessionStorage和localStorage的区别？</li></ol><p>共同点：都是保存在浏览器端，且是同源的。</p><p>区别：<br><strong>1</strong> cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。<br><strong>2</strong> 存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。<br><strong>3</strong> 数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。<br><strong>4</strong> 作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0017.html"/>
      <url>posts/a0017.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0016">对象、类与面向对象编程(三) 继承</a></strong><br>本篇: <strong>对象、类与面向对象编程(四) 类</strong><br>下篇: <strong><a href="a0018">代理与反射(一) 代理基础</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号：</p><pre><code>// 类声明class Person {}// 类表达式const Animal = class {}; </code></pre><p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能：</p><pre><code>console.log(FunctionExpression); // undefinedvar FunctionExpression = function() {};console.log(FunctionExpression); // function() {}console.log(FunctionDeclaration); // FunctionDeclaration() {}function FunctionDeclaration() {}console.log(FunctionDeclaration); // FunctionDeclaration() {}console.log(ClassExpression); // undefinedvar ClassExpression = class {};console.log(ClassExpression); // class {}console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not definedclass ClassDeclaration {}console.log(ClassDeclaration); // class ClassDeclaration {} </code></pre><p>另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制：</p><pre><code>function FunctionDeclaration() {}    class ClassDeclaration {}}console.log(FunctionDeclaration); // FunctionDeclaration() {}console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined </code></pre><h3 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h3><p>与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例（比如，通过 class Foo {}创建实例 foo）：  </p><pre><code>// 空类定义，有效class Foo {}// 有构造函数的类，有效class Bar {    constructor() {}}// 有获取函数的类，有效class Baz {    get myBaz() {}}// 有静态方法的类，有效class Qux {    static myQux() {}} </code></pre><p>类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p><pre><code>let Person = class PersonName {    identify() {        console.log(Person.name, PersonName.name);    }}let p = new Person();p.identify(); // PersonName PersonNameconsole.log(Person.name); // PersonNameconsole.log(PersonName); // ReferenceError: PersonName is not defined </code></pre><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，JavaScript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。</p><p>使用 new 调用类的构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[ Prototype]]指针被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p>来看下面的例子：</p><pre><code>class Animal {}class Person {    constructor() {        console.log('person ctor');    }}class Vegetable {    constructor() {        this.color = 'orange';    }}let a = new Animal();let p = new Person(); // person ctorlet v = new Vegetable();console.log(v.color); // orange</code></pre><p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的：</p><pre><code>class Person {    constructor(name) {        console.log(arguments.length);        this.name = name || null;    }}let p1 = new Person; // 0console.log(p1.name); // nulllet p2 = new Person(); // 0console.log(p2.name); // nulllet p3 = new Person('Jake'); // 1console.log(p3.name); // Jake </code></pre><p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p><pre><code>class Person {    constructor(override) {        this.foo = 'foo';        if (override) {            return {                bar: 'bar'            };        }       }}let p1 = new Person(),    p2 = new Person(true);console.log(p1); // Person{ foo: 'foo' }console.log(p1 instanceof Person); // trueconsole.log(p2); // { bar: 'bar' }console.log(p2 instanceof Person); // false </code></pre><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符。而普通构造函数如果不使用 new 调用，那么就会以全局的 this（通常是 window）作为内部对象。调用类构造函数时如果忘了使用 new 则会抛出错误：</p><pre><code>function Person() {}class Animal {}// 把 window 作为 this 来构建实例let p = Person();let a = Animal();// TypeError: class constructor Animal cannot be invoked without 'new' </code></pre><p>类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法（但作为类构造函数，仍然要使用 new 调用）。因此，实例化之后可以在实例上引用它：</p><pre><code>class Person {}// 使用类创建一个新实例let p1 = new Person();p1.constructor();// TypeError: Class constructor Person cannot be invoked without 'new'// 使用对类构造函数的引用创建一个新实例let p2 = new p1.constructor(); </code></pre><h3 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h3><p>ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类之后，通过 typeof 操作符检测类标识符，表明它是一个函数：</p><pre><code>class Person {}console.log(Person); // class Person {}console.log(typeof Person); // function </code></pre><p>类标识符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身：</p><pre><code>class Person{}console.log(Person.prototype); // { constructor: f() }console.log(Person === Person.prototype.constructor); // true </code></pre><p>与普通构造函数一样，可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中：</p><pre><code>class Person {}let p = new Person();console.log(p instanceof Person); // true </code></pre><p>由此可知，可以使用 instanceof 操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例。只不过此时的类构造函数要使用类标识符</p><p>如前所述，类本身具有与普通构造函数一样的行为。在类的上下文中，类本身在使用 new 调用时就会被当成构造函数。重点在于，类中定义的 constructor 方法不会被当成构造函数，在对它使用instanceof 操作符时会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转：</p><pre><code>class Person {}let p1 = new Person();console.log(p1.constructor === Person); // trueconsole.log(p1 instanceof Person); // trueconsole.log(p1 instanceof Person.constructor); // falselet p2 = new Person.constructor();console.log(p2.constructor === Person); // falseconsole.log(p2 instanceof Person); // falseconsole.log(p2 instanceof Person.constructor); // true </code></pre><p>类是 JavaScript 的一等公民，因此可以像其他对象或函数引用一样把类作为参数传递：</p><pre><code>// 类可以像函数一样在任何地方定义，比如在数组中let classList = [    class {        constructor(id) {            this.id_ = id;            console.log(`instance ${this.id_}`);        }    }];function createInstance(classDefinition, id) {    return new classDefinition(id);}let foo = createInstance(classList[0], 3141); // instance 3141 </code></pre><p>与立即调用函数表达式相似，类也可以立即实例化：</p><pre><code>// 因为是一个类表达式，所以类名是可选的let p = new class Foo {     console.log(x);}}('bar'); // barconsole.log(p); // Foo {} </code></pre><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><h3 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h3><p>每次通过new调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。</p><p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：</p><pre><code>class Person {    constructor() {        // 这个例子先使用对象包装类型定义一个字符串        // 为的是在下面测试两个对象的相等性        this.name = new String('Jack');        this.sayName = () =&gt; console.log(this.name);        this.nicknames = ['Jake', 'J-Dog']    }}let p1 = new Person(),    p2 = new Person();p1.sayName(); // Jackp2.sayName(); // Jackconsole.log(p1.name === p2.name); // falseconsole.log(p1.sayName === p2.sayName); // falseconsole.log(p1.nicknames === p2.nicknames); // falsep1.name = p1.nicknames[0];p2.name = p2.nicknames[1];p1.sayName(); // Jakep2.sayName(); // J-Dog</code></pre><h3 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h3><p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p><pre><code>class Person {    constructor() {        // 添加到 this 的所有内容都会存在于不同的实例上        this.locate = () =&gt; console.log('instance');    }     // 在类块中定义的所有内容都会定义在类的原型上    locate() {        console.log('prototype');    }}let p = new Person();p.locate(); // instancePerson.prototype.locate(); // prototype </code></pre><p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</p><pre><code>class Person {    name: 'Jake'}// Uncaught SyntaxError: Unexpected token </code></pre><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：</p><pre><code>const symbolKey = Symbol('symbolKey');class Person {    stringKey() {        console.log('invoked stringKey');    }    [symbolKey]() {        console.log('invoked symbolKey');    }    ['computed' + 'Key']() {        console.log('invoked computedKey');    }}let p = new Person();p.stringKey(); // invoked stringKeyp[symbolKey](); // invoked symbolKeyp.computedKey(); // invoked computedKey </code></pre><p>类定义也支持获取和设置访问器。语法与行为跟普通对象一样：</p><pre><code>class Person {    set name(newName) {        this.name_ = newName;    }    get name() {        return this.name_;    }}let p = new Person();p.name = 'Jake';console.log(p.name); // Jake </code></pre><h3 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h3><p>可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。</p><p>静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身。其他所有约定跟原型成员一样：</p><pre><code>class Person {    constructor() {        // 添加到 this 的所有内容都会存在于不同的实例上        this.locate = () =&gt; console.log('instance', this);    }    // 定义在类的原型对象上    locate() {        console.log('prototype', this);    }    // 定义在类本身上    static locate() {        console.log('class', this);    }}let p = new Person();p.locate(); // instance, Person {}Person.prototype.locate(); // prototype, {constructor: ... }Person.locate(); // class, class Person {} </code></pre><p>静态类方法非常适合作为实例工厂：</p><pre><code>class Person {    constructor(age) {        this.age_ = age;    }    sayAge() {        console.log(this.age_);    }    static create() {        // 使用随机年龄创建并返回一个 Person 实例        return new Person(Math.floor(Math.random()*100));    }}console.log(Person.create()); // Person { age_: ... }</code></pre><h3 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h3><p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：</p><pre><code>class Person {    sayName() {        console.log(`${Person.greeting} ${this.name}`);    }}// 在类上定义数据成员Person.greeting = 'My name is'; // 在原型上定义数据成员Person.prototype.name = 'Jake';let p = new Person();p.sayName(); // My name is Jake </code></pre><h3 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h3><p>类定义语法支持在原型和类本身上定义生成器方法：</p><pre><code>class Person {    // 在原型上定义生成器方法    *createNicknameIterator() {        yield 'Jack';        yield 'Jake';        yield 'J-Dog';    }    // 在类上定义生成器方法    static *createJobIterator() {        yield 'Butcher';        yield 'Baker';        yield 'Candlestick maker';    }}let jobIter = Person.createJobIterator();console.log(jobIter.next().value); // Butcherconsole.log(jobIter.next().value); // Bakerconsole.log(jobIter.next().value); // Candlestick makerlet p = new Person();let nicknameIter = p.createNicknameIterator();console.log(nicknameIter.next().value); // Jackconsole.log(nicknameIter.next().value); // Jakeconsole.log(nicknameIter.next().value); // J-Dog </code></pre><p>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象：</p><pre><code>class Person {    constructor() {        this.nicknames = ['Jack', 'Jake', 'J-Dog'];    }    *[Symbol.iterator]() {        yield *this.nicknames.entries();    }}let p = new Person();for (let [idx, nickname] of p) {    console.log(nickname);} // Jack// Jake// J-Dog </code></pre><p>也可以只返回迭代器实例：</p><pre><code>class Person {    constructor() {        this.nicknames = ['Jack', 'Jake', 'J-Dog'];    }    [Symbol.iterator]() {        return this.nicknames.entries();    }}let p = new Person();for (let [idx, nickname] of p) {    console.log(nickname);}// Jack// Jake// J-Dog </code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript 6 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p><h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><p>ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[ Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数</p><pre><code>class Vehicle {}// 继承类class Bus extends Vehicle {}let b = new Bus();console.log(b instanceof Bus); // trueconsole.log(b instanceof Vehicle); // truefunction Person() {}// 继承普通构造函数class Engineer extends Person {}let e = new Engineer();console.log(e instanceof Engineer); // trueconsole.log(e instanceof Person); // true </code></pre><p>派生类都会通过原型链访问到类和原型上定义的方法。this 的值会反映调用相应方法的实例或者类：</p><pre><code>class Vehicle {    identifyPrototype(id) {        console.log(id, this);    }     static identifyClass(id) {        console.log(id, this);    }}class Bus extends Vehicle {}let v = new Vehicle();let b = new Bus();b.identifyPrototype('bus'); // bus, Bus {}v.identifyPrototype('vehicle'); // vehicle, Vehicle {}Bus.identifyClass('bus'); // bus, class Bus {}Vehicle.identifyClass('vehicle'); // vehicle, class Vehicle {} </code></pre><p><strong>注意</strong> extends 关键字也可以在类表达式中使用，因此 let Bar = class extends Foo {}是有效的语法。</p><h3 id="构造函数、HomeObject-和-super"><a href="#构造函数、HomeObject-和-super" class="headerlink" title="构造函数、HomeObject 和 super()"></a>构造函数、HomeObject 和 super()</h3><p>派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造数。</p><pre><code>class Vehicle {    constructor() {        this.hasEngine = true;    }}class Bus extends Vehicle {    constructor() {        // 不要在调用 super()之前引用 this，否则会抛出 ReferenceError        super(); // 相当于 super.constructor()        console.log(this instanceof Vehicle); // true        console.log(this); // Bus { hasEngine: true }    }}new Bus(); </code></pre><p>在静态方法中可以通过 super 调用继承的类上定义的静态方法：</p><pre><code>class Vehicle {    static identify() {        console.log('vehicle');    }}class Bus extends Vehicle {    static identify() {        super.identify();    }}Bus.identify(); // vehicle </code></pre><p><strong>注意</strong> ES6 给类构造函数和静态方法添加了内部特性[[ HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内部访问。super 始终会定义为[[ HomeObject]]的原型。</p><p>在使用 super 时要注意几个问题。</p><ol><li><p>super 只能在派生类构造函数和静态方法中使用。</p><p> class Vehicle {</p><pre><code> constructor() {     super();     // SyntaxError: 'super' keyword unexpected }</code></pre><p> }</p></li><li><p>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法。</p><p> class Vehicle {}</p><p> class Bus extends Vehicle {</p><pre><code> constructor() {     console.log(super);     // SyntaxError: 'super' keyword unexpected here }</code></pre><p> }</p></li><li><p>调用 super()会调用父类构造函数，并将返回的实例赋值给 this。</p><p> class Vehicle {}</p><p> class Bus extends Vehicle {</p><pre><code> constructor() {     super();     console.log(this instanceof Vehicle); }</code></pre><p> }<br> new Bus(); // true</p></li><li><p>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</p><p> class Vehicle {</p><pre><code> constructor(licensePlate) {     this.licensePlate = licensePlate; }</code></pre><p> }</p><p> class Bus extends Vehicle {</p><pre><code> constructor(licensePlate) {     super(licensePlate); }</code></pre><p> }</p><p> console.log(new Bus(‘1337H4X’)); // Bus { licensePlate: ‘1337H4X’ }</p></li><li><p>如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数。</p><p> class Vehicle {</p><pre><code> constructor(licensePlate) {     this.licensePlate = licensePlate; }</code></pre><p> }</p><p> class Bus extends Vehicle {}</p><p> console.log(new Bus(‘1337H4X’)); // Bus { licensePlate: ‘1337H4X’ }</p></li><li><p>在类构造函数中，不能在调用 super()之前引用 this。</p><p> class Vehicle {}</p><p> class Bus extends Vehicle {</p><pre><code> constructor() {     console.log(this); }</code></pre><p> }</p><p> new Bus();<br> // ReferenceError: Must call super constructor in derived class<br> // before accessing ‘this’ or returning from derived constructor</p></li><li><p>如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。</p><p> class Vehicle {}</p><p> class Car extends Vehicle {}</p><p> class Bus extends Vehicle {</p><pre><code> constructor() {     super(); }</code></pre><p> }</p><p> class Van extends Vehicle {</p><pre><code> constructor() {     return {}; }</code></pre><p> }</p><p> console.log(new Car()); // Car {}<br> console.log(new Bus()); // Bus {}<br> console.log(new Van()); // {} </p></li></ol><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法 ，但通过 new.target 也很容易实现。new.target 保存通过 new 关键字调用的类或函数。通过在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化：</p><pre><code>// 抽象基类class Vehicle {    constructor() {        console.log(new.target);        if (new.target === Vehicle) {            throw new Error('Vehicle cannot be directly instantiated');         }    }}// 派生类class Bus extends Vehicle {}new Bus(); // class Bus {}new Vehicle(); // class Vehicle {}// Error: Vehicle cannot be directly instantiated </code></pre><p>另外，通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法：</p><pre><code>// 抽象基类class Vehicle {    constructor() {        if (new.target === Vehicle) {            throw new Error('Vehicle cannot be directly instantiated');        }        if (!this.foo) {            throw new Error('Inheriting class must define foo()');        }        console.log('success!');    }}// 派生类class Bus extends Vehicle {    foo() {}}// 派生类class Van extends Vehicle {}new Bus(); // success!new Van(); // Error: Inheriting class must define foo()</code></pre><h3 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h3><p>ES6 类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型：</p><pre><code>class SuperArray extends Array {    shuffle() {        // 洗牌算法        for (let i = this.length - 1; i &gt; 0; i--) {            const j = Math.floor(Math.random() * (i + 1));            [this[i], this[j]] = [this[j], this[i]];        }    }}let a = new SuperArray(1, 2, 3, 4, 5);console.log(a instanceof Array); // trueconsole.log(a instanceof SuperArray); // true console.log(a); // [1, 2, 3, 4, 5]a.shuffle();console.log(a); // [3, 1, 4, 5, 2]</code></pre><p>有些内置类型的方法会返回新实例。默认情况下，返回实例的类型与原始实例的类型是一致的：</p><pre><code>class SuperArray extends Array {}let a1 = new SuperArray(1, 2, 3, 4, 5);let a2 = a1.filter(x =&gt; !!(x%2))console.log(a1); // [1, 2, 3, 4, 5]console.log(a2); // [1, 3, 5]console.log(a1 instanceof SuperArray); // trueconsole.log(a2 instanceof SuperArray); // true </code></pre><p>如果想覆盖这个默认行为，则可以覆盖 Symbol.species 访问器，这个访问器决定在创建返回的实例时使用的类：</p><pre><code>class SuperArray extends Array {    static get [Symbol.species]() {        return Array;    }}let a1 = new SuperArray(1, 2, 3, 4, 5);let a2 = a1.filter(x =&gt; !!(x%2))console.log(a1); // [1, 2, 3, 4, 5]console.log(a2); // [1, 3, 5]console.log(a1 instanceof SuperArray); // trueconsole.log(a2 instanceof SuperArray); // false </code></pre><h3 id="类混入"><a href="#类混入" class="headerlink" title="类混入"></a>类混入</h3><p>把不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。</p><p><strong>注意</strong> Object.assign()方法是为了混入对象行为而设计的。只有在需要混入类的行为时才有必要自己实现混入表达式。如果只是需要混入多个对象的属性，那么使用Object.assign()就可以了。</p><p>在下面的代码片段中，extends 关键字后面是一个 JavaScript 表达式。任何可以解析为一个类或一个构造函数的表达式都是有效的。这个表达式会在求值类定义时被求值：</p><pre><code>class Vehicle {}function getParentClass() {    console.log('evaluated expression');    return Vehicle;}class Bus extends getParentClass() {}// 可求值的表达式</code></pre><p>混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类。如果 Person 类需要组合 A、B、C，则需要某种机制实现 B 继承 A，C 继承 B，而 Person再继承 C，从而把 A、B、C 组合到这个超类中。实现这种模式有不同的策略。</p><p>一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式：</p><pre><code>class Vehicle {}let FooMixin = (Superclass) =&gt; class extends Superclass {    foo() {        console.log('foo');    }};let BarMixin = (Superclass) =&gt; class extends Superclass {    bar() {        console.log('bar');    }};let BazMixin = (Superclass) =&gt; class extends Superclass {    baz() {        console.log('baz');    }};class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}let b = new Bus();b.foo(); // foob.bar(); // barb.baz(); // baz </code></pre><p>通过写一个辅助函数，可以把嵌套调用展开：</p><pre><code>class Vehicle {}let FooMixin = (Superclass) =&gt; class extends Superclass {    foo() {        console.log('foo');    }};let BarMixin = (Superclass) =&gt; class extends Superclass {    bar() {        console.log('bar');    }};let BazMixin = (Superclass) =&gt; class extends Superclass {    baz() {        console.log('baz');    }};function mix(BaseClass, ...Mixins) {    return Mixins.reduce((accumulator, current) =&gt; current(accumulator), BaseClass);}class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {}let b = new Bus();b.foo(); // foob.bar(); // barb.baz(); // baz </code></pre><p><strong>注意</strong> 很多 JavaScript 框架（特别是 React）已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来，但不使用继承）</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0016.html"/>
      <url>posts/a0016.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0015">对象、类与面向对象编程(二) 创建对象</a></strong><br>本篇: <strong>对象、类与面向对象编程(三) 继承</strong><br>下篇: <strong><a href="a0017">对象、类与面向对象编程(四) 类</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在 ECMAScript 中是不可能的，因为函数没有签名。实现继承是 ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p><p>实现原型链涉及如下代码模式：</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;};function SubType() {    this.subproperty = false;}// 继承 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function () {     return this.subproperty;};let instance = new SubType();console.log(instance.getSuperValue()); // true </code></pre><p>以上代码定义了两个类型：SuperType 和 SubType。这两个类型分别定义了一个属性和一个方法。这两个类型的主要区别是 SubType 通过创建 SuperType 的实例并将其赋值给自己的原型 SubTtype.prototype 实现了对 SuperType 的继承。这个赋值重写了 SubType 最初的原型，将其替换为SuperType 的实例。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype。这样实现继承之后，代码紧接着又给 SubType.prototype，也就是这个 SuperType 的实例添加了一个新方法。最后又创建了 SubType 的实例并调用了它继承的 getSuperValue()方法。</p><p>这个例子中实现继承的关键，是 SubType 没有使用默认原型，而是将其替换成了一个新的对象。这个新的对象恰好是 SuperType 的实例。这样一来，SubType 的实例不仅能从 SuperType 的实例中继承属性和方法，而且还与 SuperType 的原型挂上了钩。于是 instance（通过内部的[[ Prototype]]）指向SubType.prototype，而 SubType.prototype（作为 SuperType 的实例又通过内部的[[ Prototype]]）指向 SuperType.prototype。注意，getSuperValue()方法还在 SuperType.prototype 对象上，而 property 属性则在 SubType.prototype 上。这是因为 getSuperValue()是一个原型方法，而property 是一个实例属性。SubType.prototype 现在是 SuperType 的一个实例，因此 property才会存储在它上面。还要注意，由于 SubType.prototype 的 constructor 属性被重写为指向SuperType，所以 instance.constructor 也指向 SuperType。</p><p>原型链扩展了前面描述的原型搜索机制。我们知道，在读取实例上的属性时，首先会在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型。在通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型。对前面的例子而言，调用 instance.getSuperValue()经过了 3 步搜索：instance、SubType.prototype 和 SuperType.prototype，最后一步才找到这个方法。对属性和方法的搜索会一直持续到原型链的末端。</p><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实<br>现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向<br>Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf()在内的所有默认方法的原因。</p><p>SubType 继承 SuperType，而 SuperType 继承 Object。在调用 instance.toString()时，实际上调用的是保存在 Object.prototype 上的方法。</p><h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。如下例所示：</p><pre><code>console.log(instance instanceof Object); // trueconsole.log(instance instanceof SuperType); // trueconsole.log(instance instanceof SubType); // true</code></pre><p>从技术上讲，instance 是 Object、SuperType 和 SubType 的实例，因为 instance 的原型链中包含这些构造函数的原型。结果就是 instanceof 对所有这些构造函数都返回 true。</p><p>确定这种关系的第二种方式是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，如下例所示，只要原型链中包含这个原型，这个方法就返回 true：</p><pre><code>console.log(Object.prototype.isPrototypeOf(instance)); // trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); // trueconsole.log(SubType.prototype.isPrototypeOf(instance)); // true</code></pre><h3 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h3><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。来看下面的例子：</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;};function SubType() {    this.subproperty = false;}// 继承 SuperTypeSubType.prototype = new SuperType();// 新方法SubType.prototype.getSubValue = function () {    return this.subproperty;};// 覆盖已有的方法SubType.prototype.getSuperValue = function () {    return false;};let instance = new SubType();console.log(instance.getSuperValue()); // false </code></pre><p>在上面的代码中，加粗的部分涉及两个方法。第一个方法 getSubValue()是 SubType 的新方法，而第二个方法 getSuperValue()是原型链上已经存在但在这里被遮蔽的方法。后面在 SubType 实例上调用 getSuperValue()时调用的是这个方法。而 SuperType 的实例仍然会调用最初的方法。重点在于上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的。</p><p>另一个要理解的重点是，以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。下面是一个例子：</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;};function SubType() {    this.subproperty = false;} // 继承 SuperTypeSubType.prototype = new SuperType();// 通过对象字面量添加新方法，这会导致上一行无效SubType.prototype = {    getSubValue() {        return this.subproperty;    },    someOtherMethod() {        return false;    }};let instance = new SubType();console.log(instance.getSuperValue()); // 出错！</code></pre><p>在这段代码中，子类的原型在被赋值为 SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。因此之前的原型链就断了。SubType和 SuperType 之间也没有关系了。</p><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题：</p><pre><code>function SuperType() {    this.colors = ["red", "blue", "green"];}function SubType() {}// 继承 SuperTypeSubType.prototype = new SuperType();let instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors); // "red,blue,green,black"let instance2 = new SubType();console.log(instance2.colors); // "red,blue,green,black" </code></pre><p>在这个例子中，SuperType 构造函数定义了一个 colors 属性，其中包含一个数组（引用值）。每个 SuperType 的实例都会有自己的 colors 属性，包含自己的数组。但是，当 SubType 通过原型继承SuperType 后，SubType.prototype 变成了 SuperType 的一个实例，因而也获得了自己的 colors属性。这类似于创建了 SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会共享这个 colors 属性。这一点通过 instance1.colors 上的修改也能反映到 instance2.colors上就可以看出来。</p><p>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和 call()方法以新创建的对象为上下文执行构造函数。来看下面的例子：</p><pre><code>function SuperType() {    this.colors = ["red", "blue", "green"];}function SubType() {    // 继承 SuperType    SuperType.call(this);}let instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors); // "red,blue,green,black"let instance2 = new SubType();console.log(instance2.colors); // "red,blue,green" </code></pre><p>示例中加粗的代码展示了盗用构造函数的调用。通过使用 call()（或 apply()）方法，SuperType构造函数在为 SubType 的实例创建的新对象的上下文中执行了。这相当于新的 SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的 colors 属性。</p><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。来看下面的例子：</p><pre><code>function SuperType(name){    this.name = name;}function SubType() {    // 继承 SuperType 并传参    SuperType.call(this, "Nicholas");    // 实例属性    this.age = 29;}let instance = new SubType();console.log(instance.name); // "Nicholas";console.log(instance.age); // 29 </code></pre><p>在这个例子中，SuperType 构造函数接收一个参数 name，然后将它赋值给一个属性。在 SubType构造函数中调用 SuperType 构造函数时传入这个参数，实际上会在 SubType 的实例上定义 name 属性。为确保 SuperType 构造函数不会覆盖 SubType 定义的属性，可以在调用父类构造函数之后再给子类实例添加额外的属性。</p><h3 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h3><p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。来看下面的例子：</p><pre><code>function SuperType(name){    this.name = name;    this.colors = ["red", "blue", "green"];}SuperType.prototype.sayName = function() {    console.log(this.name);};function SubType(name, age){    // 继承属性    SuperType.call(this, name);    this.age = age;}// 继承方法SubType.prototype = new SuperType();SubType.prototype.sayAge = function() {    console.log(this.age);};let instance1 = new SubType("Nicholas", 29);instance1.colors.push("black");console.log(instance1.colors); // "red,blue,green,black"instance1.sayName(); // "Nicholas";instance1.sayAge(); // 29let instance2 = new SubType("Greg", 27);console.log(instance2.colors); // "red,blue,green"instance2.sayName(); // "Greg";instance2.sayAge(); // 27 </code></pre><p>在这个例子中，SuperType 构造函数定义了两个属性，name 和 colors，而它的原型上也定义了一个方法叫 sayName()。SubType 构造函数调用了 SuperType 构造函数，传入了 name 参数，然后又定义了自己的属性 age。此外，SubType.prototype 也被赋值为 SuperType 的实例。原型赋值之后，又在这个原型上添加了新方法 sayAge()。这样，就可以创建两个 SubType 实例，让这两个实例都有自己的属性，包括 colors，同时还共享相同的方法。</p><p>组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><pre><code>let person = {    name: "Nicholas",    friends: ["Shelby", "Court", "Van"]};let anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");let yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");console.log(person.friends); // "Shelby,Court,Van,Rob,Barbie" </code></pre><p>在这个例子中，person 对象定义了另一个对象也应该共享的信息，把它传给 object()之后会返回一个新对象。这个新对象的原型是 person，意味着它的原型上既有原始值属性又有引用值属性。这也意味着 person.friends 不仅是person 的属性，也会跟 anotherPerson 和 yetAnotherPerson 共享。这里实际上克隆了两个 person。</p><p>ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，Object.create()与这里的 object()方法效果相同：</p><pre><code>let person = {    name: "Nicholas",    friends: ["Shelby", "Court", "Van"]};let anotherPerson = Object.create(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");let yetAnotherPerson = Object.create(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");console.log(person.friends); // "Shelby,Court,Van,Rob,Barbie" </code></pre><p>Object.create()的第二个参数与 Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：</p><pre><code>let person = {    name: "Nicholas",    friends: ["Shelby", "Court", "Van"]};let anotherPerson = Object.create(person, {    name: {        value: "Greg"    }});console.log(anotherPerson.name); // "Greg" </code></pre><p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p><pre><code>function createAnother(original){    let clone = object(original); // 通过调用函数创建一个新对象    clone.sayHi = function() { // 以某种方式增强这个对象        console.log("hi");    };    return clone; // 返回这个对象}</code></pre><p>在这段代码中，createAnother()函数接收一个参数，就是新对象的基准对象。这个对象 original会被传给 object()函数，然后将返回的新对象赋值给 clone。接着给 clone 对象添加一个新方法sayHi()。最后返回这个对象。可以像下面这样使用 createAnother()函数： </p><pre><code>let person = {    name: "Nicholas",    friends: ["Shelby", "Court", "Van"]};let anotherPerson = createAnother(person);anotherPerson.sayHi(); // "hi" </code></pre><p>这个例子基于 person 对象返回了一个新对象。新返回的 anotherPerson 对象具有 person 的所有属性和方法，还有一个新方法叫 sayHi()。</p><p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p><p><strong>注意</strong> 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子：</p><pre><code>function SuperType(name) {    this.name = name;    this.colors = ["red", "blue", "green"];}SuperType.prototype.sayName = function() {    console.log(this.name);};function SubType(name, age){    SuperType.call(this, name); // 第二次调用 SuperType()    this.age = age;}SubType.prototype = new SuperType(); // 第一次调用 SuperType()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() {    console.log(this.age); };</code></pre><p>在上面的代码执行后，SubType.prototype上会有两个属性：name 和 colors。它们都是 SuperType 的实例属性，但现在成为了 SubType 的原型属性。在调用 SubType 构造函数时，也会调用 SuperType 构造函数，这一次会在新对象上创建实例属性 name 和 colors。这两个实例属性会遮蔽原型上同名的属性。</p><p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。寄生式组合继承的基本模式如下所示：</p><pre><code>function inheritPrototype(subType, superType) {    let prototype = object(superType.prototype); // 创建对象    prototype.constructor = subType; // 增强对象    subType.prototype = prototype; // 赋值对象} </code></pre><p>这个 inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例子中的子类型原型赋值：</p><pre><code>function SuperType(name) {    this.name = name;    this.colors = ["red", "blue", "green"];}SuperType.prototype.sayName = function() {    console.log(this.name);};function SubType(name, age) {    SuperType.call(this, name);     this.age = age;}inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() {    console.log(this.age);}; </code></pre><p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0015.html"/>
      <url>posts/a0015.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0014">对象、类与面向对象编程(一) 理解对象</a></strong><br>本篇: <strong>对象、类与面向对象编程(二) 创建对象</strong><br>下篇: <strong><a href="a0016">对象、类与面向对象编程(三) 继承</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。</p><h2 id="工场模式"><a href="#工场模式" class="headerlink" title="工场模式"></a>工场模式</h2><p>下面的例子展示了一种按照特定接口创建对象的方式：</p><pre><code>function createPerson(name, age, job) {    let o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function() {        console.log(this.name);    };    return o;}let person1 = createPerson("Nicholas", 29, "Software Engineer");let person2 = createPerson("Greg", 27, "Doctor"); </code></pre><p>这里，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含 3 个属性和 1 个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>前面几章提到过，ECMAScript 中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。比如，前面的例子使用构造函数模式可以这样写：</p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Greg</code></pre><p>在这个例子中，Person()构造函数代替了 createPerson()工厂函数。实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别。</p><ol><li>没有显式地创建对象。</li><li>属性和方法直接赋值给了 this。</li><li>没有 return。</li></ol><p>另外，要注意函数名 Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。</p><p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作。</p><ol><li>在内存中创建一个新对象。</li><li>这个新对象内部的[[ Prototype]]特性被赋值为构造函数的 prototype 属性。</li><li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li></ol><p>上一个例子的最后，person1 和 person2 分别保存着 Person 的不同实例。这两个对象都有一个constructor 属性指向 Person，如下所示：</p><pre><code>console.log(person1.constructor == Person); // trueconsole.log(person2.constructor == Person); // true</code></pre><p>constructor 本来是用于标识对象类型的。不过，一般认为 instanceof 操作符是确定对象类型更可靠的方式。前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例，如下面调用instanceof 操作符的结果所示：</p><pre><code>console.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true</code></pre><p>定义自定义构造函数可以确保实例被标识为特定类型，相比于工厂模式，这是一个很大的好处。在这个例子中，person1 和 person2 之所以也被认为是 Object 的实例，是因为所有自定义对象都继承自 Object（后面再详细讨论这一点）。</p><p>构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：</p><pre><code>let Person = function(name, age, job) {    this.name = name;    this.age = age;    this.job = job;    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Gregconsole.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true </code></pre><p>在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数：</p><pre><code>function Person() {    this.name = "Jake";    this.sayName = function() {        console.log(this.name);    };}let person1 = new Person();let person2 = new Person; person1.sayName(); // Jakeperson2.sayName(); // Jakeconsole.log(person1 instanceof Object); // trueconsole.log(person1 instanceof Person); // trueconsole.log(person2 instanceof Object); // trueconsole.log(person2 instanceof Person); // true </code></pre><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><p>构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。比如，前面的例子中定义的 Person()可以像下面这样调用：</p><pre><code>// 作为构造函数let person = new Person("Nicholas", 29, "Software Engineer");person.sayName(); // "Nicholas"// 作为函数调用Person("Greg", 27, "Doctor"); // 添加到 window 对象window.sayName(); // "Greg"// 在另一个对象的作用域中调用let o = new Object();Person.call(o, "Kristen", 25, "Nurse");o.sayName(); // "Kristen" </code></pre><p>这个例子一开始展示了典型的构造函数调用方式，即使用 new 操作符创建一个新对象。然后是普通函数的调用方式，这时候没有使用 new 操作符调用 Person()，结果会将属性和方法添加到 window 对象。这里要记住，在调用一个函数而没有明确设置 this 值的情况下（即没有作为对象的方法调用，或者没有使用 call()/apply()调用），this 始终指向 Global 对象（在浏览器中就是 window 对象）。因此在上面的调用之后，window 对象上就有了一个 sayName()方法，调用它会返回”Greg”。最后展示的调用方式是通过 call()（或 apply()）调用函数，同时将特定对象指定为作用域。这里的调用将对象 o 指定为 Person()内部的 this 值，因此执行完函数代码后，所有属性和 sayName()方法都会添加到对象 o 上面。</p><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：   </p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = new Function("console.log(this.name)"); // 逻辑等价} </code></pre><p>这样理解这个构造函数可以更清楚地知道，每个 Person 实例都会有自己的 Function 实例用于显示 name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：</p><p><code>console.log(person1.sayName == person2.sayName); // false </code></p><p>因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。要解决这个问题，可以把函数定义转移到构造函数外部：</p><pre><code>function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = sayName;}function sayName() {    console.log(this.name);}let person1 = new Person("Nicholas", 29, "Software Engineer");let person2 = new Person("Greg", 27, "Doctor");person1.sayName(); // Nicholasperson2.sayName(); // Greg</code></pre><p>在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局 sayName()函数。因为这一次 sayName 属性中包含的只是一个指向外部函数的指针，所以 person1 和 person2共享了定义在全局作用域上的 sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型，如下所示：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();person1.sayName(); // "Nicholas"let person2 = new Person();person2.sayName(); // "Nicholas"console.log(person1.sayName == person2.sayName); // true </code></pre><p>使用函数表达式也可以：</p><pre><code>let Person = function() {};Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();person1.sayName(); // "Nicholas"let person2 = new Person();person2.sayName(); // "Nicholas"console.log(person1.sayName == person2.sayName); // true </code></pre><p>这里，所有属性和 sayName()方法都直接添加到了 Person 的 prototype 属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数。要理解这个过程，就必须理解 ECMAScript 中原型的本质。</p><h3 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h3><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。</p><p>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自<br>Object。每次调用构造函数创建一个新实例，这个实例的内部[[ Prototype]]指针就会被赋值为构造函数的原型对象。实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p><p>这种关系不好可视化，但可以通过下面的代码来理解原型的行为：</p><pre><code>/*** 构造函数可以是函数表达式* 也可以是函数声明，因此以下两种形式都可以：* function Person() {}* let Person = function() {}*/function Person() {}/*** 声明之后，构造函数就有了一个* 与之关联的原型对象：*/console.log(typeof Person.prototype);console.log(Person.prototype);// {// constructor: f Person(),// __proto__: Object// }/*** 如前所述，构造函数有一个 prototype 属性* 引用其原型对象，而这个原型对象也有一个* constructor 属性，引用这个构造函数* 换句话说，两者循环引用：*/console.log(Person.prototype.constructor === Person); // true/*** 正常的原型链都会终止于 Object 的原型对象* Object 原型的原型是 null*/console.log(Person.prototype.__proto__ === Object.prototype); // trueconsole.log(Person.prototype.__proto__.constructor === Object); // trueconsole.log(Person.prototype.__proto__.__proto__ === null); // trueconsole.log(Person.prototype.__proto__);// {// constructor: f Object(),// toString: ...// hasOwnProperty: ...// isPrototypeOf: ...// ...// }let person1 = new Person(),person2 = new Person();/*** 构造函数、原型对象和实例* 是 3 个完全不同的对象：*/console.log(person1 !== Person); // trueconsole.log(person1 !== Person.prototype); // trueconsole.log(Person.prototype !== Person); // true/*** 实例通过__proto__链接到原型对象，* 它实际上指向隐藏特性[[Prototype]]** 构造函数通过 prototype 属性链接到原型对象** 实例与构造函数没有直接联系，与原型对象有直接联系*/console.log(person1.__proto__ === Person.prototype); // trueconosle.log(person1.__proto__.constructor === Person); // true/*** 同一个构造函数创建的两个实例* 共享同一个原型对象：*/console.log(person1.__proto__ === person2.__proto__); // true/*** instanceof 检查实例的原型链中* 是否包含指定构造函数的原型：*/console.log(person1 instanceof Person); // trueconsole.log(person1 instanceof Object); // trueconsole.log(Person.prototype instanceof Object); // true </code></pre><p>对于前面例子中的 Person 构造函数和 Person.prototype，可以通过图 6-1 看出各个对象之间的关系。</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20201123201157.png" alt="6-1"></p><p>图 6-1 展示了 Person 构造函数、Person 的原型对象和 Person 现有两个实例之间的关系。注意，Person.prototype 指向原型对象，而 Person.prototype.contructor 指回 Person 构造函数。原型对象包含 constructor 属性和其他后来添加的属性。Person 的两个实例 person1 和 person2 都只有一个内部属性指回 Person.prototype，而且两者都与构造函数没有直接联系。另外要注意，虽然这两个实例都没有属性和方法，但 person1.sayName()可以正常调用。这是由于对象属性查找机制的原因。</p><p>虽然不是所有实现都对外暴露了[[ Prototype]]，但可以使用 isPrototypeOf()方法确定两个对象之间的这种关系。本质上，isPrototypeOf()会在传入参数的[[ Prototype]]指向调用它的对象时返回 true，如下所示：</p><p><code>console.log(Person.prototype.isPrototypeOf(person1)); // true</code><br><code>console.log(Person.prototype.isPrototypeOf(person2)); // true </code></p><p>这里通过原型对象调用 isPrototypeOf()方法检查了 person1 和 person2。因为这两个例子内部都有链接指向 Person.prototype，所以结果都返回 true。</p><p>ECMAScript 的 Object 类型有一个方法叫 Object.getPrototypeOf()，返回参数的内部特性[[ Prototype]]的值。例如：</p><p><code>console.log(Object.getPrototypeOf(person1) == Person.prototype); // true</code><br><code>console.log(Object.getPrototypeOf(person1).name); // "Nicholas" </code></p><p>第一行代码简单确认了 Object.getPrototypeOf()返回的对象就是传入对象的原型对象。第二行代码则取得了原型对象上 name 属性的值，即”Nicholas”。使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在通过原型实现继承时显得尤为重要</p><p>Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[ Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：</p><pre><code>let biped = {    numLegs: 2};let person = {    name: 'Matt'};Object.setPrototypeOf(person, biped);console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true</code></pre><p><strong>警告</strong> Object.setPrototypeOf()可能会严重影响代码性能。Mozilla 文档说得很清楚：“在所有浏览器和 JavaScript 引擎中，修改继承关系的影响都是微妙且深远的。这种影响并不仅是执行 Object.setPrototypeOf()语句那么简单，而是会涉及所有访问了那些修改过[[ Prototype]]的对象的代码。”</p><p>为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型：</p><pre><code>let biped = {    numLegs: 2};let person = Object.create(biped);person.name = 'Matt';console.log(person.name); // Mattconsole.log(person.numLegs); // 2console.log(Object.getPrototypeOf(person) === biped); // true</code></pre><h3 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h3><p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。因此，在调用 person1.sayName()时，会发生两步搜索。首先，JavaScript 引擎会问：“person1 实例有 sayName 属性吗？”答案是没有。然后，继续搜索并问：“person1 的原型有 sayName 属性吗？”答案是有。于是就返回了保存在原型上的这个函数。在调用 person2.sayName()时，会发生同样的搜索过程，而且也会返回相同的结果。这就是原型用于在多个对象实例间共享属性和方法的原理。</p><p>虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。下面看一个例子：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();let person2 = new Person();person1.name = "Greg";console.log(person1.name); // "Greg"，来自实例console.log(person2.name); // "Nicholas"，来自原型</code></pre><p>只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过，使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象。</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();let person2 = new Person();person1.name = "Greg";console.log(person1.name); // "Greg"，来自实例console.log(person2.name); // "Nicholas"，来自原型delete person1.name;console.log(person1.name); // "Nicholas"，来自原型</code></pre><p>hasOwnProperty()方法用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自 Object的，会在属性存在于调用它的对象实例上时返回 true，如下面的例子所示：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas"; Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();let person2 = new Person();console.log(person1.hasOwnProperty("name")); // falseperson1.name = "Greg";console.log(person1.name); // "Greg"，来自实例console.log(person1.hasOwnProperty("name")); // trueconsole.log(person2.name); // "Nicholas"，来自原型console.log(person2.hasOwnProperty("name")); // falsedelete person1.name;console.log(person1.name); // "Nicholas"，来自原型console.log(person1.hasOwnProperty("name")); // false </code></pre><p>在这个例子中，通过调用 hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。调用 person1.hasOwnProperty(“name”)只在重写 person1 上 name 属性的情况下才返回 true，表明此时 name 是一个实例属性，不是原型属性。</p><h3 id="原型和-in-操作符"><a href="#原型和-in-操作符" class="headerlink" title="原型和 in 操作符"></a>原型和 in 操作符</h3><p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。来看下面的例子：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {    console.log(this.name);};let person1 = new Person();let person2 = new Person();console.log(person1.hasOwnProperty("name")); // falseconsole.log("name" in person1); // trueperson1.name = "Greg";console.log(person1.name); // "Greg"，来自实例console.log(person1.hasOwnProperty("name")); // trueconsole.log("name" in person1); // trueconsole.log(person2.name); // "Nicholas"，来自原型console.log(person2.hasOwnProperty("name")); // falseconsole.log("name" in person2); // truedelete person1.name;console.log(person1.name); // "Nicholas"，来自原型console.log(person1.hasOwnProperty("name")); // falseconsole.log("name" in person1); // true</code></pre><p>在上面整个例子中，name 随时可以通过实例或通过原型访问到。因此，调用”name” in persoon1时始终返回 true，无论这个属性是否在实例上。如果要确定某个属性是否存在于原型上，则可以像下面这样同时使用 hasOwnProperty()和 in 操作符：</p><pre><code>function hasPrototypeProperty(object, name){    return !object.hasOwnProperty(name) &amp;&amp; (name in object);} </code></pre><p>只要通过对象可以访问，in 操作符就返回 true，而 hasOwnProperty()只有属性存在于实例上时才返回 true。因此，只要 in 操作符返回 true 且 hasOwnProperty()返回 false，就说明该属性是一个原型属性。来看下面的例子：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() {    console.log(this.name);};let person = new Person();console.log(hasPrototypeProperty(person, "name")); // trueperson.name = "Greg";console.log(hasPrototypeProperty(person, "name")); // false </code></pre><p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（[[ Enumerable]]特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。</p><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。比如：</p><pre><code>function Person() {}Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() {console.log(this.name);};let keys = Object.keys(Person.prototype);console.log(keys); // "name,age,job,sayName"let p1 = new Person();p1.name = "Rob";p1.age = 31;let p1keys = Object.keys(p1);console.log(p1keys); // "[name,age]"</code></pre><p>如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：</p><pre><code>let keys = Object.getOwnPropertyNames(Person.prototype);console.log(keys); // "[constructor,name,age,job,sayName]"</code></pre><p>注意，返回的结果中包含了一个不可枚举的属性 constructor。Object.keys()和 Object.getOwnPropertyNames()在适当的时候都可用来代替 for-in 循环。</p><p>在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已：</p><pre><code>let k1 = Symbol('k1'),k2 = Symbol('k2'); let o = {    [k1]: 'k1',    [k2]: 'k2'};console.log(Object.getOwnPropertySymbols(o));// [Symbol(k1), Symbol(k2)] </code></pre><h3 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h3><p>for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。</p><p>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p><pre><code>let k1 = Symbol('k1'),    k2 = Symbol('k2');let o = {    1: 1,    first: 'first',    [k1]: 'sym2',    second: 'second',    0: 0};o[k2] = 'sym2';o[3] = 3;o.third = 'third';o[2] = 2;console.log(Object.getOwnPropertyNames(o));// ["0", "1", "2", "3", "first", "second", "third"]console.log(Object.getOwnPropertySymbols(o));// [Symbol(k1), Symbol(k2)]</code></pre><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>在 JavaScript 有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。下面的示例展示了这两个方法：</p><pre><code>const o = {     foo: 'bar',    baz: 1,    qux: {}};console.log(Object.values(o)); // ["bar", 1, {}]console.log(Object.entries((o)));// [["foo", "bar"], ["baz", 1], ["qux", {}]] </code></pre><p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：</p><pre><code>const o = {    qux: {}};console.log(Object.values(o)[0] === o.qux);// trueconsole.log(Object.entries(o)[0][1] === o.qux);// true </code></pre><p>符号属性会被忽略：</p><pre><code>const sym = Symbol();const o = {    [sym]: 'foo'};console.log(Object.values(o));// []console.log(Object.entries((o)));// [] </code></pre><h3 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h3><p>有读者可能注意到了，在前面的例子中，每次定义一个属性或方法都会把 Person.prototype 重写一遍。为了减少代码冗余，也为了从视觉上更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法，如下面的例子所示：</p><pre><code>function Person() {}Person.prototype = {    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }}; </code></pre><p>在这个例子中，Person.prototype 被设置为等于一个通过对象字面量创建的新对象。最终结果<br>是一样的，只有一个问题：这样重写之后，Person.prototype 的 constructor 属性就不指向 Person了。在创建函数时，也会创建它的 prototype 对象，同时会自动给这个原型的 constructor 属性赋值。而上面的写法完全重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同的新对象（Object 构造函数），不再指向原来的构造函数。虽然 instanceof 操作符还能可靠地返回值，但我们不能再依靠 constructor 属性来识别类型了，如下面的例子所示：</p><pre><code>let friend = new Person();console.log(friend instanceof Object); // trueconsole.log(friend instanceof Person); // true console.log(friend.constructor == Person); // falseconsole.log(friend.constructor == Object); // true </code></pre><p>这里，instanceof仍然对Object和Person都返回true。但constructor属性现在等于Object而不是 Person 了。如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值：</p><pre><code>function Person() {} Person.prototype = {    constructor: Person,    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }}; </code></pre><p>这次的代码中特意包含了 constructor 属性，并将它设置为 Person，保证了这个属性仍然包含恰当的值。</p><p>但要注意，以这种方式恢复 constructor 属性会创建一个[[ Enumerable]]为 true 的属性。而原生 constructor 属性默认是不可枚举的。因此，如果你使用的是兼容 ECMAScript 的 JavaScript 引擎，那可能会改为使用 Object.defineProperty()方法来定义 constructor 属性：</p><pre><code>function Person() {}Person.prototype = {    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }};// 恢复 constructor 属性Object.defineProperty(Person.prototype, "constructor", {enumerable: false,value: Person});</code></pre><h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。下面是一个例子：</p><pre><code>let friend = new Person();Person.prototype.sayHi = function() {    console.log("hi");};friend.sayHi(); // "hi"，没问题！</code></pre><p>以上代码先创建一个 Person 实例并保存在 friend 中。然后一条语句在 Person.prototype 上添加了一个名为 sayHi()的方法。虽然 friend 实例是在添加方法之前创建的，但它仍然可以访问这个方法。之所以会这样，主要原因是实例与原型之间松散的联系。在调用 friend.sayHi()时，首先会从这个实例中搜索名为 sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到 sayHi 属性并返回这个属性保存的函数。</p><p>虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的[[ Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。记住，实例只有指向原型的指针，没有指向构造函数的指针。来看下面的例子：</p><pre><code>function Person() {}let friend = new Person();Person.prototype = {    constructor: Person,    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }};friend.sayName(); // 错误</code></pre><p>在这个例子中，Person 的新实例是在重写原型对象之前创建的。在调用 friend.sayName()的时候，会导致错误。这是因为 firend 指向的原型还是最初的原型，而这个原型上并没有 sayName 属性。重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。</p><pre><code>function Person() {}Person.prototype = {    constructor: Person,    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }}; let friend = new Person();friend.sayName(); // "Nicholas"</code></pre><h3 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h3><p>原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。所有原生引用类型的构造函数（包括 Object、Array、String 等）都在原型上定义了实例方法。比如，数组实例的 sort()方法就是 Array.prototype 上定义的，而字符串包装对象的 substring()方法也是在 String.prototype 上定义的，如下所示：</p><p><code>console.log(typeof Array.prototype.sort); // "function"</code><br><code>console.log(typeof String.prototype.substring); // "function" </code></p><p>通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。可以像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法。比如，下面的代码就给 String原始值包装类型的实例添加了一个 startsWith()方法：</p><pre><code>String.prototype.startsWith = function (text) {    return this.indexOf(text) === 0;};let msg = "Hello world!";console.log(msg.startsWith("Hello")); // true </code></pre><p><strong>注意</strong> 尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。</p><h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。</p><p>我们知道，原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，如前面例子中所示，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。来看下面的例子：</p><pre><code>function Person() {}Person.prototype = {    constructor: Person,    name: "Nicholas",    age: 29,    job: "Software Engineer",    friends: ["Shelby", "Court"],     sayName() {        console.log(this.name);    }};let person1 = new Person();let person2 = new Person();person1.friends.push("Van");console.log(person1.friends); // "Shelby,Court,Van"console.log(person2.friends); // "Shelby,Court,Van"console.log(person1.friends === person2.friends); // true </code></pre><p>这里，Person.prototype 有一个名为 friends 的属性，它包含一个字符串数组。然后这里创建了两个 Person 的实例。person1.friends 通过 push 方法向数组中添加了一个字符串。由于这个friends 属性存在于 Person.prototype 而非 person1 上，新加的这个字符串也会在（指向同一个数组的）person2.friends 上反映出来。如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(六)</title>
      <link href="posts/a0014.html"/>
      <url>posts/a0014.html</url>
      
        <content type="html"><![CDATA[<h1 id="对象、类与面向对象编程"><a href="#对象、类与面向对象编程" class="headerlink" title="对象、类与面向对象编程"></a>对象、类与面向对象编程</h1><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数。</p><p>上篇: <strong><a href="a0013">迭代器与生成器(二) 生成器</a></strong><br>本篇: <strong>对象、类与面向对象编程(一) 理解对象</strong><br>下篇: <strong><a href="a0015">对象、类与面向对象编程(二) 创建对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：</p><pre><code>let person = new Object();person.name = "Nicholas";person.age = 29;person.job = "Software Engineer";person.sayName = function() {    console.log(this.name);}; </code></pre><p>前面的例子如果使用对象字面量则可以这样写：</p><pre><code>let person = {    name: "Nicholas",    age: 29,    job: "Software Engineer",    sayName() {        console.log(this.name);    }}; </code></pre><h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如[[ Enumerable]]。</p><p>属性分两种：数据属性和访问器属性。</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为。</p><ol><li><p>[[ Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特<br>性都是 true，如前面的例子所示。</p></li><li><p>[[ Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[ Writable]]：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，如前面的例子所示。</p></li><li><p>[[ Value]]：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为 undefined。</p></li></ol><p>要修改属性的默认特性，就必须使用 Object.defineProperty()方法。这个方法接收 3 个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable 和 value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。比如：</p><pre><code>let person = {};Object.defineProperty(person, "name", {    writable: false,    value: "Nicholas"});console.log(person.name); // "Nicholas"person.name = "Greg";console.log(person.name); // "Nicholas" </code></pre><p>这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值”Nicholas”。这个属性的值就<br>不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。</p><p>类似的规则也适用于创建不可配置的属性。比如：</p><pre><code>let person = {};Object.defineProperty(person, "name", {configurable: false,value: "Nicholas"});console.log(person.name); // "Nicholas"delete person.name;console.log(person.name); // "Nicholas"</code></pre><p>这个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用 Object.defineProperty()并修改任何非 writable 属性会导致错误：</p><pre><code>let person = {};Object.defineProperty(person, "name", {configurable: false,value: "Nicholas"});// 抛出错误Object.defineProperty(person, "name", {configurable: true,value: "Nicholas"}); </code></pre><p>因此，虽然可以对同一个属性多次调用 Object.defineProperty()，但在把 configurable 设置为 false 之后就会受限制了。</p><p>在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。</p><ol><li><p>[[ Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[ Enumerable]]：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</p></li><li><p>[[ Get]]：获取函数，在读取属性时调用。默认值为 undefined。</p></li><li><p>[[ Set]]：设置函数，在写入属性时调用。默认值为 undefined。</p></li></ol><p>访问器属性是不能直接定义的，必须使用 Object.defineProperty()。下面是一个例子：</p><pre><code>// 定义一个对象，包含伪私有成员 year_和公共成员 editionlet book = {    year_: 2017,    edition: 1 };Object.defineProperty(book, "year", {    get() {        return this.year_;    },    set(newValue) {        if (newValue &gt; 2017) {            this.year_ = newValue;            this.edition += newValue - 2017;        }    }});book.year = 2018;console.log(book.edition); // 2 </code></pre><p>在这个例子中，对象 book 有两个默认属性：year_和 edition。year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问。另一个属性 year 被定义为一个访问器属性，其中获取函数简单地返回 year_的值，而设置函数会做一些计算以决定正确的版本（edition）。因此，把 year 属性修改为 2018 会导致 year_变成 2018，edition 变成 2。这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。</p><p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回 undefined，严格模式下会抛出错误。</p><h2 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h2><p>在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript 提供了 Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。比如：</p><pre><code>let book = {};Object.defineProperties(book, {    year_: {        value: 2017    },    edition: {        value: 1    },    year: {        get() {            return this.year_;        },        set(newValue) {            if (newValue &gt; 2017) {                this.year_ = newValue;                this.edition += newValue - 2017;            }        }    }}); </code></pre><p>这段代码在 book 对象上定义了两个数据属性 year_和 edition，还有一个访问器属性 year。最终的对象跟上一节示例中的一样。唯一的区别是所有属性都是同时定义的，并且数据属性的configurable、enumerable 和 writable 特性值都是 false。</p><h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。比如：</p><pre><code>let book = {};Object.defineProperties(book, {    year_: {        value: 2017    },    edition: {        value: 1    },    year: {        get: function() {            return this.year_;        },        set: function(newValue){            if (newValue &gt; 2017) {                this.year_ = newValue;                this.edition += newValue - 2017;            }        }    }}); let descriptor = Object.getOwnPropertyDescriptor(book, "year_");console.log(descriptor.value); // 2017console.log(descriptor.configurable); // falseconsole.log(typeof descriptor.get); // "undefined"let descriptor = Object.getOwnPropertyDescriptor(book, "year");console.log(descriptor.value); // undefinedconsole.log(descriptor.enumerable); // falseconsole.log(typeof descriptor.get); // "function" </code></pre><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>JavaScript 开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。</p><p>ECMAScript 6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回 true）和自有（Object.hasOwnProperty()返回 true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[ Get]]取得属性的值，然后使用目标对象上的[[ Set]]设置属性的值。</p><pre><code>let dest, src, result;/*** 简单复制*/dest = {};src = { id: 'src' };result = Object.assign(dest, src); // Object.assign 修改目标对象// 也会返回修改后的目标对象console.log(dest === result); // trueconsole.log(dest !== src); // trueconsole.log(result); // { id: src }console.log(dest); // { id: src } /*** 多个源对象*/dest = {};result = Object.assign(dest, { a: 'foo' }, { b: 'bar' });console.log(result); // { a: foo, b: bar }/*** 获取函数与设置函数*/dest = {    set a(val) {        console.log(`Invoked dest setter with param ${val}`);    }};src = {    get a() {        console.log('Invoked src getter');        return 'foo';    }}; Object.assign(dest, src);// 调用 src 的获取方法// 调用 dest 的设置方法并传入参数"foo"// 因为这里的设置函数不执行赋值操作// 所以实际上并没有把值转移过来console.log(dest); // { set a(val) {...} } </code></pre><p>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。</p><pre><code>let dest, src, result;、/*** 覆盖属性*/dest = { id: 'dest' };result = Object.assign(dest, { id: 'src1', a: 'foo' }, { id: 'src2', b: 'bar' });// Object.assign 会覆盖重复的属性console.log(result); // { id: src2, a: foo, b: bar }// 可以通过目标对象上的设置函数观察到覆盖的过程：dest = {    set id(x) {        console.log(x);    }};Object.assign(dest, { id: 'first' }, { id: 'second' }, { id: 'third' });// first// second// third /*** 对象引用*/dest = {};src = { a: {} };Object.assign(dest, src);// 浅复制意味着只会复制对象的引用console.log(dest); // { a :{} }console.log(dest.a === src.a); // true </code></pre><p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p><pre><code>let dest, src, result;/*** 错误处理*/dest = {};src = {    a: 'foo',    get b() {        // Object.assign()在调用这个获取函数时会抛出错误        throw new Error();    },     c: 'bar'};try {    Object.assign(dest, src);} catch(e) {}// Object.assign()没办法回滚已经完成的修改// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：console.log(dest); // { a: foo } </code></pre><h2 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h2><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：</p><pre><code>// 这些是===符合预期的情况console.log(true === 1); // falseconsole.log({} === {}); // falseconsole.log("2" === 2); // false// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等console.log(+0 === -0); // trueconsole.log(+0 === 0); // trueconsole.log(-0 === 0); // true// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()console.log(NaN === NaN); // falseconsole.log(isNaN(NaN)); // true </code></pre><p>为改善这类情况，ECMAScript 6 规范新增了 Object.is()，这个方法与===很像，但同时也考虑到了上述边界情形。这个方法必须接收两个参数：</p><pre><code>console.log(Object.is(true, 1)); // falseconsole.log(Object.is({}, {})); // falseconsole.log(Object.is("2", 2)); // false// 正确的 0、-0、+0 相等/不等判定console.log(Object.is(+0, -0)); // falseconsole.log(Object.is(+0, 0)); // trueconsole.log(Object.is(-0, 0)); // false// 正确的 NaN 相等判定console.log(Object.is(NaN, NaN)); // true </code></pre><p>要检查超过两个值，递归地利用相等性传递即可：</p><pre><code>function recursivelyCheckEqual(x, ...rest) {return Object.is(x, rest[0]) &amp;&amp;       (rest.length &lt; 2 || recursivelyCheckEqual(...rest));} </code></pre><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><p>ECMAScript 6 为定义和操作对象新增了很多极其有用的语法糖特性。这些特性都没有改变现有引擎的行为，但极大地提升了处理对象的方便程度。</p><p>本节介绍的所有对象语法同样适用于 ECMAScript 6 的类，本章后面会讨论。</p><h3 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h3><p>在给对象添加变量的时候，开发者经常会发现属性名和变量名是一样的。例如：</p><pre><code>let name = 'Matt';let person = {    name: name};console.log(person); // { name: 'Matt' } </code></pre><p>为此，简写属性名语法出现了。简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 ReferenceError。以下代码和之前的代码是等价的：</p><pre><code>let name = 'Matt';let person = {    name};console.log(person); // { name: 'Matt' } </code></pre><p>代码压缩程序会在不同作用域间保留属性名，以防止找不到引用。以下面的代码为例：</p><pre><code>function makePerson(name) {    return {        name    };}let person = makePerson('Matt');console.log(person.name); // Matt</code></pre><p>在这里，即使参数标识符只限定于函数作用域，编译器也会保留初始的 name 标识符。</p><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性。换句话说，不能在对象字面量中直接动态命名属性。比如：    </p><pre><code>const nameKey = 'name';const ageKey = 'age'; const jobKey = 'job';let person = {};person[nameKey] = 'Matt';person[ageKey] = 27;person[jobKey] = 'Software engineer';console.log(person); // { name: 'Matt', age: 27, job: 'Software engineer' }</code></pre><p>有了可计算属性，就可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：</p><pre><code>const nameKey = 'name';const ageKey = 'age';const jobKey = 'job';let person = {    [nameKey]: 'Matt',    [ageKey]: 27,    [jobKey]: 'Software engineer'};console.log(person);// { name: 'Matt', age: 27, job: 'Software engineer' } </code></pre><p>因为被当作 JavaScript 表达式求值，所以可计算属性本身可以是复杂的表达式，在实例化时再求值：</p><pre><code>const nameKey = 'name';const ageKey = 'age';const jobKey = 'job';let uniqueToken = 0;function getUniqueKey(key) {    return `${key}_${uniqueToken++}`;}let person = {    [getUniqueKey(nameKey)]: 'Matt',    [getUniqueKey(ageKey)]: 27,    [getUniqueKey(jobKey)]: 'Software engineer'};console.log(person); // { name_0: 'Matt', age_1: 27, job_2: 'Software engineer' } </code></pre><h3 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h3><p>在给对象定义方法时，通常都要写一个方法名、冒号，然后再引用一个匿名函数表达式，如下所示：</p><pre><code>let person = {    sayName: function(name) {        console.log(`My name is ${name}`);    }};person.sayName('Matt'); // My name is Matt</code></pre><p>新的简写方法的语法遵循同样的模式，但开发者要放弃给函数表达式命名。相应地，这样也可以明显缩短方法声明。 以下代码和之前的代码在行为上是等价的：</p><pre><code>let person = {    sayName(name) {        console.log(`My name is ${name}`);    }};person.sayName('Matt'); // My name is Matt </code></pre><p>简写方法名对获取函数和设置函数也是适用的：</p><pre><code>let person = {    name_: '',    get name() {        return this.name_;    },    set name(name) {        this.name_ = name;    },    sayName() {        console.log(`My name is ${this.name_}`);    }};person.name = 'Matt';person.sayName(); // My name is Matt</code></pre><p>简写方法名与可计算属性键相互兼容：</p><pre><code>const methodKey = 'sayName';let person = {    [methodKey](name) {        console.log(`My name is ${name}`);    }}person.sayName('Matt'); // My name is Matt</code></pre><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。</p><p>下面的例子展示了两段等价的代码，首先是不使用对象解构的：</p><pre><code>// 不使用对象解构let person = {    name: 'Matt',    age: 27}; let personName = person.name,    personAge = person.age;console.log(personName); // Mattconsole.log(personAge); // 27 </code></pre><p>然后，是使用对象解构的：</p><pre><code>// 使用对象解构let person = {    name: 'Matt',    age: 27};let { name: personName, age: personAge } = person;console.log(personName); // Mattconsole.log(personAge); // 27 </code></pre><p>使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。如果想让变量直接使用属性的名称，那么可以使用简写语法，比如：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, age } = person;console.log(name); // Mattconsole.log(age); // 27 </code></pre><p>解构赋值不一定与对象的属性匹配。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则该变量的值就是 undefined：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, job } = person;console.log(name); // Mattconsole.log(job); // undefined </code></pre><p>也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况：</p><pre><code>let person = {    name: 'Matt',    age: 27};let { name, job='Software engineer' } = person;console.log(name); // Mattconsole.log(job); // Software engineer</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(五)</title>
      <link href="posts/a0013.html"/>
      <url>posts/a0013.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。</p><p>上篇: <strong><a href="a0012">迭代器与生成器(一) 迭代器</a></strong><br>本篇: <strong>迭代器与生成器(二) 生成器</strong><br>下篇: <strong><a href="a0014">对象、类与面向对象编程(一) 理解对象</a></strong> </p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。这种新能力具有深远的影响，比如，使用生成器可以自定义迭代器和实现协程</p><h2 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h2><p>生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义<br>函数的地方，就可以定义生成器。</p><pre><code>// 生成器函数声明function* generatorFn() {}// 生成器函数表达式let generatorFn = function* () {}// 作为对象字面量方法的生成器函数let foo = {    * generatorFn() {}}// 作为类实例方法的生成器函数class Foo {    * generatorFn() {}}// 作为类静态方法的生成器函数class Bar {    static * generatorFn() {}} </code></pre><p><strong>注意</strong> 箭头函数不能用来定义生成器函数</p><p>标识生成器函数的星号不受两侧空格的影响：</p><pre><code>// 等价的生成器函数：function* generatorFnA() {}function *generatorFnB() {}function * generatorFnC() {}// 等价的生成器方法：class Foo {    *generatorFnD() {}    * generatorFnE() {}} </code></pre><p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。</p><pre><code>function* generatorFn() {}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.next); // f next() { [native code] } </code></pre><p>next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。</p><pre><code>function* generatorFn() {}let generatorObject = generatorFn();console.log(generatorObject); // generatorFn {&lt;suspended&gt;}console.log(generatorObject.next()); // { done: true, value: undefined } </code></pre><p>value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定：</p><pre><code>function* generatorFn() {    return 'foo';}let generatorObject = generatorFn();console.log(generatorObject); // generatorFn {&lt;suspended&gt;}console.log(generatorObject.next()); // { done: true, value: 'foo' } </code></pre><p>生成器函数只会在初次调用 next()方法后开始执行，如下所示</p><pre><code>function* generatorFn() {    console.log('foobar');}// 初次调用生成器函数并不会打印日志let generatorObject = generatorFn();generatorObject.next(); // foobar </code></pre><p>生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的：</p><pre><code>function* generatorFn() {}console.log(generatorFn);// f* generatorFn() {}console.log(generatorFn()[Symbol.iterator]); // f [Symbol.iterator]() {native code}console.log(generatorFn());// generatorFn {&lt;suspended&gt;}console.log(generatorFn()[Symbol.iterator]());// generatorFn {&lt;suspended&gt;} const g = generatorFn();console.log(g === g[Symbol.iterator]()); // true</code></pre><h2 id="通过-yield-中断执行"><a href="#通过-yield-中断执行" class="headerlink" title="通过 yield 中断执行"></a>通过 yield 中断执行</h2><p>yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行：</p><pre><code>function* generatorFn() {    yield;}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: undefined }console.log(generatorObject.next()); // { done: true, value: undefined }</code></pre><p>此时的yield 关键字有点像函数的中间返回语句，它生成的值会出现在 next()方法返回的对象里。通过 yield 关键字退出的生成器函数会处在 done: false 状态；通过 return 关键字退出的生成器函数会处于 done: true 状态。</p><pre><code>function* generatorFn() {    yield 'foo';    yield 'bar';    return 'baz';}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: 'foo' }console.log(generatorObject.next()); // { done: false, value: 'bar' }console.log(generatorObject.next()); // { done: true, value: 'baz' }</code></pre><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用 next()不会影响其他生成器：</p><pre><code>function* generatorFn() {    yield 'foo';    yield 'bar';    return 'baz';}let generatorObject1 = generatorFn();let generatorObject2 = generatorFn();console.log(generatorObject1.next()); // { done: false, value: 'foo' }console.log(generatorObject2.next()); // { done: false, value: 'foo' } console.log(generatorObject2.next()); // { done: false, value: 'bar' }console.log(generatorObject1.next()); // { done: false, value: 'bar' } </code></pre><p>yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。类似函数的 return 关键字，yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误：</p><pre><code>// 有效function* validGeneratorFn() {    yield;}// 无效function* invalidGeneratorFnA() {    function a() {        yield;    }}// 无效function* invalidGeneratorFnB() {    const b = () =&gt; {        yield;    }}// 无效function* invalidGeneratorFnC() {    (() =&gt; {        yield;    })();} </code></pre><h3 id="生成器对象作为可迭代对象"><a href="#生成器对象作为可迭代对象" class="headerlink" title="生成器对象作为可迭代对象"></a>生成器对象作为可迭代对象</h3><p>在生成器对象上显式调用 next()方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：</p><pre><code>function* generatorFn() {    yield 1;    yield 2;    yield 3;}for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3</code></pre><p>在需要自定义迭代对象时，这样使用生成器对象会特别有用。比如，我们需要定义一个可迭代对象，而它会产生一个迭代器，这个迭代器会执行指定的次数。使用生成器，可以通过一个简单的循环来实现：</p><pre><code>function* nTimes(n) {    while(n--) {        yield;    }} for (let _ of nTimes(3)) {    console.log('foo');}// foo// foo// foo </code></pre><p>传给生成器的函数可以控制迭代循环的次数。在 n 为 0 时，while 条件为假，循环退出，生成器函数返回。</p><h3 id="使用-yield-实现输入和输出"><a href="#使用-yield-实现输入和输出" class="headerlink" title="使用 yield 实现输入和输出"></a>使用 yield 实现输入和输出</h3><p>除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。这里有个地方不太好理解——第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p><pre><code>function* generatorFn(initial) {    console.log(initial);    console.log(yield);    console.log(yield);}let generatorObject = generatorFn('foo');generatorObject.next('bar'); // foogeneratorObject.next('baz'); // bazgeneratorObject.next('qux'); // qux</code></pre><p>yield 关键字可以同时用于输入和输出，如下例所示：</p><pre><code>function* generatorFn() {    return yield 'foo';}let generatorObject = generatorFn();console.log(generatorObject.next()); // { done: false, value: 'foo' }console.log(generatorObject.next('bar')); // { done: true, value: 'bar' } </code></pre><p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到 yield 关键字时暂停执行并计算出要产生的值：”foo”。下一次调用 next()传入了”bar”，作为交给同一个 yield 的值。然后这个值被确定为本次生成器函数要返回的值。</p><p>yield 关键字并非只能使用一次。比如，以下代码就定义了一个无穷计数生成器函数：</p><pre><code>function* generatorFn() {    for (let i = 0;;++i) {        yield i;    }}let generatorObject = generatorFn();console.log(generatorObject.next().value); // 0console.log(generatorObject.next().value); // 1console.log(generatorObject.next().value); // 2console.log(generatorObject.next().value); // 3console.log(generatorObject.next().value); // 4console.log(generatorObject.next().value); // 5... </code></pre><p>假设我们想定义一个生成器函数，它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为：</p><pre><code>function* nTimes(n) {    for (let i = 0; i &lt; n; ++i) {        yield i;    }}for (let x of nTimes(3)) {    console.log(x);}// 0// 1// 2</code></pre><p>另外，使用 while 循环也可以，而且代码稍微简洁一点：</p><pre><code>function* nTimes(n) {    let i = 0;    while(n--) {        yield i++;    }}for (let x of nTimes(3)) {    console.log(x);}// 0// 1// 2 </code></pre><p>这样使用生成器也可以实现范围和填充数组：<br>    function* range(start, end) {<br>        while(end &gt; start) {<br>            yield start++;<br>        }<br>    }</p><pre><code>for (const x of range(4, 7)) {    console.log(x);}// 4// 5// 6function* zeroes(n) {    while(n--) {        yield 0;    }}console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0] </code></pre><h3 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h3><p>可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</p><pre><code>// 等价的 generatorFn：// function* generatorFn() {// for (const x of [1, 2, 3]) {// yield x;// }// }function* generatorFn() {    yield* [1, 2, 3];}let generatorObject = generatorFn();for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3 </code></pre><p>与生成器函数的星号类似，yield 星号两侧的空格不影响其行为：</p><pre><code>function* generatorFn() {    yield* [1, 2];    yield *[3, 4];    yield * [5, 6];}for (const x of generatorFn()) {    console.log(x);}// 1// 2// 3// 4// 5// 6 </code></pre><p>因为 yield*实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把 yield放到一个循环里没什么不同。下面两个生成器函数的行为是等价的：</p><pre><code>function* generatorFnA() {    for (const x of [1, 2, 3]) {        yield x;    }}for (const x of generatorFnA()) {    console.log(x);}// 1// 2// 3function* generatorFnB() {    yield* [1, 2, 3];}for (const x of generatorFnB()) {    console.log(x);} //1 2 3 </code></pre><p>yield*的值是关联迭代器返回 done: true 时的 value 属性。对于普通迭代器来说，这个值是undefined：</p><pre><code>function* generatorFn() {    console.log('iter value:', yield* [1, 2, 3]);}for (const x of generatorFn()) {    console.log('value:', x);}// value: 1// value: 2// value: 3// iter value: undefined </code></pre><p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p><pre><code>function* innerGeneratorFn() {    yield 'foo';    return 'bar';}function* outerGeneratorFn(genObj) {    console.log('iter value:', yield* innerGeneratorFn());}for (const x of outerGeneratorFn()) {    console.log('value:', x);}// value: foo// iter value: bar </code></pre><h3 id="使用-yield-实现递归算法"><a href="#使用-yield-实现递归算法" class="headerlink" title="使用 yield*实现递归算法"></a>使用 yield*实现递归算法</h3><p>yield*最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p><pre><code>function* nTimes(n) {    if (n &gt; 0) {        yield* nTimes(n - 1);        yield n - 1;    }}for (const x of nTimes(3)) {    console.log(x);}// 0// 1// 2 </code></pre><p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</p><p>使用递归生成器结构和 yield*可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p><pre><code>class Node {    constructor(id) {        this.id = id;        this.neighbors = new Set();    }    connect(node) {        if (node !== this) {            this.neighbors.add(node);            node.neighbors.add(this);        }    }} class RandomGraph {    constructor(size) {        this.nodes = new Set();        // 创建节点        for (let i = 0; i &lt; size; ++i) {            this.nodes.add(new Node(i));        }        // 随机连接节点        const threshold = 1 / size;        for (const x of this.nodes) {            for (const y of this.nodes) {                if (Math.random() &lt; threshold) {                    x.connect(y);                }            }        }    }     for (const node of this.nodes) {        const ids = [...node.neighbors]                    .map((n) =&gt; n.id)                    .join(',');        console.log(`${node.id}: ${ids}`);    }}const g = new RandomGraph(6);g.print();// 示例输出：// 0: 2,3,5// 1: 2,3,4,5// 2: 1,3// 3: 0,1,2,4// 4: 2,3// 5: 0,4 </code></pre><p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p><pre><code>class Node {    constructor(id) {        ...    }    connect(node) {        ...    }}class RandomGraph {    constructor(size) {        ...    }    print() {        ...    }     isConnected() {        const visitedNodes = new Set();        function* traverse(nodes) {            for (const node of nodes) {                if (!visitedNodes.has(node)) {                    yield node;                    yield* traverse(node.neighbors);                }            }        }        // 取得集合中的第一个节点        const firstNode = this.nodes[Symbol.iterator]().next().value;        // 使用递归生成器迭代每个节点        for (const node of traverse([firstNode])) {            visitedNodes.add(node);        }        return visitedNodes.size === this.nodes.size;    }}  </code></pre><h2 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h2><p>因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p><pre><code>class Foo {    constructor() {        this.values = [1, 2, 3];    }     * [Symbol.iterator]() {        yield* this.values;    }}const f = new Foo();for (const x of f) {    console.log(x);}// 1// 2// 3 </code></pre><p>这里，for-of 循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p><h2 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h2><p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next()方法，还有一个可选的 return()方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：throw()。</p><pre><code>function* generatorFn() {}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.next); // f next() { [native code] }console.log(g.return); // f return() { [native code] }console.log(g.throw); // f throw() { [native code] }</code></pre><p>return()和 throw()方法都可以用于强制生成器进入关闭状态。</p><h3 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h3><p>return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}console.log(g.return(4)); // { done: true, value: 4 }console.log(g); // generatorFn {&lt;closed&gt;} </code></pre><p>与迭代器不同，所有生成器对象都有 return()方法，只要通过它进入关闭状态，就无法恢复了。后续调用 next()会显示 done: true 状态，而提供的任何返回值都不会被存储或传播：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g.next()); // { done: false, value: 1 }console.log(g.return(4)); // { done: true, value: 4 }console.log(g.next()); // { done: true, value: undefined }console.log(g.next()); // { done: true, value: undefined }console.log(g.next()); // { done: true, value: undefined }  </code></pre><p>for-of 循环等内置语言结构会忽略状态为 done: true 的 IteratorObject 内部返回的值。</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();for (const x of g) {    if (x &gt; 1) {        g.return(4);    }    console.log(x);}// 1// 2 </code></pre><h3 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h3><p>throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        yield x;    }}const g = generatorFn();console.log(g); // generatorFn {&lt;suspended&gt;}try {    g.throw('foo');} catch (e) {    console.log(e); // foo}console.log(g); // generatorFn {&lt;closed&gt;}</code></pre><p>不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield，因此在这个例子中会跳过一个值。比如：</p><pre><code>function* generatorFn() {    for (const x of [1, 2, 3]) {        try {            yield x;        } catch(e) {}    }} const g = generatorFn();console.log(g.next()); // { done: false, value: 1}g.throw('foo');console.log(g.next()); // { done: false, value: 3}</code></pre><p>在这个例子中，生成器在 try/catch 块中的 yield 关键字处暂停执行。在暂停期间，throw()方法向生成器对象内部注入了一个错误：字符串”foo”。这个错误会被 yield 关键字抛出。因为错误是在生成器的 try/catch 块中抛出的，所以仍然在生成器内部被捕获。可是，由于 yield 抛出了那个错误，生成器就不会再产出值 2。此时，生成器函数继续执行，在下一次迭代再次遇到 yield 关键字时产出了值 3。</p><p><strong>注意</strong> 如果生成器对象还没有开始执行，那么调用 throw()抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(五)</title>
      <link href="posts/a0012.html"/>
      <url>posts/a0012.html</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><p>迭代的英文“iteration”源自拉丁文 itero，意思是“重复”或“再来”。软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性：迭代器和生成器。使用这两个特性，能够更清晰、高效、方便地实现迭代。</p><p>上篇: <strong><a href="a0011">集合引用类型(八) 迭代与扩展操作</a></strong><br>本篇: <strong>迭代器与生成器(一) 迭代器</strong><br>下篇: <strong><a href="a0013">迭代器与生成器(二) 生成器</a></strong> </p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h2><p>在 JavaScript 中，计数循环就是一种最简单的迭代：</p><pre><code>for (let i = 1; i &lt;= 10; ++i) {    console.log(i);} </code></pre><p>循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。</p><p>数组是 JavaScript 中有序集合的最典型例子。</p><pre><code>let collection = ['foo', 'bar', 'baz'];for (let index = 0; index &lt; collection.length; ++index) {console.log(collection[index]);} </code></pre><p>因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。由于如下原因，通过这种循环来执行例程并不理想。</p><ol><li><p>迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，<br>然后再通过[]操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。</p></li><li><p>遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适<br>用于其他具有隐式顺序的数据结构。</p></li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。</p><p>可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：</p><pre><code>// 数组的元素是有限的// 递增索引可以按序访问每个元素let arr = [3, 1, 4];// 集合的元素是有限的// 可以按插入顺序访问每个元素let set = new Set().add(3).add(1).add(4); </code></pre><p>不过，可迭代对象不一定是集合对象，也可以是仅仅具有类似数组行为的其他数据结构，比如本章开头提到的计数循环。该循环中生成的值是暂时性的，但循环本身是在执行迭代。计数循环和数组都具有可迭代对象的行为。</p><p><strong>注意</strong> 临时性可迭代对象可以实现为生成器</p><p>任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。迭代器（iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。</p><h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。</p><p>很多内置类型都实现了 Iterable 接口：</p><ol><li>字符串</li><li>数组</li><li>映射</li><li>集合</li><li>arguments 对象</li><li>NodeList 等 DOM 集合类型</li></ol><p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p><pre><code>let num = 1;let obj = {};// 这两种类型没有实现迭代器工厂函数console.log(num[Symbol.iterator]); // undefinedconsole.log(obj[Symbol.iterator]); // undefinedlet str = 'abc';let arr = ['a', 'b', 'c'];let map = new Map().set('a', 1).set('b', 2).set('c', 3);let set = new Set().add('a').add('b').add('c');let els = document.querySelectorAll('div');// 这些类型都实现了迭代器工厂函数console.log(str[Symbol.iterator]); // f values() { [native code] }console.log(arr[Symbol.iterator]); // f values() { [native code] }console.log(map[Symbol.iterator]); // f values() { [native code] }console.log(set[Symbol.iterator]); // f values() { [native code] }console.log(els[Symbol.iterator]); // f values() { [native code] }// 调用这个工厂函数会生成一个迭代器console.log(str[Symbol.iterator]()); // StringIterator {}console.log(arr[Symbol.iterator]()); // ArrayIterator {}console.log(map[Symbol.iterator]()); // MapIterator {}console.log(set[Symbol.iterator]()); // SetIterator {}console.log(els[Symbol.iterator]()); // ArrayIterator {} </code></pre><p>实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p><ol><li>for-of 循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()接收由期约组成的可迭代对象</li><li>Promise.race()接收由期约组成的可迭代对象</li><li>yield*操作符，在生成器中使用</li></ol><p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p><pre><code>let arr = ['foo', 'bar', 'baz'];// for-of 循环for (let el of arr) {    console.log(el); }// foo// bar// baz// 数组解构let [a, b, c] = arr;console.log(a, b, c); // foo, bar, baz// 扩展操作符let arr2 = [...arr];console.log(arr2); // ['foo', 'bar', 'baz']// Array.from()let arr3 = Array.from(arr);console.log(arr3); // ['foo', 'bar', 'baz']// Set 构造函数let set = new Set(arr);console.log(set); // Set(3) {'foo', 'bar', 'baz'}// Map 构造函数let pairs = arr.map((x, i) =&gt; [x, i]);console.log(pairs); // [['foo', 0], ['bar', 1], ['baz', 2]]let map = new Map(pairs);console.log(map); // Map(3) { 'foo'=&gt;0, 'bar'=&gt;1, 'baz'=&gt;2 }</code></pre><p>如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口：</p><pre><code>class FooArray extends Array {}let fooArr = new FooArray('foo', 'bar', 'baz');for (let el of fooArr) {    console.log(el);}// foo// bar// baz  </code></pre><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。</p><p>next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”。可以通过以下简单的数组来演示：</p><pre><code>// 可迭代对象let arr = ['foo', 'bar'];// 迭代器工厂函数console.log(arr[Symbol.iterator]); // f values() { [native code] }// 迭代器let iter = arr[Symbol.iterator]();console.log(iter); // ArrayIterator {} // 执行迭代console.log(iter.next()); // { done: false, value: 'foo' }console.log(iter.next()); // { done: false, value: 'bar' }console.log(iter.next()); // { done: true, value: undefined }</code></pre><p>这里通过创建迭代器并调用 next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了：</p><pre><code>let arr = ['foo'];let iter = arr[Symbol.iterator]();console.log(iter.next()); // { done: false, value: 'foo' }console.log(iter.next()); // { done: true, value: undefined }console.log(iter.next()); // { done: true, value: undefined }console.log(iter.next()); // { done: true, value: undefined } </code></pre><p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象：</p><pre><code>let arr = ['foo', 'bar'];let iter1 = arr[Symbol.iterator]();let iter2 = arr[Symbol.iterator]();console.log(iter1.next()); // { done: false, value: 'foo' }console.log(iter2.next()); // { done: false, value: 'foo' }console.log(iter2.next()); // { done: false, value: 'bar' }console.log(iter1.next()); // { done: false, value: 'bar' }</code></pre><p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：</p><pre><code>    let arr = ['foo', 'baz'];    let iter = arr[Symbol.iterator]();    console.log(iter.next()); // { done: false, value: 'foo' }    // 在数组中间插入值    arr.splice(1, 0, 'bar');    console.log(iter.next()); // { done: false, value: 'bar' }    console.log(iter.next()); // { done: false, value: 'baz' }    console.log(iter.next()); // { done: true, value: undefined } </code></pre><p><strong>注意</strong> 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。</p><p>“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。</p><pre><code>// 这个类实现了可迭代接口（Iterable）// 调用默认的迭代器工厂函数会返回// 一个实现迭代器接口（Iterator）的迭代器对象class Foo {    [Symbol.iterator]() {        return {            next() {                return { done: false, value: 'foo' };            }        }    }}let f = new Foo(); // 打印出实现了迭代器接口的对象console.log(f[Symbol.iterator]()); // { next: f() {} } // Array 类型实现了可迭代接口（Iterable）// 调用 Array 类型的默认迭代器工厂函数// 会创建一个 ArrayIterator 的实例let a = new Array();// 打印出 ArrayIterator 的实例console.log(a[Symbol.iterator]()); // Array Iterator {} </code></pre><h2 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h2><p>与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。下面这个例子中的 Counter 类只能被迭代一定的次数：</p><pre><code>class Counter {    // Counter 的实例应该迭代 limit 次    constructor(limit) {        this.count = 1;        this.limit = limit;    }    next() {        if (this.count &lt;= this.limit) {            return { done: false, value: this.count++ };        } else {            return { done: true, value: undefined };        }    }    [Symbol.iterator]() {        return this;    }}let counter = new Counter(3);for (let i of counter) {    console.log(i);}// 1// 2// 3 </code></pre><p>这个类实现了 Iterator 接口，但不理想。这是因为它的每个实例只能被迭代一次：</p><pre><code>for (let i of counter) { console.log(i); } // 1 2 3for (let i of counter) { console.log(i); } // (nothing logged)</code></pre><p>为了让一个可迭代对象能够创建多个迭代器，必须每创建一个迭代器就对应一个新计数器。为此，可以把计数器变量放到闭包里，然后通过闭包返回迭代器：</p><pre><code>class Counter {    constructor(limit) {        this.limit = limit;    }    [Symbol.iterator]() {        let count = 1,        limit = this.limit;        return {            next() {                if (count &lt;= limit) {                    return { done: false, value: count++ };                } else {                    return { done: true, value: undefined };                }            }        };    }} let counter = new Counter(3);for (let i of counter) { console.log(i); } //1 2 3for (let i of counter) { console.log(i); } //1 2 3</code></pre><p>每个以这种方式创建的迭代器也实现了 Iterable 接口。Symbol.iterator 属性引用的工厂函数会返回相同的迭代器：</p><pre><code>let arr = ['foo', 'bar', 'baz'];let iter1 = arr[Symbol.iterator]();console.log(iter1[Symbol.iterator]); // f values() { [native code] }let iter2 = iter1[Symbol.iterator]();console.log(iter1 === iter2); // true </code></pre><p>因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如for-of 循环：</p><pre><code>let arr = [3, 1, 4];let iter = arr[Symbol.iterator](); for (let item of arr ) { console.log(item); } //3 1 4 for (let item of iter ) { console.log(item); } //3 1 4</code></pre><h2 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h2><p>可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况包括：</p><ol><li>for-of 循环通过 break、continue、return 或 throw 提前退出；</li><li>解构操作并未消费所有值。</li></ol><p>return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。因为这个返回值只会用在生成器的上下文中，所以本章后面再讨论这种情况。</p><p>如下面的代码所示，内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用return()方法。</p><pre><code>class Counter {    constructor(limit) {        this.limit = limit;    }    [Symbol.iterator]() {        let count = 1,        limit = this.limit;        return {            next() {                if (count &lt;= limit) {                    return { done: false, value: count++ };                } else {                    return { done: true };                }            },            return() {                console.log('Exiting early');                return { done: true };            }        };    }} let counter1 = new Counter(5);for (let i of counter1) {    if (i &gt; 2) {        break;    }    console.log(i);} // 1// 2// Exiting earlylet counter2 = new Counter(5);try {    for (let i of counter2) {        if (i &gt; 2) {            throw 'err';        }        console.log(i);    }} catch(e) {}// 1// 2// Exiting early let counter3 = new Counter(5);let [a, b] = counter3;// Exiting early</code></pre><p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的：</p><pre><code>let a = [1, 2, 3, 4, 5];let iter = a[Symbol.iterator]();for (let i of iter) {    console.log(i);    if (i &gt; 2) {        break;    }}// 1// 2// 3for (let i of iter) {    console.log(i);}// 4// 5 </code></pre><p>因为 return()方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用 return()不会强制迭代器进入关闭状态。即便如此，return()方法还是会被调用。</p><pre><code>let a = [1, 2, 3, 4, 5];let iter = a[Symbol.iterator]();iter.return = function() {    console.log('Exiting early');    return { done: true }; };for (let i of iter) {    console.log(i);    if (i &gt; 2) {        break;    }}// 1// 2// 3// 提前退出for (let i of iter) {    console.log(i);}// 4// 5 </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0011.html"/>
      <url>posts/a0011.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0010">集合引用类型(七) WeakSet</a></strong><br>本篇: <strong>集合引用类型(八) 迭代与扩展操作</strong><br>下篇: <strong><a href="a0012">迭代器与生成器(一) 迭代器</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h1><p>ECMAScript 6 新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便。</p><p><strong>注意</strong> 第 5 章会更详细地介绍迭代器和生成器。</p><p>如本章前面所示，有 4 种原生集合类型定义了默认迭代器：</p><ol><li>Array</li><li>所有定型数组</li><li>Map</li><li>Set</li></ol><p>很简单，这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环：</p><pre><code>let iterableThings = [    Array.of(1, 2),    typedArr = Int16Array.of(3, 4),    new Map([[5, 6], [7, 8]]),    new Set([9, 10])];for (const iterableThing of iterableThings) {    for (const x of iterableThing) {        console.log(x);    }}// 1// 2// 3// 4// [5, 6]// [7, 8]// 9// 10 </code></pre><p>这也意味着所有这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p><pre><code>let arr1 = [1, 2, 3];let arr2 = [...arr1];console.log(arr1); // [1, 2, 3]console.log(arr2); // [1, 2, 3]console.log(arr1 === arr2); // false </code></pre><p>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制：</p><pre><code>let map1 = new Map([[1, 2], [3, 4]]);let map2 = new Map(map1);console.log(map1); // Map {1 =&gt; 2, 3 =&gt; 4}console.log(map2); // Map {1 =&gt; 2, 3 =&gt; 4}</code></pre><p>当然，也可以构建数组的部分元素：</p><pre><code>let arr1 = [1, 2, 3];let arr2 = [0, ...arr1, 4, 5];console.log(arr2); // [0, 1, 2, 3, 4, 5] </code></pre><p>浅复制意味着只会复制对象引用：</p><pre><code>let arr1 = [{}];let arr2 = [...arr1];arr1[0].foo = 'bar';console.log(arr2[0]); // { foo: 'bar' } </code></pre><p>上面的这些类型都支持多种构建方法，比如 Array.of()和 Array.from()静态方法。在与扩展操作符一起使用时，可以非常方便地实现互操作：</p><pre><code>let arr1 = [1, 2, 3];// 把数组复制到定型数组let typedArr1 = Int16Array.of(...arr1);let typedArr2 = Int16Array.from(arr1);console.log(typedArr1); // Int16Array [1, 2, 3]console.log(typedArr2); // Int16Array [1, 2, 3]// 把数组复制到映射let map = new Map(arr1.map((x) =&gt; [x, 'val' + x]));console.log(map); // Map {1 =&gt; 'val 1', 2 =&gt; 'val 2', 3 =&gt; 'val 3'}// 把数组复制到集合let set = new Set(typedArr2);console.log(set); // Set {1, 2, 3}// 把集合复制回数组let arr2 = [...set];console.log(arr2); // [1, 2, 3] </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0010.html"/>
      <url>posts/a0010.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0009">集合引用类型(六) Set</a></strong><br>本篇: <strong>集合引用类型(七) WeakSet</strong><br>下篇: <strong><a href="a0011">集合引用类型(八) 迭代与扩展操作</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>ECMAScript 6 新增的“弱集合”（WeakSet）是一种新的集合类型，为这门语言带来了集合数据结构。WeakSet 是 Set 的“兄弟”类型，其 API 也是 Set 的子集。WeakSet 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱集合”中值的方式。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>可以使用 new 关键字实例化一个空的 WeakSet：</p><p><code>const ws = new WeakSet(); </code></p><p>弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出TypeError。如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值。可迭代对象中的每个值都会按照迭代顺序插入到新实例中：</p><pre><code>const val1 = {id: 1},val2 = {id: 2},val3 = {id: 3};// 使用数组初始化弱集合const ws1 = new WeakSet([val1, val2, val3]);alert(ws1.has(val1)); // truealert(ws1.has(val2)); // truealert(ws1.has(val3)); // true// 初始化是全有或全无的操作// 只要有一个值无效就会抛出错误，导致整个初始化失败const ws2 = new WeakSet([val1, "BADVAL", val3]);// TypeError: Invalid value used in WeakSettypeof ws2;// ReferenceError: ws2 is not defined// 原始值可以先包装成对象再用作值const stringVal = new String("val1");const ws3 = new WeakSet([stringVal]);alert(ws3.has(stringVal)); // true </code></pre><p>初始化之后可以使用 add()再添加新值，可以使用 has()查询，还可以使用 delete()删除：</p><pre><code>const ws = new WeakSet();const val1 = {id: 1},      val2 = {id: 2};alert(ws.has(val1)); // falsews.add(val1).add(val2);alert(ws.has(val1)); // truealert(ws.has(val2)); // truews.delete(val1); // 只删除这一个值alert(ws.has(val1)); // falsealert(ws.has(val2)); // true </code></pre><p>add()方法返回弱集合实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const val1 = {id: 1},val2 = {id: 2},val3 = {id: 3};const ws = new WeakSet().add(val1);ws.add(val2).add(val3);alert(ws.has(val1)); // truealert(ws.has(val2)); // truealert(ws.has(val3)); // true</code></pre><h2 id="弱值"><a href="#弱值" class="headerlink" title="弱值"></a>弱值</h2><p>WeakSet 中“weak”表示弱集合的值是“弱弱地拿着”的。意思就是，这些值不属于正式的引用，不会阻止垃圾回收。来看下面的例子：</p><pre><code>const ws = new WeakSet();ws.add({}); </code></pre><p>add()方法初始化了一个新对象，并将它用作一个值。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象值就会被当作垃圾回收。然后，这个值就从弱集合中消失了，使其成为一个空集合。再看一个稍微不同的例子：</p><pre><code>const ws = new WeakSet();const container = {    val: {}};ws.add(container.val);function removeReference() {    container.val = null;} </code></pre><p>这一次，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁值对象的最后一个引用，垃圾回收程序就可以把这个值清理掉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0009.html"/>
      <url>posts/a0009.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0008">集合引用类型(五) WeakMap</a></strong><br>本篇: <strong>集合引用类型(六) Set</strong><br>下篇: <strong><a href="a0010">集合引用类型(七) WeakSet</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构。Set 在很多方面都像是加强的 Map，这是因为它们的大多数 API 和行为都是共有的。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>使用 new 关键字和 Set 构造函数可以创建一个空集合：</p><p><code>const m = new Set(); </code></p><p>如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个可迭代对象，其中需要包含插入到新集合实例中的元素：</p><pre><code>// 使用数组初始化集合const s1 = new Set(["val1", "val2", "val3"]);alert(s1.size); // 3// 使用自定义迭代器初始化集合const s2 = new Set({[Symbol.iterator]: function*() {    yield "val1";    yield "val2";    yield "val3";}});alert(s2.size); // 3</code></pre><p>初始化之后，可以使用 add()增加值，使用 has()查询，通过 size 取得元素数量，以及使用 delete()和 clear()删除元素：</p><pre><code>const s = new Set();alert(s.has("Matt")); // falsealert(s.size); // 0s.add("Matt").add("Frisbie");alert(s.has("Matt")); // truealert(s.size); // 2s.delete("Matt");alert(s.has("Matt")); // falsealert(s.has("Frisbie")); // truealert(s.size); // 1s.clear(); // 销毁集合实例中的所有值alert(s.has("Matt")); // falsealert(s.has("Frisbie")); // falsealert(s.size); // 0 </code></pre><p>add()返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：</p><pre><code>const s = new Set().add("val1");s.add("val2").add("val3");alert(s.size); // 3 </code></pre><p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值。集合也使用 SameValueZero 操作,基本上相当于使用严格对象相等的标准来检查值的匹配性。</p><pre><code>const s = new Set();const functionVal = function() {};const symbolVal = Symbol();const objectVal = new Object();s.add(functionVal);s.add(symbolVal);s.add(objectVal);alert(s.has(functionVal)); // truealert(s.has(symbolVal)); // truealert(s.has(objectVal)); // true// SameValueZero 检查意味着独立的实例不会冲突alert(s.has(function() {})); // false </code></pre><p>与严格相等一样，用作值的对象和其他“集合”类型在自己的内容或属性被修改时也不会改变：</p><pre><code>const s = new Set();const objVal = {},      arrVal = [];s.add(objVal);s.add(arrVal);objVal.bar = "bar";arrVal.push("bar");alert(s.has(objVal)); // truealert(s.has(arrVal)); // true</code></pre><p>add()和 delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值：</p><pre><code>const s = new Set();s.add('foo');alert(s.size); // 1s.add('foo');alert(s.size); // 1// 集合里有这个值alert(s.delete('foo')); // true// 集合里没有这个值alert(s.delete('foo')); // false</code></pre><h2 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p>Set 会维护值插入时的顺序，因此支持按顺序迭代。</p><p>集合实例可以提供一个迭代器（Iterator），能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys()（或者 Symbol.iterator 属性，它引用 values()）取得这个迭代器：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);for (let value of s.values()) {    alert(value);}// val1// val2// val3 </code></pre><p>因为 values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);console.log([...s]); // ["val1", "val2", "val3"] </code></pre><p>集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);for (let pair of s.entries()) {    console.log(pair);}// ["val1", "val1"]// ["val2", "val2"]// ["val3", "val3"] </code></pre><p>使用迭代器，而是使用回调方式，则可以调用集合的 forEach()方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p><pre><code>const s = new Set(["val1", "val2", "val3"]);s.forEach((val, dupVal) =&gt; alert(`${val} -&gt; ${dupVal}`));// val1 -&gt; val1// val2 -&gt; val2// val3 -&gt; val3 </code></pre><p>修改集合中值的属性不会影响其作为集合值的身份：</p><pre><code>const s1 = new Set(["val1"]);// 字符串原始值作为值不会被修改for (let value of s1.values()) { alert(value); // newValalert(s1.has("val1")); // true}const valObj = {id: 1};const s2 = new Set([valObj]);// 修改值对象的属性，但对象仍然存在于集合中for (let value of s2.values()) {    value.id = "newVal";    alert(value); // {id: "newVal"}    alert(s2.has(valObj)); // true}alert(valObj); // {id: "newVal"} </code></pre><h2 id="定义正式集合操作"><a href="#定义正式集合操作" class="headerlink" title="定义正式集合操作"></a>定义正式集合操作</h2><p>从各方面来看，Set 跟 Map 都很相似，只是 API 稍有调整。唯一需要强调的就是集合的 API 对自身的简单操作。很多开发者都喜欢使用 Set 操作，但需要手动实现：或者是子类化 Set，或者是定义一个实用函数库。要把两种方式合二为一，可以在子类上实现静态方法，然后在实例方法中使用这些静态方法。在实现这些操作时，需要考虑几个地方。</p><ol><li><p>某些 Set 操作是有关联性的，因此最好让实现的方法能支持处理任意多个集合实例。</p></li><li><p>Set 保留插入顺序，所有方法返回的集合必须保证顺序。</p></li><li><p>尽可能高效地使用内存。扩展操作符的语法很简洁，但尽可能避免集合和数组间的相互转换能够节省对象初始化成本。</p></li><li><p>不要修改已有的集合实例。union(a, b)或 a.union(b)应该返回包含结果的新集合实例。</p><p> class XSet extends Set {<br> union(…sets) {</p><pre><code> return XSet.union(this, ...sets)</code></pre><p> }<br> intersection(…sets) {</p><pre><code> return XSet.intersection(this, ...sets);</code></pre><p> }<br> difference(set) {</p><pre><code> return XSet.difference(this, set);</code></pre><p> }<br> symmetricDifference(set) {</p><pre><code> return XSet.symmetricDifference(this, set);</code></pre><p> }<br> cartesianProduct(set) {</p><pre><code> return XSet.cartesianProduct(this, set);</code></pre><p> }<br> powerSet() {</p><pre><code> return XSet.powerSet(this);</code></pre><p> }</p><p>  // 返回两个或更多集合的并集<br> static union(a, …bSets) {</p><pre><code> const unionSet = new XSet(a); for (const b of bSets) {     for (const bValue of b) {     unionSet.add(bValue);     } } return unionSet;</code></pre><p> } </p><p> // 返回两个或更多集合的交集<br> static intersection(a, …bSets) {</p><pre><code> const intersectionSet = new XSet(a); for (const aValue of intersectionSet) {     for (const b of bSets) {         if (!b.has(aValue)) {         intersectionSet.delete(aValue);         }     } } return intersectionSet;</code></pre><p> } </p><p>  // 返回两个集合的差集<br> static difference(a, b) {</p><pre><code> const differenceSet = new XSet(a); for (const bValue of b) {     if (a.has(bValue)) {         differenceSet.delete(bValue);     } } return differenceSet;</code></pre><p> } </p><p>  // 返回两个集合的对称差集<br> static symmetricDifference(a, b) {</p><pre><code> // 按照定义，对称差集可以表达为 return a.union(b).difference(a.intersection(b));</code></pre><p> } </p><p> // 返回两个集合（数组对形式）的笛卡儿积<br> // 必须返回数组集合，因为笛卡儿积可能包含相同值的对<br> static cartesianProduct(a, b) {</p><pre><code> const cartesianProductSet = new XSet(); for (const aValue of a) {     for (const bValue of b) {         cartesianProductSet.add([aValue, bValue]);     } } return cartesianProductSet;</code></pre><p> } </p><p>  // 返回一个集合的幂集<br> static powerSet(a) {</p><pre><code> const powerSet = new XSet().add(new XSet());     for (const aValue of a) {          for (const set of new XSet(powerSet)) {             powerSet.add(new XSet(set).add(aValue));         }     } return powerSet; }</code></pre><p> } </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0008.html"/>
      <url>posts/a0008.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0007">集合引用类型(四) Map</a></strong><br>本篇: <strong>集合引用类型(五) WeakMap</strong><br>下篇: <strong><a href="a0009">集合引用类型(六) Set</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>ECMAScript 6 新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集。WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。</p><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><p>可以使用 new 关键字实例化一个空的 WeakMap：</p><p><code>const wm = new WeakMap(); </code></p><p>弱映射中的键只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。</p><p>如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。可迭代对象中的每个键/值都会按照迭代顺序插入新实例中：</p><pre><code>const key1 = {id: 1},      key2 = {id: 2},       key3 = {id: 3};// 使用嵌套数组初始化弱映射const wm1 = new WeakMap([    [key1, "val1"],    [key2, "val2"],    [key3, "val3"]]);alert(wm1.get(key1)); // val1alert(wm1.get(key2)); // val2alert(wm1.get(key3)); // val3// 初始化是全有或全无的操作// 只要有一个键无效就会抛出错误，导致整个初始化失败const wm2 = new WeakMap([    [key1, "val1"],    ["BADKEY", "val2"],    [key3, "val3"]]);// TypeError: Invalid value used as WeakMap keytypeof wm2;// ReferenceError: wm2 is not defined// 原始值可以先包装成对象再用作键const stringKey = new String("key1");const wm3 = new WeakMap([    stringKey, "val1"]);alert(wm3.get(stringKey)); // "val1" </code></pre><p>初始化之后可以使用 set()再添加键/值对，可以使用 get()和 has()查询，还可以使用 delete()删除：</p><pre><code>const wm = new WeakMap();const key1 = {id: 1},      key2 = {id: 2};alert(wm.has(key1)); // falsealert(wm.get(key1)); // undefinedwm.set(key1, "Matt").set(key2, "Frisbie");alert(wm.has(key1)); // truealert(wm.get(key1)); // Mattwm.delete(key1); // 只删除这一个键/值对alert(wm.has(key1)); // falsealert(wm.has(key2)); // true </code></pre><p>set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const key1 = {id: 1},    key2 = {id: 2},    key3 = {id: 3};const wm = new WeakMap().set(key1, "val1"); wm.set(key2, "val2").set(key3, "val3");alert(wm.get(key1)); // val1alert(wm.get(key2)); // val2alert(wm.get(key3)); // val3</code></pre><h2 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h2><p>WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收。来看下面的例子：</p><pre><code>const wm = new WeakMap();wm.set({}, "val"); </code></pre><p>set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。在这个例子中，因为值也没有被引用，所以这对键/值被破坏以后，值本身也会成为垃圾回收的目标。再看一个稍微不同的例子：</p><pre><code>const wm = new WeakMap();const container = {    key: {}};wm.set(container.key, "val");function removeReference() {    container.key = null;} </code></pre><p>这一次，container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标。不过，如果调用了 removeReference()，就会摧毁键对象的最后一个引用，垃圾回收程序就可以把这个键/值对清理掉。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0007.html"/>
      <url>posts/a0007.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0006">集合引用类型(三) 定型数组</a></strong><br>本篇: <strong>集合引用类型(四) Map</strong><br>下篇: <strong><a href="a0008">集合引用类型(五) WeakMap</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ECMAScript 6 以前，在 JavaScript 中实现“键/值”式存储可以使用 Object 来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此 TC39 委员会专门为“键/值”存储定义了一个规范。</p><p>作为 ECMAScript 6 的新增特性，Map 是一种新的集合类型，为这门语言带来了真正的键/值存储机制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。</p><h2 id="基本-API"><a href="#基本-API" class="headerlink" title="基本 API"></a>基本 API</h2><p>使用 new 关键字和 Map 构造函数可以创建一个空映射：</p><p><code>const m = new Map(); </code></p><p>如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中：</p><pre><code>// 使用嵌套数组初始化映射const m1 = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);alert(m1.size); // 3// 使用自定义迭代器初始化映射const m2 = new Map({[Symbol.iterator]: function*() {    yield ["key1", "val1"];    yield ["key2", "val2"];    yield ["key3", "val3"];}});alert(m2.size); // 3 const m3 = new Map([[]]);alert(m3.has(undefined)); // truealert(m3.get(undefined)); // undefined</code></pre><p>初始化之后，可以使用 set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键/值对的数量，还可以使用 delete()和 clear()删除值。</p><pre><code>const m = new Map();alert(m.has("firstName")); // falsealert(m.get("firstName")); // undefinedalert(m.size); // 0m.set("firstName", "Matt").set("lastName", "Frisbie");alert(m.has("firstName")); // truealert(m.get("firstName")); // Mattalert(m.size); // 2m.delete("firstName"); // 只删除这一个键/值对alert(m.has("firstName")); // falsealert(m.has("lastName")); // truealert(m.size); // 1m.clear(); // 清除这个映射实例中的所有键/值对alert(m.has("firstName")); // falsealert(m.has("lastName")); // falsealert(m.size); // 0 </code></pre><p>set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：</p><pre><code>const m = new Map().set("key1", "val1");m.set("key2", "val2").set("key3", "val3");alert(m.size); // 3</code></pre><p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键。与 Object 类似，映射的值是没有限制的。</p><pre><code>const m = new Map();const functionKey = function() {};const symbolKey = Symbol();const objectKey = new Object();m.set(functionKey, "functionValue");m.set(symbolKey, "symbolValue");m.set(objectKey, "objectValue");alert(m.get(functionKey)); // functionValuealert(m.get(symbolKey)); // symbolValuealert(m.get(objectKey)); // objectValue// SameValueZero 比较意味着独立实例不冲突alert(m.get(function() {})); // undefined </code></pre><p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变：</p><pre><code>const m = new Map();const objKey = {},      objVal = {},      arrKey = [],      arrVal = [];m.set(objKey, objVal);m.set(arrKey, arrVal);objKey.foo = "foo";objVal.bar = "bar";arrKey.push("foo");arrVal.push("bar");console.log(m.get(objKey)); // {bar: "bar"}console.log(m.get(arrKey)); // ["bar"] </code></pre><h2 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h2><p>与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key, value]形式的数组。可以通过 entries()方法取得这个迭代器：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);for (let pair of m.entries()) {alert(pair);}// [key1,val1]// [key2,val2]// [key3,val3] </code></pre><p>因为 entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]] </code></pre><p>如果不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部 this 的值：</p><pre><code>const m = new Map([    ["key1", "val1"],    ["key2", "val2"],    ["key3", "val3"]]);m.forEach((val, key) =&gt; alert(`${key} -&gt; ${val}`));// key1 -&gt; val1// key2 -&gt; val2// key3 -&gt; val3 </code></pre><p>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份：</p><pre><code>const m1 = new Map([    ["key1", "val1"]]);// 作为键的字符串原始值是不能修改的for (let key of m1.keys()) {    key = "newKey";    alert(key); // newKey    alert(m1.get("key1")); // val1}const keyObj = {id: 1};const m = new Map([[keyObj, "val1"]]); // 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值for (let key of m.keys()) {    key.id = "newKey";    alert(key); // {id: "newKey"}    alert(m.get(keyObj)); // val1}alert(keyObj); // {id: "newKey"}</code></pre><h2 id="选择-Object-还是-Map"><a href="#选择-Object-还是-Map" class="headerlink" title="选择 Object 还是 Map"></a>选择 Object 还是 Map</h2><p>对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别。</p><ol><li><p>内存占用<br>Object 和 Map 的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况不同，但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。</p></li><li><p>插入性能<br>向 Object 和 Map 中插入新键/值对的消耗大致相当，不过插入 Map 在所有浏览器中一般会稍微快一点儿。对这两个类型来说，插入速度并不会随着键/值对数量而线性增加。如果代码涉及大量插入操作，那么显然 Map 的性能更佳。</p></li><li><p>查找速度<br>与插入不同，从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键/值对，则 Object 有时候速度更快。在把 Object 当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。这对 Map 来说是不可能的。对这两个类型而言，查找速度不会随着键/值对数量增加而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。</p></li><li><p>删除性能<br>使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0006.html"/>
      <url>posts/a0006.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0005">集合引用类型(二) Array</a></strong><br>本篇: <strong>集合引用类型(三) 定型数组</strong><br>下篇: <strong><a href="a0007">集合引用类型(四) Map</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h1><h2 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p>Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。</p><p>ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。</p><pre><code>const buf = new ArrayBuffer(16); // 在内存中分配 16 字节alert(buf.byteLength); // 16 </code></pre><p>ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中：</p><pre><code>const buf1 = new ArrayBuffer(16);const buf2 = buf1.slice(4, 12);alert(buf2.byteLength); // 8</code></pre><p>ArrayBuffer 某种程度上类似于 C++的 malloc()，但也有几个明显的区别。</p><ol><li><p>malloc()在分配失败时会返回一个 null 指针。ArrayBuffer 在分配失败时会抛出错误。</p></li><li><p>malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer分配的内存不能超过 Number.MAX_SAFE_INTEGER（2^53 - 1）字节。</p></li><li><p>malloc()调用成功不会初始化实际的地址。声明 ArrayBuffer 则会将所有二进制位初始化为 0。</p></li><li><p>通过 malloc()分配的堆内存除非调用 free()或程序退出，否则系统不能再使用。而通过声明ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。</p></li></ol><p>不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。</p><h2 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h2><p>第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。</p><p>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><pre><code>const buf = new ArrayBuffer(16);// DataView 默认使用整个 ArrayBufferconst fullDataView = new DataView(buf);alert(fullDataView.byteOffset); // 0alert(fullDataView.byteLength); // 16alert(fullDataView.buffer === buf); // true// 构造函数接收一个可选的字节偏移量和字节长度// byteOffset=0 表示视图从缓冲起点开始// byteLength=8 限制视图为前 8 个字节const firstHalfDataView = new DataView(buf, 0, 8);alert(firstHalfDataView.byteOffset); // 0alert(firstHalfDataView.byteLength); // 8alert(firstHalfDataView.buffer === buf); // true// 如果不指定，则 DataView 会使用剩余的缓冲// byteOffset=8 表示视图从缓冲的第 9 个字节开始// byteLength 未指定，默认为剩余缓冲const secondHalfDataView = new DataView(buf, 8);alert(secondHalfDataView.byteOffset); // 8 alert(secondHalfDataView.byteLength); // 8alert(secondHalfDataView.buffer === buf); // true </code></pre><p>要通过 DataView 读取缓冲，还需要几个组件。</p><ol><li><p>首先是要读或写的字节偏移量。可以看成 DataView 中的某种“地址”。</p></li><li><p>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。</p></li><li><p>最后是内存中值的字节序。默认为大端字节序。</p></li></ol><h3 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a>ElementType</h3><p>DataView 对存储在缓冲内的数据类型没有预设。它暴露的 API 强制开发者在读、写时指定一个ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。</p><p>ECMAScript 6 支持 8 种不同的 ElementType</p><table><thead><tr><th align="left">ElementType</th><th align="left">字 节</th><th align="left">说 明</th><th align="left">等价的 C 类型</th><th align="left">值的范围</th></tr></thead><tbody><tr><td align="left">Int8</td><td align="left">1</td><td align="left">8 位有符号整数</td><td align="left">signed char</td><td align="left">-128~127</td></tr><tr><td align="left">Uint8</td><td align="left">1</td><td align="left">8 位无符号整数</td><td align="left">unsigned char</td><td align="left">0~255</td></tr><tr><td align="left">Int16</td><td align="left">2</td><td align="left">16 位有符号整数</td><td align="left">short</td><td align="left">-32768~32767</td></tr><tr><td align="left">Uint16</td><td align="left">2</td><td align="left">16 位无符号整数</td><td align="left">unsigned short</td><td align="left">0~65535</td></tr><tr><td align="left">Int32</td><td align="left">4</td><td align="left">32 位有符号整数</td><td align="left">int</td><td align="left">-2147483648~2147483647</td></tr><tr><td align="left">Uint32</td><td align="left">4</td><td align="left">32 位无符号整数</td><td align="left">unsigned int</td><td align="left">0~4294967295</td></tr><tr><td align="left">Float32</td><td align="left">4</td><td align="left">32 位 IEEE-754 浮点数</td><td align="left">float</td><td align="left">-3.4e+38~+3.4e+38</td></tr><tr><td align="left">Float64</td><td align="left">8</td><td align="left">64 位 IEEE-754 浮点数</td><td align="left">double</td><td align="left">-1.7e+308~+1.7e+308</td></tr></tbody></table><p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如下例所示：</p><pre><code>// 在内存中分配两个字节并声明一个 DataViewconst buf = new ArrayBuffer(2);const view = new DataView(buf);// 说明整个缓冲确实所有二进制位都是 0// 检查第一个和第二个字符alert(view.getInt8(0)); // 0alert(view.getInt8(1)); // 0// 检查整个缓冲alert(view.getInt16(0)); // 0// 将整个缓冲都设置为 1// 255 的二进制表示是 11111111（2^8 - 1）view.setUint8(0, 255);// DataView 会自动将数据转换为特定的 ElementType// 255 的十六进制表示是 0xFFview.setUint8(1, 0xFF);// 现在，缓冲里都是 1 了// 如果把它当成二补数的有符号整数，则应该是-1alert(view.getInt16(0)); // -1 </code></pre><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p><p>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序。</p><pre><code>// 在内存中分配两个字节并声明一个 DataViewconst buf = new ArrayBuffer(2);const view = new DataView(buf);// 填充缓冲，让第一位和最后一位都是 1view.setUint8(0, 0x80); // 设置最左边的位等于 1view.setUint8(1, 0x01); // 设置最右边的位等于 1// 缓冲内容（为方便阅读，人为加了空格）// 0x8 0x0 0x0 0x1// 1000 0000 0000 0001// 按大端字节序读取 Uint16// 0x80 是高字节，0x01 是低字节// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769alert(view.getUint16(0)); // 32769// 按小端字节序读取 Uint16// 0x01 是高字节，0x80 是低字节// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384alert(view.getUint16(0, true)); // 384// 按大端字节序写入 Uint16view.setUint16(0, 0x0004);// 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x0 0x0 0x4// 0000 0000 0000 0100alert(view.getUint8(0)); // 0alert(view.getUint8(1)); // 4// 按小端字节序写入 Uint16view.setUint16(0, 0x0002, true);// 缓冲内容（为方便阅读，人为加了空格）// 0x0 0x2 0x0 0x0// 0000 0010 0000 0000alert(view.getUint8(0)); // 2alert(view.getUint8(1)); // 0 </code></pre><h3 id="边界情形"><a href="#边界情形" class="headerlink" title="边界情形"></a>边界情形</h3><p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p><pre><code>const buf = new ArrayBuffer(6);const view = new DataView(buf);// 尝试读取部分超出缓冲范围的值view.getInt32(4);// RangeError// 尝试读取超出缓冲范围的值view.getInt32(8);// RangeError// 尝试读取超出缓冲范围的值view.getInt32(-1);// RangeError// 尝试写入超出缓冲范围的值view.setInt32(4, 123);// RangeError </code></pre><p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p><pre><code>const buf = new ArrayBuffer(1);const view = new DataView(buf);view.setInt8(0, 1.5);alert(view.getInt8(0)); // 1view.setInt8(0, [4]);alert(view.getInt8(0)); // 4view.setInt8(0, 'f');alert(view.getInt8(0)); // 0view.setInt8(0, Symbol());// TypeError </code></pre><h2 id="定型数组-1"><a href="#定型数组-1" class="headerlink" title="定型数组"></a>定型数组</h2><p>定型数组是另一种形式的 ArrayBuffer 视图。虽然概念上与 DataView 接近，但定型数组的区别在于，它特定于一种 ElementType 且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API 和更高的性能。设计定型数组的目的就是提高与 WebGL 等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript 引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快。</p><p>创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。另外，通过&lt; ElementType&gt;.from()和&lt; ElementType&gt;.of()也可以创建定型数组：</p><pre><code>// 创建一个 12 字节的缓冲const buf = new ArrayBuffer(12);// 创建一个引用该缓冲的 Int32Arrayconst ints = new Int32Array(buf);// 这个定型数组知道自己的每个元素需要 4 字节// 因此长度为 3alert(ints.length); // 3 // 创建一个长度为 6 的 Int32Arrayconst ints2 = new Int32Array(6);// 每个数值使用 4 字节，因此 ArrayBuffer 是 24 字节alert(ints2.length); // 6// 类似 DataView，定型数组也有一个指向关联缓冲的引用alert(ints2.buffer.byteLength); // 24// 创建一个包含[2, 4, 6, 8]的 Int32Arrayconst ints3 = new Int32Array([2, 4, 6, 8]);alert(ints3.length); // 4alert(ints3.buffer.byteLength); // 16alert(ints3[2]); // 6// 通过复制 ints3 的值创建一个 Int16Arrayconst ints4 = new Int16Array(ints3);// 这个新类型数组会分配自己的缓冲// 对应索引的每个值会相应地转换为新格式alert(ints4.length); // 4alert(ints4.buffer.byteLength); // 8alert(ints4[2]); // 6// 基于普通数组来创建一个 Int16Arrayconst ints5 = Int16Array.from([3, 5, 7, 9]);alert(ints5.length); // 4alert(ints5.buffer.byteLength); // 8alert(ints5[2]); // 7// 基于传入的参数创建一个 Float32Arrayconst floats = Float32Array.of(3.14, 2.718, 1.618);alert(floats.length); // 3alert(floats.buffer.byteLength); // 12alert(floats[2]); // 1.6180000305175781 </code></pre><p>定型数组的构造函数和实例都有一个 BYTES_PER_ELEMENT 属性，返回该类型数组中每个元素的大小：</p><pre><code>alert(Int16Array.BYTES_PER_ELEMENT); // 2alert(Int32Array.BYTES_PER_ELEMENT); // 4const ints = new Int32Array(1),floats = new Float64Array(1);alert(ints.BYTES_PER_ELEMENT); // 4alert(floats.BYTES_PER_ELEMENT); // 8 </code></pre><p>如果定型数组没有用任何值初始化，则其关联的缓冲会以 0 填充：</p><pre><code>const ints = new Int32Array(4);alert(ints[0]); // 0alert(ints[1]); // 0alert(ints[2]); // 0alert(ints[3]); // 0 </code></pre><h3 id="定型数组行为"><a href="#定型数组行为" class="headerlink" title="定型数组行为"></a>定型数组行为</h3><p>从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：</p><ol><li><p>[]</p></li><li><p>copyWithin()</p></li><li><p>entries()</p></li><li><p>every()</p></li><li><p>fill()</p></li><li><p>filter()</p></li><li><p>find()</p></li><li><p>findIndex()</p></li><li><p>forEach()</p></li><li><p>indexOf()</p></li><li><p>join()</p></li><li><p>keys()</p></li><li><p>lastIndexOf()</p></li><li><p>length</p></li><li><p>map()</p></li><li><p>reduce()</p></li><li><p>reduceRight()</p></li><li><p>reverse()</p></li><li><p>slice()</p></li><li><p>some()</p></li><li><p>sort()</p></li><li><p>toLocaleString()</p></li><li><p>toString()</p></li><li><p>values()</p></li></ol><p>其中，返回新数组的方法也会返回包含同样元素类型（element type）的新定型数组：</p><pre><code>const ints = new Int16Array([1, 2, 3]);const doubleints = ints.map(x =&gt; 2*x);alert(doubleints instanceof Int16Array); // true</code></pre><p>定型数组有一个 Symbol.iterator 符号属性，因此可以通过 for..of 循环和扩展操作符来操作：</p><pre><code>const ints = new Int16Array([1, 2, 3]);for (const int of ints) {    alert(int);}// 1// 2// 3alert(Math.max(...ints)); // 3 </code></pre><h3 id="合并、复制和修改定型数组"><a href="#合并、复制和修改定型数组" class="headerlink" title="合并、复制和修改定型数组"></a>合并、复制和修改定型数组</h3><p>定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：</p><ol><li><p>concat()</p></li><li><p>pop()</p></li><li><p>push()</p></li><li><p>shift()</p></li><li><p>splice()</p></li><li><p>unshift()</p></li></ol><p>不过，定型数组也提供了两个新方法，可以快速向外或向内复制数据：set()和 subarray()。set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：</p><pre><code>// 创建长度为 8 的 int16 数组const container = new Int16Array(8);// 把定型数组复制为前 4 个值// 偏移量默认为索引 0container.set(Int8Array.of(1, 2, 3, 4));console.log(container); // [1,2,3,4,0,0,0,0]// 把普通数组复制为后 4 个值// 偏移量 4 表示从索引 4 开始插入container.set([5,6,7,8], 4);console.log(container); // [1,2,3,4,5,6,7,8]// 溢出会抛出错误container.set([5,6,7,8], 7);// RangeError </code></pre><p>subarray()执行与 set()相反的操作，它会基于从原始定型数组中复制的值返回一个新定型数组。复制值时的开始索引和结束索引是可选的：</p><pre><code>const source = Int16Array.of(2, 4, 6, 8);// 把整个数组复制为一个同类型的新数组const fullCopy = source.subarray();console.log(fullCopy); // [2, 4, 6, 8]// 从索引 2 开始复制数组const halfCopy = source.subarray(2);console.log(halfCopy); // [6, 8]// 从索引 1 开始复制到索引 3const partialCopy = source.subarray(1, 3);console.log(partialCopy); // [4, 6]</code></pre><p>定型数组没有原生的拼接能力，但使用定型数组 API 提供的很多工具可以手动构建：</p><pre><code>// 第一个参数是应该返回的数组类型// 其余参数是应该拼接在一起的定型数组function typedArrayConcat(typedArrayConstructor, ...typedArrays) {    // 计算所有数组中包含的元素总数    const numElements = typedArrays.reduce((x,y) =&gt; (x.length || x) + y.length);    // 按照提供的类型创建一个数组，为所有元素留出空间    const resultArray = new typedArrayConstructor(numElements);    // 依次转移数组    let currentOffset = 0;    typedArrays.map(x =&gt; {        resultArray.set(x, currentOffset);        currentOffset += x.length;    });    return resultArray;}const concatArray = typedArrayConcat(Int32Array,                                     Int8Array.of(1, 2, 3),                                     Int16Array.of(4, 5, 6),                                     Float32Array.of(7, 8, 9));console.log(concatArray); // [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(concatArray instanceof Int32Array); // true</code></pre><h3 id="下溢和上溢"><a href="#下溢和上溢" class="headerlink" title="下溢和上溢"></a>下溢和上溢</h3><p>定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于可以存储的每个索引只接受一个相关位，而不考虑它们对实际数值的影响。以下代码演示了如何处理下溢和上溢：</p><pre><code>// 长度为 2 的有符号整数数组// 每个索引保存一个二补数形式的有符号整数// 范围是-128（-1 * 2^7）~127（2^7 - 1）const ints = new Int8Array(2);// 长度为 2 的无符号整数数组// 每个索引保存一个无符号整数// 范围是 0~255（2^7 - 1）const unsignedInts = new Uint8Array(2);// 上溢的位不会影响相邻索引// 索引只取最低有效位上的 8 位unsignedInts[1] = 256; // 0x100console.log(unsignedInts); // [0, 0]unsignedInts[1] = 511; // 0x1FFconsole.log(unsignedInts); // [0, 255]// 下溢的位会被转换为其无符号的等价值// 0xFF 是以二补数形式表示的-1（截取到 8 位）,// 但 255 是一个无符号整数unsignedInts[1] = -1 // 0xFF (truncated to 8 bits)console.log(unsignedInts); // [0, 255]// 上溢自动变成二补数形式// 0x80 是无符号整数的 128，是二补数形式的-128ints[1] = 128; // 0x80console.log(ints); // [0, -128]// 下溢自动变成二补数形式// 0xFF 是无符号整数的 255，是二补数形式的-1ints[1] = 255; // 0xFFconsole.log(ints); // [0, -1] </code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0005.html"/>
      <url>posts/a0005.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0004">集合引用类型(一) Object</a></strong><br>本篇: <strong>集合引用类型(二) Array</strong><br>下篇: <strong><a href="a0006">集合引用类型(三) 定型数组</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>除了 Object，Array 应该就是 ECMAScript 中最常用的类型了。ECMAScript 数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加自动增长。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：</p><p><code>let colors = new Array(); </code></p><p>如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始 length 为 20 的数组：</p><p><code>let colors = new Array(20); </code></p><p>也可以给 Array 构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的数组：</p><p><code>let colors = new Array("red", "blue", "green"); </code></p><p>另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表，如下面的例子所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个元素的数组let names = []; // 创建一个空数组let values = [1,2,]; // 创建一个包含 2 个元素的数组</code></pre><p><strong>注意</strong> 与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。</p><p>Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。</p><p>Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很多场合：</p><pre><code>// 字符串会被拆分为单字符数组console.log(Array.from("Matt")); // ["M", "a", "t", "t"]// 可以使用 from()将集合和映射转换为一个新数组const m = new Map().set(1, 2).set(3, 4);const s = new Set().add(1).add(2).add(3).add(4);console.log(Array.from(m)); // [[1, 2], [3, 4]]console.log(Array.from(s)); // [1, 2, 3, 4]// Array.from()对现有数组执行浅复制const a1 = [1, 2, 3, 4];const a2 = Array.from(a1);console.log(a1); // [1, 2, 3, 4]alert(a1 === a2); // false// 可以使用任何可迭代对象const iter = {    *[Symbol.iterator]() {        yield 1;        yield 2;        yield 3;        yield 4;    }};console.log(Array.from(iter)); // [1, 2, 3, 4] // arguments 对象可以被轻松地转换为数组function getArgsArray() {    return Array.from(arguments);}console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]// from()也能转换带有必要属性的自定义对象const arrayLikeObject = {    0: 1,    1: 2,    2: 3,    3: 4,    length: 4};console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]</code></pre><p>Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。但这个重写的 this 值在箭头函数中不适用。</p><pre><code>const a1 = [1, 2, 3, 4];const a2 = Array.from(a1, x =&gt; x**2);const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});console.log(a2); // [1, 4, 9, 16]console.log(a3); // [1, 4, 9, 16] </code></pre><p>Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：</p><pre><code>console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]console.log(Array.of(undefined)); // [undefined]</code></pre><h2 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h2><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。可以像下面这样创建一个空位数组：</p><pre><code>const options = [,,,,,]; // 创建包含 5 个元素的数组console.log(options.length); // 5console.log(options); // [,,,,,]</code></pre><p>ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined：</p><pre><code>const options = [1,,,,5];for (const option of options) {console.log(option === undefined);}// false// true// true// true// false </code></pre><p><strong>注意</strong> 由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替。</p><h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如下所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 定义一个字符串数组alert(colors[0]); // 显示第一项colors[2] = "black"; // 修改第三项colors[3] = "brown"; // 添加第四项</code></pre><p>使用 length 属性可以方便地向数组末尾添加元素，如下例所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[colors.length] = "black"; // 添加一种颜色（位置 3）colors[colors.length] = "brown"; // 再添加一种颜色（位置 4）</code></pre><p>length 属性会更新为位置加上 1，如下例所示：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组colors[99] = "black"; // 添加一种颜色（位置 99）alert(colors.length); // 100</code></pre><p>这里，colors 数组有一个值被插入到位置 99，结果新 length 就变成了 100（99 + 1）。这中间的所有元素，即位置 3~98，实际上并不存在，因此在访问时会返回 undefined。</p><p><strong>注意</strong> 数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误</p><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣：</p><pre><code>if (value instanceof Array){// 操作数组} </code></pre><p>使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。</p><p>为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：</p><pre><code>if (Array.isArray(value)){// 操作数组} </code></pre><h2 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h2><p>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引/值对的迭代器：</p><pre><code>const a = ["foo", "bar", "baz", "qux"];// 因为这些方法都返回迭代器，所以可以将它们的内容// 通过 Array.from()直接转换为数组实例const aKeys = Array.from(a.keys());const aValues = Array.from(a.values());const aEntries = Array.from(a.entries());console.log(aKeys); // [0, 1, 2, 3]console.log(aValues); // ["foo", "bar", "baz", "qux"]console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]] </code></pre><p>使用 ES6 的解构可以非常容易地在循环中拆分键/值对：</p><pre><code>const a = ["foo", "bar", "baz", "qux"];    for (const [idx, element] of a.entries()) {    alert(idx);    alert(element);}// 0// foo// 1// bar// 2// baz// 3// qux</code></pre><h2 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h2><p>ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p><p>使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p><pre><code>const zeroes = [0, 0, 0, 0, 0];// 用 5 填充整个数组zeroes.fill(5);console.log(zeroes); // [5, 5, 5, 5, 5]zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素zeroes.fill(6, 3);console.log(zeroes); // [0, 0, 0, 6, 6]zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素zeroes.fill(7, 1, 3);console.log(zeroes); // [0, 7, 7, 0, 0];zeroes.fill(0); // 重置// 用 8 填充索引大于等于 1 且小于 4 的元素// (-4 + zeroes.length = 1)// (-1 + zeroes.length = 4)zeroes.fill(8, -4, -1);console.log(zeroes); // [0, 8, 8, 8, 0];fill()静默忽略超出数组边界、零长度及方向相反的索引范围：const zeroes = [0, 0, 0, 0, 0];// 索引过低，忽略zeroes.fill(1, -10, -6);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引过高，忽略zeroes.fill(1, 10, 15);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引反向，忽略zeroes.fill(2, 4, 2);console.log(zeroes); // [0, 0, 0, 0, 0]// 索引部分可用，填充可用部分zeroes.fill(4, 3, 10)console.log(zeroes); // [0, 0, 0, 4, 4] </code></pre><p>与 fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法：</p><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><p>前面提到过，所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的例子：</p><pre><code>let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组alert(colors.toString()); // red,blue,greenalert(colors.valueOf()); // red,blue,greenalert(colors); // red,blue,green </code></pre><p>首先是被显式调用的 toString()和 valueOf()方法，它们分别返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。最后一行代码直接用 alert()显示数组，因为 alert()期待字符串，所以会在后台调用数组的 toString()方法，从而得到跟前面一样的结果。</p><p>在调用数组的 toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 toLocaleString()方法，而不是toString()方法。看下面的例子：</p><pre><code>let person1 = {    toLocaleString() {        return "Nikolaos";    },    toString() {        return "Nicholas";    }}; let person2 = {    toLocaleString() {        return "Grigorios";    },    toString() {        return "Greg";    }};let people = [person1, person2];alert(people); // Nicholas,Gregalert(people.toString()); // Nicholas,Gregalert(people.toLocaleString()); // Nikolaos,Grigorios </code></pre><p>这里定义了两个对象 person1 和 person2，它们都定义了 toString()和 toLocaleString()方法，而且返回不同的值。然后又创建了一个包含这两个对象的数组 people。在将数组传给 alert()时，输出的是”Nicholas,Greg”，这是因为会在数组每一项上调用 toString()方法（与下一行显式调用toString()方法结果一样）。而在调用数组的 toLocaleString()方法时，结果变成了”Nikolaos,Grigorios”，这是因为调用了数组每一项的 toLocaleString()方法。</p><p>继承的方法 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue"];alert(colors.join(",")); // red,green,bluealert(colors.join("||")); // red||green||blue</code></pre><p>这里在 colors 数组上调用了 join()方法，得到了与调用 toString()方法相同的结果。传入逗号，结果就是逗号分隔的字符串。最后一行给 join() 传入了双竖线，得到了字符串”red||green||blue”。如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。</p><h2 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h2><p>ECMAScript 给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。</p><p>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.push("red", "green"); // 推入两项alert(count); // 2count = colors.push("black"); // 再推入一项alert(count); // 3let item = colors.pop(); // 取得最后一项alert(item); // blackalert(colors.length); // 2 </code></pre><p>栈方法可以与数组的其他任何方法一起使用，如下例所示：</p><pre><code>let colors = ["red", "blue"];colors.push("brown"); // 再添加一项colors[3] = "black"; // 添加一项alert(colors.length); // 4let item = colors.pop(); // 取得最后一项alert(item); // black </code></pre><h2 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h2><p>就像栈是以 LIFO 形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.push("red", "green"); // 推入两项alert(count); // 2count = colors.push("black"); // 再推入一项alert(count); // 3let item = colors.shift(); // 取得第一项alert(item); // redalert(colors.length); // 2 </code></pre><p>ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示：</p><pre><code>let colors = new Array(); // 创建一个数组let count = colors.unshift("red", "green"); // 从数组开头推入两项alert(count); // 2count = colors.unshift("black"); // 再推入一项alert(count); // 3let item = colors.pop(); // 取得最后一项alert(item); // greenalert(colors.length); // 2 </code></pre><p>这里，先创建一个数组，再通过 unshift()填充数组。首先，给数组添加”red”和”green”，再添<br>加”black”，得到[ “black”,”red”,”green”]。调用 pop()时，删除最后一项”green”并返回它。</p><h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就是将数组元素反向排列。比如：</p><pre><code>let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1 </code></pre><p>数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就是将数组元素反向排列。比如：</p><pre><code>let values = [1, 2, 3, 4, 5];values.reverse();alert(values); // 5,4,3,2,1 </code></pre><p>一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串”10”在字符串”5”的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个比较函数，用于判断哪个值应该排在前面。</p><p>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一个例子：</p><pre><code>function compare(value1, value2) {    if (value1 &lt; value2) {    return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }} </code></pre><p>这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示：</p><pre><code>let values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 0,1,5,10,15 </code></pre><p>在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：</p><pre><code>function compare(value1, value2) {    if (value1 &lt; value2) {        return 1;    } else if (value1 &gt; value2) {        return -1;    } else {        return 0;    }}let values = [0, 1, 5, 10, 15];values.sort(compare);alert(values); // 15,10,5,1,0 </code></pre><p>此外，这个比较函数还可简写为一个箭头函数：</p><pre><code>let values = [0, 1, 5, 10, 15];values.sort((a, b) =&gt; a &lt; b ? 1 : a &gt; b ? -1 : 0);alert(values); // 15,10,5,1,0 </code></pre><p>如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值：</p><pre><code>function compare(value1, value2){    return value2 - value1;}</code></pre><p>比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue"];let colors2 = colors.concat("yellow", ["black", "brown"]);console.log(colors); // ["red", "green","blue"]console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"] </code></pre><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如   果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子：</p><pre><code>let colors = ["red", "green", "blue", "yellow", "purple"];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow </code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>splice()方法的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。</p><ol><li><p>删除。需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。</p></li><li><p>插入。需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, “red”, “green”)会从数组位置 2 开始插入字符串”red”和”green”。</p></li><li><p>替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入”red”和”green”。</p><p> let colors = [“red”, “green”, “blue”];<br> let removed = colors.splice(0,1); // 删除第一项<br> alert(colors); // green,blue<br> alert(removed); // red，只有一个元素的数组</p><p> removed = colors.splice(1, 0, “yellow”, “orange”); // 在位置 1 插入两个元素<br> alert(colors); // green,yellow,orange,blue<br> alert(removed); // 空数组</p><p> removed = colors.splice(1, 1, “red”, “purple”); // 插入两个值，删除一个元素<br> alert(colors); // green,red,purple,orange,blue<br> alert(removed); // yellow，只有一个元素的数组</p></li></ol><h2 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h2><h3 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h3><p>ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索</p><p>indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较，也就是说两项必须严格相等。下面来看一些例子：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];alert(numbers.indexOf(4)); // 3alert(numbers.lastIndexOf(4)); // 5alert(numbers.includes(4)); // truealert(numbers.indexOf(4, 4)); // 5alert(numbers.lastIndexOf(4, 4)); // 3alert(numbers.includes(4, 7)); // falselet person = { name: "Nicholas" };let people = [{ name: "Nicholas" }];let morePeople = [person];alert(people.indexOf(person)); // -1alert(morePeople.indexOf(person)); // 0alert(people.includes(person)); // falsealert(morePeople.includes(person)); // true </code></pre><h3 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h3><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p><p>find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。</p><pre><code>const people = [    {        name: "Matt",        age: 27    },{        name: "Nicholas",        age: 29    }];alert(people.find((element, index, array) =&gt; element.age &lt; 28));// {name: "Matt", age: 27}alert(people.findIndex((element, index, array) =&gt; element.age &lt; 28));// 0 </code></pre><p>找到匹配项后，这两个方法都不再继续搜索。</p><pre><code>const evens = [2, 4, 6];// 找到匹配后，永远不会检查数组的最后一个元素evens.find((element, index, array) =&gt; {    console.log(element);    console.log(index);    console.log(array);    return element === 4;});// 2// 0// [2, 4, 6]// 4// 1// [2, 4, 6] </code></pre><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身。</p><ol><li><p>every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</p></li><li><p>filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</p></li><li><p>forEach()：对数组每一项都运行传入的函数，没有返回值。</p></li><li><p>map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</p></li><li><p>some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</p></li></ol><p>这些方法都不改变调用它们的数组。</p><p>在这些方法中，every()和 some()是最相似的，都是从数组中搜索符合某个条件的元素。对 every()来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 some()来说，只要有一项让传入的函数返回 true，它就会返回 true。下面是一个例子：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);alert(everyResult); // falselet someResult = numbers.some((item, index, array) =&gt; item &gt; 2);alert(someResult); // true </code></pre><p>下面再看一看 filter()方法。这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。比如，要返回一个所有数值都大于 2 的数组，可以使用如下代码：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);alert(filterResult); // 3,4,5,4,3 </code></pre><p>这里，调用 filter()返回的数组包含 3、4、5、4、3，因为只有对这些项传入的函数才返回 true。这个方法非常适合从数组中筛选满足给定条件的元素。</p><p>接下来 map()方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let mapResult = numbers.map((item, index, array) =&gt; item * 2);alert(mapResult); // 2,4,6,8,10,8,6,4,2</code></pre><p>以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原始数组元素一一对应的新数组。</p><p>最后，再来看一看 forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值。本质上，forEach()方法相当于使用 for 循环遍历数组。比如：</p><pre><code>let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach((item, index, array) =&gt; {    // 执行某些操作}); </code></pre><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。</p><p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。</p><p>如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><p>可以使用 reduce()函数执行累加数组中所有数值的操作，比如：</p><pre><code>let values = [1, 2, 3, 4, 5];let sum = values.reduce((prev, cur, index, array) =&gt; prev + cur);alert(sum); // 15</code></pre><p>reduceRight()方法与之类似，只是方向相反。来看下面的例子：</p><pre><code>let values = [1, 2, 3, 4, 5];let sum = values.reduceRight(function(prev, cur, index, array){return prev + cur;});alert(sum); // 15 </code></pre><p>在这里，第一次调用归并函数时 prev 是 5，而 cur 是 4。当然，最终结果相同，因为归并操作都是简单的加法。究竟是使用 reduce()还是 reduceRight()，只取决于遍历数组元素的方向。除此之外，这两个方法没什么区别。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(四)</title>
      <link href="posts/a0004.html"/>
      <url>posts/a0004.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合引用类型"><a href="#集合引用类型" class="headerlink" title="集合引用类型"></a>集合引用类型</h1><p>上篇: <strong><a href="a0003">基本引用类型(四) 单例内置对象</a></strong><br>本篇: <strong>集合引用类型(一) Object</strong><br>下篇: <strong><a href="a0005">集合引用类型(二) Array</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="Objcet"><a href="#Objcet" class="headerlink" title="Objcet"></a>Objcet</h2><p>到目前为止，大多数引用值的示例使用的是 Object 类型。Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。</p><p>显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：</p><pre><code>let person = new Object();person.name = "Nicholas";person.age = 29; </code></pre><p>另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象字面量表示法：</p><pre><code>let person = {    name: "Nicholas",    age: 29};</code></pre><p>接下来指定了 name 属性，后跟一个冒号，然后是属性的值。逗号用于在对象字面量中分隔属性，因此字符串”Nicholas”后面有一个逗号，而 29 后面没有，因为 age 是这个对象的最后一个属性。</p><p>在对象字面量表示法中，属性名可以是字符串或数值，比如：</p><pre><code>let person = {    "name": "Nicholas",    "age": 29,    5: true}; </code></pre><p>这个例子会得到一个带有属性 name、age 和 5 的对象。注意，数值属性会自动转换为字符串。</p><p>当然也可以用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行了：</p><pre><code>let person = {}; // 与 new Object()相同person.name = "Nicholas";person.age = 29; </code></pre><p>虽然使用哪种方式创建 Object 实例都可以，但实际上开发者更倾向于使用对象字面量表示法。这是因为对象字面量代码更少，看起来也更有封装所有相关数据的感觉。事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，比如：</p><pre><code>function displayInfo(args) {    let output = "";    if (typeof args.name == "string"){        output += "Name: " + args.name + "\n";    }    if (typeof args.age == "number") {        output += "Age: " + args.age + "\n";    }    alert(output);}displayInfo({    name: "Nicholas",    age: 29});displayInfo({    name: "Greg"});</code></pre><p>虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p><pre><code>console.log(person["name"]); // "Nicholas"console.log(person.name); // "Nicholas" </code></pre><p>从功能上讲，这两种存取属性的方式没有区别。使用中括号的主要优势就是可以通过变量访问属性，就像下面这个例子中一样：</p><pre><code>let propertyName = "name";console.log(person[propertyName]); // "Nicholas"</code></pre><p>通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。</p><p><strong>注意</strong> 第 5 章将更全面、深入地介绍 Object 类型</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0003.html"/>
      <url>posts/a0003.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="a0002">基本引用类型(三) 原始值包装类型</a></strong><br>本篇: <strong>基本引用类型(四) 单例内置对象</strong><br>下篇: <strong><a href="a0004">集合引用类型(一) Object</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h2><p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”。这就意味着，开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已经接触了大部分内置对象，包括 Object、Array 和 String。本节介绍 ECMA-262定义的另外两个单例内置对象：Global 和 Math。</p><h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>Global 对象是 ECMAScript 中最特别的对象，因为代码不会显式地访问它。ECMA-262 规定 Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。</p><h4 id="URL-编码方法"><a href="#URL-编码方法" class="headerlink" title="URL 编码方法"></a>URL 编码方法</h4><p>encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。使用 URI 编码方法来编码 URI 可以让浏览器能够理解们，同时又以特殊的 UTF-8 编码替换掉所有无效字符。</p><p>ecnodeURI()方法用于对整个 URI 进行编码，比如”<a href="http://www.wrox.com/illegal">www.wrox.com/illegal</a> value.js”。而encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的”illegal value.js”。</p><p>这两个方法的主要区别是，encodeURI()不会编码属于 URL 组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent()会编码它发现的所有非标准字符。来看下面的例子：</p><pre><code>let uri = "http://www.wrox.com/illegal value.js#start";// "http://www.wrox.com/illegal%20value.js#start"console.log(encodeURI(uri));// "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start"console.log(encodeURIComponent(uri)); </code></pre><p><strong>注意</strong> 一般来说，使用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多。</p><p>与 encodeURI()和 encodeURIComponent()相对的是 decodeURI()和 decodeURIComponent()。decodeURI()只对使用 encodeURI()编码过的字符解码。例如，%20 会被替换为空格，但%23 不会被替换为井号（#），因为井号不是由 encodeURI()替换的。类似地，decodeURIComponent()解码所有被 encodeURIComponent()编码的字符，基本上就是解码所有特殊值。来看下面的例子：</p><pre><code>let uri = "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.js%23start";// http%3A%2F%2Fwww.wrox.com%2Fillegal value.js%23startconsole.log(decodeURI(uri));// http:// www.wrox.com/illegal value.js#startconsole.log(decodeURIComponent(uri));</code></pre><h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h4><p>最后一个方法可能是整个 ECMAScript 语言中最强大的了，它就是 eval()。这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串。来看一个例子：</p><p><code>eval("console.log('hi')");</code></p><p>上面这行代码的功能与下一行等价：</p><p><code>console.log("hi");</code></p><p>通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链。这意味着定义在包含上下文中的变量可以在 eval()调用内部被引用，比如下面这个例子：</p><pre><code>let msg = "hello world";eval("console.log(msg)"); // "hello world" </code></pre><p>这里，变量 msg 是在 eval()调用的外部上下文中定义的，而 console.log()显示了文本”helloworld”。这是因为第二行代码会被替换成一行真正的函数调用代码。类似地，可以在 eval()内部定义一个函数或变量，然后在外部代码中引用，如下所示：</p><pre><code>eval("function sayHi() { console.log('hi'); }");sayHi();</code></pre><p>对于变量也是一样的：</p><pre><code>eval("let msg = 'hello world';");console.log(msg); // Reference Error: msg is not defined </code></pre><p>通过 eval()定义的任何变量和函数都不会被提升，这是因为在解析代码的时候，它们是被包含在一个字符串中的。它们只是在 eval()执行的时候才会被创建。</p><p>在严格模式下，在 eval()内部创建的变量和函数无法被外部访问。换句话说，最后两个例子会报错。同样，在严格模式下，赋值给 eval 也会导致错误：</p><pre><code>"use strict";eval = "hi"; // 导致错误</code></pre><p><strong>注意</strong> 解释代码字符串的能力是非常强大的，但也非常危险。在使用 eval()的时候必须极为慎重，特别是在解释用户输入的内容时。因为这个方法会对 XSS 利用暴露出很大的攻击面。恶意用户可能插入会导致你网站或应用崩溃的代码。</p><h4 id="Global-对象属性"><a href="#Global-对象属性" class="headerlink" title="Global 对象属性"></a>Global 对象属性</h4><p>Global 对象有很多属性，其中一些前面已经提到过了。像 undefined、NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function，也都是Global 对象的属性。下表列出了所有这些属性。</p><table><thead><tr><th align="left">属 性</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">undefined</td><td align="left">特殊值 undefined</td></tr><tr><td align="left">NaN</td><td align="left">特殊值 NaN</td></tr><tr><td align="left">Infinity</td><td align="left">特殊值 Infinity</td></tr><tr><td align="left">Object</td><td align="left">Object 的构造函数</td></tr><tr><td align="left">Array</td><td align="left">Array 的构造函数</td></tr><tr><td align="left">Function</td><td align="left">Function 的构造函数</td></tr><tr><td align="left">Boolean</td><td align="left">Boolean 的构造函数</td></tr><tr><td align="left">String</td><td align="left">String 的构造函数</td></tr><tr><td align="left">Number</td><td align="left">Number 的构造函数</td></tr><tr><td align="left">Date</td><td align="left">Date 的构造函数</td></tr><tr><td align="left">RegExp</td><td align="left">RegExp 的构造函数</td></tr><tr><td align="left">Symbol</td><td align="left">Symbol 的伪构造函数</td></tr><tr><td align="left">Error</td><td align="left">Error 的构造函数</td></tr><tr><td align="left">EvalError</td><td align="left">EvalError 的构造函数</td></tr><tr><td align="left">RangeError</td><td align="left">RangeError 的构造函数</td></tr><tr><td align="left">ReferenceError</td><td align="left">ReferenceError 的构造函数</td></tr><tr><td align="left">SyntaxError</td><td align="left">SyntaxError 的构造函数</td></tr><tr><td align="left">TypeError</td><td align="left">TypeError 的构造函数</td></tr><tr><td align="left">URIError</td><td align="left">URIError 的构造函数</td></tr></tbody></table><h4 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h4><p>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。来看下面的例子：</p><pre><code>var color = "red";function sayColor() {    console.log(window.color);}window.sayColor(); // "red" </code></pre><p><strong>注意</strong> window 对象在 JavaScript 中远不止实现了 ECMAScript 的 Global 对象那么简单。<br>关于 window 对象的更多介绍，请参考第 9 章。</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。</p><p><strong>注意</strong> Math 对象上提供的计算要比直接在 JavaScript 实现的快得多，因为 Math 对象上的计算使用了 JavaScript 引擎中更高效的实现和处理器指令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和硬件而异。</p><h4 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h4><p>Math 对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。</p><table><thead><tr><th align="left">属 性</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Math.E</td><td align="left">自然对数的基数 e 的值</td></tr><tr><td align="left">Math.LN10</td><td align="left">10 为底的自然对数</td></tr><tr><td align="left">Math.LN2</td><td align="left">2 为底的自然对数</td></tr><tr><td align="left">Math.LOG2E</td><td align="left">以 2 为底 e 的对数</td></tr><tr><td align="left">Math.LOG10E</td><td align="left">以 10 为底 e 的对数</td></tr><tr><td align="left">Math.PI</td><td align="left">π 的值</td></tr><tr><td align="left">Math.SQRT1_2</td><td align="left">1/2 的平方根</td></tr><tr><td align="left">Math.SQRT2</td><td align="left">2 的平方根</td></tr></tbody></table><h4 id="min-和-max-方法"><a href="#min-和-max-方法" class="headerlink" title="min()和 max()方法"></a>min()和 max()方法</h4><p>Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数，如下面的例子所示：</p><pre><code>let max = Math.max(3, 54, 32, 16);console.log(max); // 54let min = Math.min(3, 54, 32, 16);console.log(min); // 3 </code></pre><p>要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符：</p><pre><code>let values = [1, 2, 3, 4, 5, 6, 7, 8];let max = Math.max(...val); </code></pre><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><p>接下来是用于把小数值舍入为整数的 4 个方法：Math.ceil()、Math.floor()、Math.round()和 Math.fround()。这几个方法处理舍入的方式如下所述。</p><ol><li><p>Math.ceil()方法始终向上舍入为最接近的整数。</p></li><li><p>Math.floor()方法始终向下舍入为最接近的整数。</p></li><li><p>Math.round()方法执行四舍五入。</p></li><li><p>Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示。</p></li></ol><p>以下示例展示了这些方法的用法：</p><pre><code>console.log(Math.ceil(25.9)); // 26console.log(Math.ceil(25.5)); // 26console.log(Math.ceil(25.1)); // 26console.log(Math.round(25.9)); // 26console.log(Math.round(25.5)); // 26console.log(Math.round(25.1)); // 25console.log(Math.fround(0.4)); // 0.4000000059604645console.log(Math.fround(0.5)); // 0.5console.log(Math.fround(25.9)); // 25.899999618530273console.log(Math.floor(25.9)); // 25console.log(Math.floor(25.5)); // 25console.log(Math.floor(25.1)); // 25 </code></pre><h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4><p>Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 Math.random()从一组整数中随机选择一个数：</p><p><code>number = Math.floor(Math.random() * total_number_of_choices +first_possible_value) </code></p><p>这里使用了 Math.floor()方法，因为 Math.random()始终返回小数，即便乘以一个数再加上一个数也是小数。因此，如果想从 1~10 范围内随机选择一个数，代码就是这样的：</p><p><code>let num = Math.floor(Math.random() * 10 + 1);</code></p><p>这样就有 10 个可能的值（1<del>10），其中最小的值是 1。如果想选择一个 2</del>10 范围内的值，则代码就要写成这样：</p><p><code>let num = Math.floor(Math.random() * 9 + 2); </code></p><p>2~10 只有 9 个数，所以可选总数（total_number_of_choices）是 9，而最小可能的值（first_possible_value）是 2。很多时候，通过函数来算出可选总数和最小可能的值可能更方便，比如：</p><pre><code>function selectFrom(lowerValue, upperValue) {    let choices = upperValue - lowerValue + 1;    return Math.floor(Math.random() * choices + lowerValue);}let num = selectFrom(2,10);console.log(num); // 2~10 范围内的值，其中包含 2 和 10 </code></pre><p>这里的函数 selectFrom()接收两个参数：应该返回的最小值和最大值。通过将这两个值相减再加 1 得到可选总数，然后再套用上面的公式。于是，调用 selectFrom(2,10)就可以从 2~10（包含）范围内选择一个值了。使用这个函数，从一个数组中随机选择一个元素就很容易，比如：</p><pre><code>let colors = ["red", "green", "blue", "yellow", "black", "purple", "brown"];let color = colors[selectFrom(0, colors.length-1)]; </code></pre><p><strong>注意</strong> 如果是为了加密而需要生成随机数（传给生成器的输入需要较高的不确定性），那么建议使用 window.crypto.getRandomValues()。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>Math 对象还有很多涉及各种简单或高阶数运算的方法。</p><table><thead><tr><th align="left">方 法</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">Math.abs(x)</td><td align="left">返回 x 的绝对值</td></tr><tr><td align="left">Math.exp(x)</td><td align="left">返回 Math.E 的 x 次幂</td></tr><tr><td align="left">Math.expm1(x)</td><td align="left">等于 Math.exp(x) - 1</td></tr><tr><td align="left">Math.log(x)</td><td align="left">返回 x 的自然对数</td></tr><tr><td align="left">Math.log1p(x)</td><td align="left">等于 1 + Math.log(x)</td></tr><tr><td align="left">Math.pow(x, power)</td><td align="left">返回 x 的 power 次幂</td></tr><tr><td align="left">Math.hypot(…nums)</td><td align="left">返回 nums 中每个数平方和的平方根</td></tr><tr><td align="left">Math.clz32(x)</td><td align="left">返回 32 位整数 x 的前置零的数量</td></tr><tr><td align="left">Math.sign(x)</td><td align="left">返回表示 x 符号的 1、0、-0 或-1</td></tr><tr><td align="left">Math.trunc(x)</td><td align="left">返回 x 的整数部分，删除所有小数</td></tr><tr><td align="left">Math.sqrt(x)</td><td align="left">返回 x 的平方根</td></tr><tr><td align="left">Math.cbrt(x)</td><td align="left">返回 x 的立方根</td></tr><tr><td align="left">Math.acos(x)</td><td align="left">返回 x 的反余弦</td></tr><tr><td align="left">Math.acosh(x)</td><td align="left">返回 x 的反双曲余弦</td></tr><tr><td align="left">Math.asin(x)</td><td align="left">返回 x 的反正弦</td></tr><tr><td align="left">Math.asinh(x)</td><td align="left">返回 x 的反双曲正弦</td></tr><tr><td align="left">Math.atan(x)</td><td align="left">返回 x 的反正切</td></tr><tr><td align="left">Math.atanh(x)</td><td align="left">返回 x 的反双曲正切</td></tr><tr><td align="left">Math.atan2(y, x)</td><td align="left">返回 y/x 的反正切</td></tr><tr><td align="left">Math.cos(x)</td><td align="left">返回 x 的余弦</td></tr><tr><td align="left">Math.sin(x)</td><td align="left">返回 x 的正弦</td></tr><tr><td align="left">Math.tan(x)</td><td align="left">返回 x 的正切</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0002.html"/>
      <url>posts/a0002.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong><br>本篇: <strong>基本引用类型(三) 原始值包装类型</strong><br>下篇: <strong><a href="a0003">基本引用类型(四) 单例内置对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p><pre><code>let s1 = "some text";let s2 = s1.substring(2);</code></pre><p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：</p><p>(1) 创建一个 String 类型的实例；<br>(2) 调用实例上的特定方法；<br>(3) 销毁实例。</p><p>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p><pre><code>let s1 = new String("some text");let s2 = s1.substring(2);s1 = null;</code></pre><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过<br>用的是 Boolean 和 Number 包装类型而已。</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p><pre><code>let s1 = "some text";s1.color = "red";console.log(s1.color); // undefined</code></pre><p>可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 typeof 会返回”object”，所有原始值包装对象都会转换为布尔值 true。</p><p>另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p><pre><code>let obj = new Object("some text");console.log(obj instanceof String); // true</code></pre><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：</p><p><code>let booleanObject = new Boolean(true);</code></p><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。</p><p>不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：</p><pre><code>let falseObject = new Boolean(false);let result = falseObject &amp;&amp; true;console.log(result); // truelet falseValue = false;result = falseValue &amp;&amp; true;console.log(result); // false</code></pre><p>在这段代码中，我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。</p><p>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：</p><pre><code>console.log(typeof falseObject); // objectconsole.log(typeof falseValue); // booleanconsole.log(falseObject instanceof Boolean); // trueconsole.log(falseValue instanceof Boolean); // false</code></pre><p>理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：</p><p><code>let numberObject = new Number(10);</code></p><p>valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>toFixed()方法返回包含指定小数点位数的数值字符串，如：</p><pre><code>let num = 10;console.log(num.toFixed(2)); // "10.00"</code></pre><p>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小位：</p><pre><code>let num = 10.005;console.log(num.toFixed(2)); // "10.01"</code></pre><p>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。</p><p>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：</p><pre><code>let num = 10;console.log(num.toExponential(1)); // "1.0e+1"</code></pre><p>toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：</p><pre><code>let num = 99;console.log(num.toPrecision(1)); // "1e+2"console.log(num.toPrecision(2)); // "99"console.log(num.toPrecision(3)); // "99.0" </code></pre><p>与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。</p><pre><code>let numberObject = new Number(10);let numberValue = 10;console.log(typeof numberObject); // "object"console.log(typeof numberValue); // "number"console.log(numberObject instanceof Number); // trueconsole.log(numberValue instanceof Number); // false </code></pre><p>isInteger()方法与安全整数<br>ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0可能会让人误以为数值是一个浮点值：</p><pre><code>console.log(Number.isInteger(1)); // trueconsole.log(Number.isInteger(1.00)); // trueconsole.log(Number.isInteger(1.01)); // false</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值，如下例所示：</p><p><code>let stringObject = new String("hello world");</code></p><p>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleStrin()和 toString()都返回对象的原始字符串值。</p><p>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.length); // "11"</code></pre><p>charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p><pre><code>let message = "abcde";console.log(message.charAt(2)); // "c" </code></pre><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p>首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world");console.log(result); // "hello world"console.log(stringValue); // "hello" </code></pre><p>在这个例子中，对 stringValue 调 用 concat()方法的结果是得到”hello world”， 但<br>stringValue 的值保持不变。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字串，如下所示：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world", "!");console.log(result); // "hello world!"console.log(stringValue); // "hello"</code></pre><p>虽然 concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对拼接多个字符串来说，使用加号更方便。</p><p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：slice()、substr()和 substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是取结束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样，slice()substr()和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.slice(3)); // "lo world"console.log(stringValue.substring(3)); // "lo world"console.log(stringValue.substr(3)); // "lo world"console.log(stringValue.slice(3, 7)); // "lo w"console.log(stringValue.substring(3,7)); // "lo w"console.log(stringValue.substr(3, 7)); // "lo worl"</code></pre><p>substr()返回”lo worl”，因为第二个参数对它而言表示返回的字符数</p><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o")); // 4console.log(stringValue.lastIndexOf("o")); // 7</code></pre><p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o", 6)); // 7console.log(stringValue.lastIndexOf("o", 6)); // 4 </code></pre><p>像这样使用第二个参数并循环调用indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串，如下所示：</p><pre><code>let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";let positions = new Array();let pos = stringValue.indexOf("e");while(pos &gt; -1) {    positions.push(pos);    pos = stringValue.indexOf("e", pos + 1);}console.log(positions); // [3,24,32,35,52]</code></pre><p>这个例子逐步增大开始搜索的位置，通过 indexOf()遍历了整个字符串。首先取得第一个”e”的位置，然后进入循环，将上一次的位置加 1 再传给 indexOf()，确保搜索到最后一个子字符串实例之后。每个位置都保存在 positions 数组中，可供以后使用。</p><h4 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h4><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("bar")); // falseconsole.log(message.endsWith("baz")); // trueconsole.log(message.endsWith("bar")); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("qux")); // false</code></pre><p>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("foo", 1)); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("bar", 4)); // false</code></pre><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p><pre><code>let stringValue = " hello world ";let trimmedStringValue = stringValue.trim();console.log(stringValue); // " hello world "console.log(trimmedStringValue); // "hello world"</code></pre><p>由于 trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。另外，trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</p><h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p><pre><code>let stringValue = "na ";console.log(stringValue.repeat(16) + "batman");// na na na na na na na na na na na na na na na na batman</code></pre><h4 id="padStart-和-padEnd-方法"><a href="#padStart-和-padEnd-方法" class="headerlink" title="padStart()和 padEnd()方法"></a>padStart()和 padEnd()方法</h4><p>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(6)); // " foo"console.log(stringValue.padStart(9, ".")); // "......foo"console.log(stringValue.padEnd(6)); // "foo "console.log(stringValue.padEnd(9, ".")); // "foo......"</code></pre><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(8, "bar")); // "barbafoo"console.log(stringValue.padStart(2)); // "foo"console.log(stringValue.padEnd(8, "bar")); // "foobarba"console.log(stringValue.padEnd(2)); // "foo"</code></pre><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><p>下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的法，与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在于特定地区实现。</p><pre><code>let stringValue = "hello world";console.log(stringValue.toLocaleUpperCase()); // "HELLO WORLD"console.log(stringValue.toUpperCase()); // "HELLO WORLD"console.log(stringValue.toLocaleLowerCase()); // "hello world"console.log(stringValue.toLowerCase()); // "hello world" </code></pre><h4 id="字符串模式匹配方法"><a href="#字符串模式匹配方法" class="headerlink" title="字符串模式匹配方法"></a>字符串模式匹配方法</h4><p>String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。来看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;// 等价于 pattern.exec(text)let matches = text.match(pattern);console.log(matches.index); // 0console.log(matches[0]); // "cat"console.log(pattern.lastIndex); // 0</code></pre><p>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返-1。search()始终从字符串开头向后匹配模式。看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pos = text.search(/at/);console.log(pos); // 1 </code></pre><p>为简化子字符串替换操作，ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let result = text.replace("at", "ond");console.log(result); // "cond, bat, sat, fat"result = text.replace(/at/g, "ond");console.log(result); // "cond, bond, sond, fond"</code></pre><p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262 中规定了下表中的值。</p><table><thead><tr><th align="left">字符序列</th><th align="left">替换文本</th></tr></thead><tbody><tr><td align="left">$$</td><td align="left">$</td></tr><tr><td align="left">$&amp;</td><td align="left">匹配整个模式的子字符串。与 RegExp.lastMatch 相同</td></tr><tr><td align="left">$’</td><td align="left">匹配的子字符串之前的字符串。与 RegExp.rightContext 相同</td></tr><tr><td align="left">$`</td><td align="left">匹配的子字符串之后的字符串。与 RegExp.leftContext 相同</td></tr><tr><td align="left">$n</td><td align="left">匹配第 n 个捕获组的字符串，其中 n 是 0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr><tr><td align="left">$nn</td><td align="left">匹配第 nn 个捕获组字符串，其中 nn 是 01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr></tbody></table><p>使用这些特殊的序列，可以在替换文本中使用之前匹配的内容，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";result = text.replace(/(.at)/g, "word ($1)");console.log(result); // word (cat), word (bat), word (sat), word (fat)</code></pre><p>这里，每个以”at”结尾的词都会被替换成”word”后跟一对小括号，其中包含捕获组匹配的内容$1。</p><p>replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程，如下所示：</p><pre><code>function htmlEscape(text) {    return text.replace(/[&lt;&gt;"&amp;]/g, function(match, pos, originalText) {        switch(match) {            case "&lt;":            return "&amp;lt;";            case "&gt;":            return "&amp;gt;";            case "&amp;":            return "&amp;amp;";            case "\"":            return "&amp;quot;";        }    });}console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"));// "&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&lt;/p&gt;" </code></pre><p>这里，函数 htmlEscape()用于将一段 HTML 中的 4 个字符替换成对应的实体：小于号、大于号、和号，还有双引号（都必须经过转义）。实现这个任务最简单的办法就是用一个正则表达式查找这些字符，然后定义一个函数，根据匹配的每个字符分别返回特定的 HTML 实体。</p><p>最后一个与模式匹配相关的字符串方法是 split()。这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。（字符串分隔符不会被这个方法当成正则表达式。）还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。来看下面的例子：</p><pre><code>let colorText = "red,blue,green,yellow";let colors1 = colorText.split(","); // ["red", "blue", "green", "yellow"]let colors2 = colorText.split(",", 2); // ["red", "blue"]let colors3 = colorText.split(/[^,]+/); // ["", ",", ",", ",", ""]</code></pre><p>在这里，字符串 colorText 是一个逗号分隔的颜色名称符串。调用 split(“,”)会得到包含这些颜色名的数组，基于逗号进行拆分。要把数组元素限制为 2 个，传入第二个参数 2 即可。最后，使用正则表达式可以得到一个包含逗号的数组。注意在最后一次调用 split()时，返回的数组前后包含两个空字符串。这是因为正则表达式指定的分隔符出现在了字符串开头（”red”）和末尾（”yellow”）。</p><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h4><p>最后一个方法是 localeCompare()，这个方法比较两个字符串，返回如下 3 个值中的一个。</p><ol><li><p>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是-1，具体还要看与实际值相关的实现。）</p></li><li><p>如果字符串与字符串参数相等，则返回 0。</p></li><li><p>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1，具体还要看与实际值相关的实现。）</p></li></ol><p>下面是一个例子：</p><pre><code>let stringValue = "yellow";console.log(stringValue.localeCompare("brick")); // 1console.log(stringValue.localeCompare("yellow")); // 0console.log(stringValue.localeCompare("zoo")); // -1</code></pre><p>强调一下，因为返回的具体值可能因具体实现而异，所以最好像下面的示例中一样使用localeCompare()：</p><pre><code>function determineOrder(value) {    let result = stringValue.localeCompare(value);    if (result &lt; 0) {        console.log(`The string 'yellow' comes before the string '${value}'.`);    } else if (result &gt; 0) {        console.log(`The string 'yellow' comes after the string '${value}'.`);    } else {        console.log(`The string 'yellow' is equal to the string '${value}'.`);    }}determineOrder("brick");determineOrder("yellow");determineOrder("zoo");</code></pre><p>这样一来，就可以保证在所有实现中都能正确判断字符串的顺序了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0001.html"/>
      <url>posts/a0001.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong><br>本篇: <strong>基本引用类型(二) RegExp</strong><br>下篇: <strong><a href="a0002">基本引用类型(三) 原始值包装类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p><ol><li><p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</p></li><li><p>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</p></li><li><p>m：多行模式，表示查找到一行文本末尾时会继续查找。</p></li><li><p>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</p></li><li><p>u：Unicode 模式，启用 Unicode 匹配。</p></li><li><p>s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</p></li></ol><p>使用不同模式和标记可以创建出各种正则表达式，比如：</p><pre><code>// 匹配字符串中的所有"at"let pattern1 = /at/g;// 匹配第一个"bat"或"cat"，忽略大小写let pattern2 = /[bc]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi; </code></pre><p>与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：</p><p>( [ { \ ^ $ | ) ] } ? * + . </p><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 匹配第一个"[bc]at"，忽略大小写let pattern2 = /\[bc\]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi;// 匹配所有".at"，忽略大小写let pattern4 = /\.at/gi; </code></pre><p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 跟 pattern1 一样，只不过是用构造函数创建的let pattern2 = new RegExp("[bc]at", "i"); </code></pre><p>注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。</p><table><thead><tr><th align="left">字面量模式</th><th align="left">对应的字符串</th></tr></thead><tbody><tr><td align="left">/\[bc\]at/</td><td align="left">“\\[bc\\]at”</td></tr><tr><td align="left">/\.at/</td><td align="left">“\\.at”</td></tr><tr><td align="left">/name\/age/</td><td align="left">“name\\/age”</td></tr><tr><td align="left">/\d.\d{1,2}/</td><td align="left">“\\d.\\d{1,2}”</td></tr><tr><td align="left">/\w\\hello\\123/</td><td align="left">“\\w\\\\hello\\\\123”</td></tr></tbody></table><p>此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><pre><code>const re1 = /cat/g;console.log(re1); // "/cat/g"const re2 = new RegExp(re1);console.log(re2); // "/cat/g"const re3 = new RegExp(re1, "i");console.log(re3); // "/cat/i" </code></pre><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。</p><ol><li><p>global：布尔值，表示是否设置了 g 标记。</p></li><li><p>ignoreCase：布尔值，表示是否设置了 i 标记。</p></li><li><p>unicode：布尔值，表示是否设置了 u 标记。</p></li><li><p>sticky：布尔值，表示是否设置了 y 标记。</p></li><li><p>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</p></li><li><p>multiline：布尔值，表示是否设置了 m 标记。</p></li><li><p>dotAll：布尔值，表示是否设置了 s 标记。</p></li><li><p>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</p></li><li><p>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</p></li></ol><p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含<br>这些信息。下面是一个例子：</p><pre><code>let pattern1 = /\[bc\]at/i;console.log(pattern1.global); // falseconsole.log(pattern1.ignoreCase); // trueconsole.log(pattern1.multiline); // falseconsole.log(pattern1.lastIndex); // 0console.log(pattern1.source); // "\[bc\]at"console.log(pattern1.flags); // "i"let pattern2 = new RegExp("\\[bc\\]at", "i");console.log(pattern2.global); // falseconsole.log(pattern2.ignoreCase); // trueconsole.log(pattern2.multiline); // falseconsole.log(pattern2.lastIndex); // 0console.log(pattern2.source); // "\[bc\]at"console.log(pattern2.flags); // "i" </code></pre><p>注意，虽然第一个模式是通过字面量创建的，第二个模式是通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。</p><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p><pre><code>let text = "mom and dad and baby";let pattern = /mom( and dad( and baby)?)?/gi;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" </code></pre><p>在这个例子中，模式包含两个捕获组：最内部的匹配项” and baby”，以及外部的匹配项” and dad”或” and dad and baby”。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获的字符串，第三个元素是匹配第二个捕获组的字符串。</p><p>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0 </code></pre><p>上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（”cat”）。lastIndex在非全局模式下始终不变。</p><p>如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/g;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8matches = pattern.exec(text);console.log(matches.index); // 10console.log(matches[0]); // satconsole.log(pattern.lastIndex); // 13</code></pre><p>这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。</p><p>如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/y;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3// 以索引 3 对应的字符开头找不到匹配项，因此 exec()返回 null// exec()没找到匹配项，于是将 lastIndex 设置为 0matches = pattern.exec(text);console.log(matches); // nullconsole.log(pattern.lastIndex); // 0// 向前设置 lastIndex 可以让粘附的模式通过 exec()找到下一个匹配项：pattern.lastIndex = 5;matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8</code></pre><p>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p><pre><code>let text = "000-00-0000";let pattern = /\d{3}-\d{2}-\d{4}/;if (pattern.test(text)) {console.log("The pattern was matched."); </code></pre><p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p><p>无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：</p><pre><code>let pattern = new RegExp("\\[bc\\]at", "gi");console.log(pattern.toString()); // /\[bc\]at/giconsole.log(pattern.toLocaleString()); // /\[bc\]at/gi</code></pre><p>这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。</p><p><strong>注意</strong> 正则表达式的 valueOf()方法返回正则表达式本身。</p><h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>每个属性都有一个全名和一个简写。下表列出了RegExp 构造函数的属性</p><table><thead><tr><th align="left">全 名</th><th align="left">简 写</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">input</td><td align="left">$_</td><td align="left">最后搜索的字符串（非标准特性）</td></tr><tr><td align="left">lastMatch</td><td align="left">$&amp;</td><td align="left">最后匹配的文本</td></tr><tr><td align="left">lastParen</td><td align="left">$+</td><td align="left">最后匹配的捕获组（非标准特性）</td></tr><tr><td align="left">leftContext</td><td align="left">$`</td><td align="left">input 字符串中出现在 lastMatch 前面的文本</td></tr><tr><td align="left">rightContext</td><td align="left">$’</td><td align="left">input 字符串中出现在 lastMatch 后面的文本</td></tr></tbody></table><p>通过这些属性可以提取出与 exec()和 test()执行的操作相关的信息。来看下面的例子：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;if (pattern.test(text)) {  console.log(RegExp.input); // this has been a short summer  console.log(RegExp.leftContext); // this has been a  console.log(RegExp.rightContext); // summer  console.log(RegExp.lastMatch); // short  console.log(RegExp.lastParen); // s} </code></pre><p>以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下</p><ol><li><p>input 属性中包含原始的字符串。</p></li><li><p>leftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。</p></li><li><p>lastMatch 属性包含匹配整个正则表达式的上一个字符串，即”short”。</p></li><li><p>lastParen 属性包含捕获组的上一次匹配，即”s”。</p></li></ol><p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的 ECMAScript 标识符：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;/** 注意：Opera 不支持简写属性名* IE 不支持多行匹配*/if (pattern.test(text)) {  console.log(RegExp.$_); // this has been a short summer  console.log(RegExp["$`"]); // this has been a  console.log(RegExp["$'"]); // summer  console.log(RegExp["$&amp;"]); // short  console.log(RegExp["$+"]); // s}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/58a1.html"/>
      <url>posts/58a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong><br>本篇: <strong>基本引用类型(一) Date</strong><br>下篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月1 日之前及之后的日期。</p><p>要创建日期对象，就使用 new 操作符来调用 Date 构造函数：</p><p><code>let now = new Date();</code></p><p>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒<br>数。</p><ol><li>“月/日/年”，如”5/23/2019”；</li><li>“月名 日, 年”，如”May 23, 2019”；</li><li>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”；</li><li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00</li></ol><p>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：</p><p><code>let someDate = new Date(Date.parse("May 23, 2019")); </code></p><p>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：</p><p><code>let someDate = new Date("May 23, 2019"); </code></p><p>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：</p><pre><code>// GMT 时间 2000 年 1 月 1 日零点let y2k = new Date(Date.UTC(2000, 0));// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); </code></pre><p>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><pre><code>// 起始时间let start = Date.now();// 调用函数doSomething();// 结束时间let stop = Date.now(),result = stop - start;</code></pre><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为”en-US”的 PST，即 Pacific Standard Time，太平洋标准时间）：</p><pre><code>toLocaleString() - 2/1/2019 12:00:00 AMtoString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) </code></pre><p>Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：</p><pre><code>let date1 = new Date(2019, 0, 1); // 2019 年 1 月 1 日let date2 = new Date(2019, 1, 1); // 2019 年 2 月 1 日console.log(date1 &lt; date2); // trueconsole.log(date1 &gt; date2); // false </code></pre><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ol><li><p>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；</p></li><li><p>toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）;</p></li><li><p>toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；</p></li><li><p>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；</p></li><li><p>toUTCString()显示完整的 UTC 日期（格式特定于实现）。</p></li></ol><p>这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p><table><thead><tr><th align="left">方 法</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">getTime()</td><td align="left">返回日期的毫秒表示；与 valueOf()相同</td></tr><tr><td align="left">setTime(milliseconds)</td><td align="left">设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td align="left">getFullYear()</td><td align="left">返回 4 位数年（即 2019 而不是 19）</td></tr><tr><td align="left">getUTCFullYear()</td><td align="left">返回 UTC 日期的 4 位数年</td></tr><tr><td align="left">setFullYear(year)</td><td align="left">设置日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">setUTCFullYear(year)</td><td align="left">设置 UTC 日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">getMonth()</td><td align="left">返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">getUTCMonth()</td><td align="left">返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">setMonth(month)</td><td align="left">设置日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">setUTCMonth(month)</td><td align="left">设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">getDate()</td><td align="left">返回日期中的日（1~31）</td></tr><tr><td align="left">getUTCDate()</td><td align="left">返回 UTC 日期中的日（1~31）</td></tr><tr><td align="left">setDate(date)</td><td align="left">设置日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">setUTCDate(date)</td><td align="left">设置 UTC 日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">getDay()</td><td align="left">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getUTCDay()</td><td align="left">返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getHours()</td><td align="left">返回日期中的时（0~23）</td></tr><tr><td align="left">getUTCHours()</td><td align="left">返回 UTC 日期中的时（0~23）</td></tr><tr><td align="left">setHours(hours)</td><td align="left">设置日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">setUTCHours(hours)</td><td align="left">设置 UTC 日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回日期中的分（0~59）</td></tr><tr><td align="left">getUTCMinutes()</td><td align="left">返回 UTC 日期中的分（0~59）</td></tr><tr><td align="left">setMinutes(minutes)</td><td align="left">设置日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">setUTCMinutes(minutes)</td><td align="left">设置 UTC 日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回日期中的秒（0~59）</td></tr><tr><td align="left">getUTCSeconds()</td><td align="left">返回 UTC 日期中的秒（0~59）</td></tr><tr><td align="left">setSeconds(seconds)</td><td align="left">设置日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">setUTCSeconds(seconds)</td><td align="left">设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回日期中的毫秒</td></tr><tr><td align="left">getUTCMilliseconds()</td><td align="left">返回 UTC 日期中的毫秒</td></tr><tr><td align="left">setMilliseconds(milliseconds)</td><td align="left">设置日期中的毫秒</td></tr><tr><td align="left">setUTCMilliseconds(milliseconds)</td><td align="left">设置 UTC 日期中的毫秒</td></tr><tr><td align="left">getTimezoneOffset()</td><td align="left">返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/c803.html"/>
      <url>posts/c803.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong><br>本篇: <strong>变量、作用域与内存(三) 垃圾回收</strong><br>下篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>挖坑了~  QAQ<br>此坑挖于: 2020/11/20<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/85b1.html"/>
      <url>posts/85b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong><br>本篇: <strong>变量、作用域与内存(二) 执行上下文与作用域</strong><br>下篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variableobject），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象。</p><p>因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和const 的顶级声明不会定义在全局上下文中但在作用域链解析上效果是一样的。</p><p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）</p><p>看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    if (color === "blue") {        color = "red";    } else {        color = "blue";    }}changeColor();</code></pre><p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    let anotherColor = "red";    function swapColors() {        let tempColor = anotherColor;        anotherColor = color;        color = tempColor;        // 这里可以访问 color、anotherColor 和 tempColor    }    // 这里可以访问 color 和 anotherColor，但访问不到 tempColor    swapColors();}// 这里只能访问 colorchangeColor(); </code></pre><hr><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这现象，即代码执行到下面任意一种情况时：</p><ol><li><p>try/catch 语句的 catch 块</p></li><li><p>with 语句</p></li></ol><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p><pre><code>function buildUrl() {    let qs = "?debug=true";    with(location){        let url = href + qs;    }    return url;}</code></pre><p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块作用域（稍后介绍），所以在 with 块之外没有定义。</p><hr><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="使用-var-的函数作用域声明"><a href="#使用-var-的函数作用域声明" class="headerlink" title="使用 var 的函数作用域声明"></a>使用 var 的函数作用域声明</h4><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p><pre><code>function add(num1, num2) {    var sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 报错：sum 在这里不是有效变量</code></pre><p>这里，函数 add()定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回，但变量 sum 在函数外部是访问不到的。如果省略上面例子中的关键字 var，那么 sum 在 add()被调用之后就变成可以访问的了，如下所示：</p><pre><code>function add(num1, num2) {    sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 30 </code></pre><p><strong>注意</strong> 未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p><p>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。下面的例子展示了在全局作用域中两等价的代码：</p><pre><code>var name = "Jake";// 等价于：name = 'Jake';var name;下面是两个等价的函数：function fn1() {    var name = 'Jake';}// 等价于：function fn2() {    var name;    name = 'Jake';} </code></pre><p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是<br>Reference Error：</p><pre><code>console.log(name); // undefinedvar name = 'Jake';function() {    console.log(name); // undefined    var name = 'Jake';} </code></pre><h4 id="使用-let-的块级作用域声明"><a href="#使用-let-的块级作用域声明" class="headerlink" title="使用 let 的块级作用域声明"></a>使用 let 的块级作用域声明</h4><p>ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域。</p><p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p><pre><code>var a;var a;// 不会报错{    let b;    let b;}// SyntaxError: 标识符 b 已经声明过了</code></pre><p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</p><pre><code>for (var i = 0; i &lt; 10; ++i) {}console.log(i); // 10for (let j = 0; j &lt; 10; ++j) {}console.log(j); // ReferenceError: j 没有定义</code></pre><p>严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal deadzone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提跟 var是不一样的。</p><h4 id="使用-const-的常量声明"><a href="#使用-const-的常量声明" class="headerlink" title="使用 const 的常量声明"></a>使用 const 的常量声明</h4><p>除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><pre><code>const a; // SyntaxError: 常量声明时没有初始化const b = 3;console.log(b); // 3b = 4; // TypeError: 给常量赋值</code></pre><p>const 除了要遵循以上规则，其他方面与 let 声明是一样的</p><p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><pre><code>const o1 = {};o1 = {}; // TypeError: 给常量赋值const o2 = {};o2.name = 'Jake';console.log(o2.name); // 'Jake'</code></pre><p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：</p><pre><code>const o3 = Object.freeze({});o3.name = 'Jake';console.log(o3.name); // undefined </code></pre><p><strong>注意</strong> 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用<br>const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现<br>重新赋值导致的 bug。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/44e8.html"/>
      <url>posts/44e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong><br>本篇: <strong>变量、作用域与内存(一)原始值与引用值</strong><br>下篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。</p><hr><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：</p><pre><code>let person = new Object();person.name = "Nicholas";console.log(person.name); // "Nicholas" </code></pre><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：</p><pre><code>let name = "Nicholas";name.age = 27;console.log(name.age); // undefined </code></pre><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><pre><code>let name1 = "Nicholas";let name2 = new String("Matt");name1.age = 27;name2.age = 26;console.log(name1.age); // undefinedconsole.log(name2.age); // 26console.log(typeof name1); // stringconsole.log(typeof name2); // object </code></pre><hr><h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p><pre><code>let num1 = 5;let num2 = num1;</code></pre><p>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p><pre><code>let obj1 = new Object();let obj2 = obj1;obj1.name = "Nicholas";console.log(obj2.name); // "Nicholas" </code></pre><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><p>在按值传递参数时，值会被复制到一个局部变量在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部</p><pre><code>function addTen(num) {    num += 10;    return num;}let count = 20; let result = addTen(count);console.log(count); // 20，没有变化console.log(result); // 30 function setName(obj) {    obj.name = "Nicholas";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><pre><code>function setName(obj) {    obj.name = "Nicholas";    obj = new Object();    obj.name = "Greg";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><p><strong>注意</strong> ECMAScript 中函数的参数就是局部变量</p><hr><h3 id="确定类型-instanceof"><a href="#确定类型-instanceof" class="headerlink" title="确定类型 instanceof"></a>确定类型 instanceof</h3><p>前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返”object”，如下面的例子所示：</p><pre><code>let s = "Nicholas";let b = true;let i = 22;let u;let n = null;let o = new Object();console.log(typeof s); // stringconsole.log(typeof i); // numberconsole.log(typeof b); // booleanconsole.log(typeof u); // undefinedconsole.log(typeof n); // objectconsole.log(typeof o); // object </code></pre><p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型的实例，则 instanceof 操作符返回 true。来看下面的例子：</p><pre><code>console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><p>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。</p><p><strong>注意</strong></p><p>typeof 操作符在用于检测函数时也会返回”function”</p><p>typeof 对正则表达式也返回”function”，在 IE 和 Firefox 中，typeof 对正则表达式返回”object”</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a1.html"/>
      <url>posts/8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="873e">语言基础(四)操作符</a></strong><br>本篇: <strong>[语言基础(五)语句&amp;&amp;函数]</strong><br>下篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环：</p><pre><code>for (;;) { // 无穷循环doSomething();} </code></pre><hr><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h3><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><pre><code>for (property in expression) statement</code></pre><p>下面是一个例子：</p><pre><code>for (const propName in window) {document.write(propName);} </code></pre><p>这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量propName 赋予一个 window 对象的属性作为值，直到 window 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。</p><p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</p><hr><h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h3><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><pre><code>for (property of expression) statement</code></pre><p>下面是示例：</p><pre><code>for (const el of [2,4,6,8]) {document.write(el);} </code></pre><p>在这个例子中，我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误</p><hr><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p><pre><code>label: statement</code></pre><p>下面是一个例子：</p><pre><code>start: for (let i = 0; i &lt; count; i++) {console.log(i);}</code></pre><p>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</p><hr><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        if (i == 5 &amp;&amp; j == 5) {            break outermost;        }    num++;    }}console.log(num); // 55</code></pre><p>在这个例子中，outermost 标签标识的是第一个 for 语句。正常情况下，每个循环执行 10 次，意味着 num++语句会执行 100 次，而循环结束时 console.log 的结果应该是 100。但是，break 语带来了一个变数，即要退出到的标签。添加标签不仅让 break 退出（使用变量 j 的）内部循环，也会退出（使用变量 i 的）外部循环。当执行到 i 和 j 都等于 5 时，循环停止执行，此时 num 的值是55。</p><p>continue语句也可以使用标签，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {     if (i == 5 &amp;&amp; j == 5) {       continue outermost;    }    num++;    }}console.log(num); // 95 </code></pre><p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次结果 num 等于 95。</p><p>组合使用标签语句和 break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><hr><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>with 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><pre><code>with (expression) statement;</code></pre><p>使用 with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：</p><pre><code>let qs = location.search.substring(1);let hostName = location.hostname;let url = location.href;</code></pre><p>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</p><pre><code>with(location) {let qs = search.substring(1);let hostName = hostname;let url = href;} </code></pre><p>这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 location 对象的属性。</p><p>严格模式不允许使用 with 语句，否则会抛出错误。</p><p><strong>警告</strong> 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p><hr><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>虽然 switch 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：</p><pre><code>switch ("hello world") {    case "hello" + " world":        console.log("Greeting was found.");        break;    case "goodbye":        console.log("Closing was found.");        break;    default:        console.log("Unexpected message was found.");} </code></pre><p>注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值。比如：</p><pre><code>function sum(num1, num2) {return num1 + num2;}</code></pre><p>要注意的是，只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。 </p><p>严格模式对函数也有一些限制：</p><ol><li><p>函数不能以 eval 或 arguments 作为名称；</p></li><li><p>函数的参数不能叫 eval 或 arguments；</p></li><li><p>两个命名参数不能拥有同一个名称。</p></li></ol><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/873e.html"/>
      <url>posts/873e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong><br>本篇: <strong>[语言基础(四)操作符]</strong><br>下篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。</p><hr><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作符叫一元操作符。</p><h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="headerlink" title="递增/递减操作符"></a>递增/递减操作符</h4><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p><p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p><ol><li><p>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</p></li><li><p>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</p></li><li><p>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于浮点值，加 1 或减 1。</p></li><li><p>如果是对象，则调用其（第 3 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。</p></li></ol><p>下面的例子演示了这些规则：</p><pre><code>let s1 = "2";let s2 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1++; // 值变成数值 3s2++; // 值变成 NaNb++; // 值变成数值 1f--; // 值变成 0.10000000000000009（因为浮点数不精确）o--; // 值变成-2 </code></pre><hr><h4 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h4><p>如果将一元加应用到非数值,则会执行与使用Number()转型函数一样的类型转换：布尔值false和true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toStrin()方法以得到可以转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><pre><code>let s1 = "01";let s2 = "1.1"; let s3 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1 = +s1; // 值变成数值 1s2 = +s2; // 值变成数值 1.1s3 = +s3; // 值变成 NaNb = +b; // 值变成数值 0f = +f; // 不变，还是 1.1o = +o; // 值变成数值-1 </code></pre><p>一元减由一个减号（-）表示同上</p><hr><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>挖坑了~<br>此坑挖于:2020/11/20<br>此坑填于:~</p><hr><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h4><p>逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。<br>逻辑非操作符会遵循如下规则：</p><ol><li><p>如果操作数是对象，则返回 false。</p></li><li><p>如果操作数是空字符串，则返回 true。</p></li><li><p>如果操作数是非空字符串，则返回 false。</p></li><li><p>如果操作数是数值 0，则返回 true。</p></li><li><p>如果操作数是非 0 数值（包括 Infinity），则返回 false。</p></li><li><p>如果操作数是 null，则返回 true。</p></li><li><p>如果操作数是 NaN，则返回 true。</p></li><li><p>如果操作数是 undefined，则返回 true。</p></li></ol><p>以下示例验证了上述行为：</p><pre><code>console.log(!false); // trueconsole.log(!"blue"); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!""); // trueconsole.log(!12345); // false </code></pre><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p><pre><code>console.log(!!"blue"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!12345); // true </code></pre><hr><h4 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h4><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p><p>同真为真，其余全是假</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则:</p><ol><li><p>如果第一个操作数是对象，则返回第二个操作数。</p></li><li><p>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</p></li><li><p>如果两个操作数都是对象，则返回第二个操作数。</p></li><li><p>如果有一个操作数是 null，则返回 null。</p></li><li><p>如果有一个操作数是 NaN，则返回 NaN。</p></li><li><p>如果有一个操作数是 undefined，则返回 undefined</p></li></ol><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</p><hr><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h4><p>逻辑或操作符由两个管道符（||）表示</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：</p><ol><li><p>如果第一个操作数是对象，则返回第一个操作数。</p></li><li><p>如果第一个操作数求值为 false，则返回第二个操作数。</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数。</p></li><li><p>如果两个操作数都是 null，则返回 null。</p></li><li><p>如果两个操作数都是 NaN，则返回 NaN。</p></li><li><p>如果两个操作数都是 undefined，则返回 undefined。</p></li></ol><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。</p><hr><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h4 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h4><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。</p><p>乘法操作符在处理特殊值时也有一些特殊的行为。</p><ol><li><p>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以 0，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity -Infinity。</p></li><li><p>如果是 Infinity 乘以 Infinity，则返回 Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</p></li></ol><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p><p>跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ol><li><p>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果是 0 除以 0，则返回 NaN。</p></li><li><p>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><hr><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><p>取模（余数）操作符由一个百分比符号（%）表示</p><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为:</p><ol><li><p>如果操作数是数值，则执行常规除法运算，返回余数。</p></li><li><p>如果被除数是无限值，除数是有限值，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是 0，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是无限值，则返回被除数。</p></li><li><p>如果被除数是 0，除数不是 0，则返回 0。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h4 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>如果有一个操作数是字符串，则要应用如下规则：</p><ol><li><p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</p></li><li><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。</p></li></ol><p>看下面的例子：</p><pre><code>let result1 = 5 + 5; // 两个数值console.log(result1); // 10let result2 = 5 + "5"; // 一个数值和一个字符串console.log(result2); // "55" </code></pre><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + num1 + num2;console.log(message); // "The sum of 5 and 10 is 510" </code></pre><p>如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + (num1 + num2);console.log(message); // "The sum of 5 and 10 is 15" </code></pre><hr><h4 id="加法操作符-1"><a href="#加法操作符-1" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ol><li><p> 如果两个操作数都是数值，则执行数学减法运算并返回结果。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 减 Infinity，则返回 NaN。</p></li><li><p>如果是-Infinity 减-Infinity，则返回 NaN。</p></li><li><p>如果是 Infinity 减-Infinity，则返回 Infinity。</p></li><li><p>如果是-Infinity 减 Infinity，则返回-Infinity。</p></li><li><p>如果是+0 减+0，则返回+0。</p></li><li><p>如果是+0 减-0，则返回-0。</p></li><li><p>如果是-0 减-0，则返回+0。</p></li><li><p>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</p></li></ol><p>以下示例演示了上面的规则：</p><pre><code>let result1 = 5 - true; // true 被转换为 1，所以结果是 4let result2 = NaN - 1; // NaNlet result3 = 5 - 3; // 2let result4 = 5 - ""; // ""被转换为 0，所以结果是 5let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3let result6 = 5 - null; // null 被转换为 0，所以结果是 5 </code></pre><hr><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ol><li><p>如果操作数都是数值，则执行数值比较。</p></li><li><p>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</p></li><li><p>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p><p> let result = “23” &lt; “3”; // true</p></li></ol><p>这里在比较字符串”23”和”3”时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p><pre><code>let result = "23" &lt; 3; // false</code></pre><p>因为这次会将字符串”23”转换为数值 23，然后再跟 3 比较。但如果字符串不能转换成数值呢？比如下面这个例子：</p><pre><code>let result = "a" &lt; 3; // 因为"a"会转换为 NaN，所以结果是 false</code></pre><p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。</p><hr><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ol><li><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</p></li><li><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</p></li><li><p>如果一个操作数是对象，另，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</p></li></ol><p>在进行比较时，这两个操作符会遵循如下规则:</p><ol><li><p>null 和 undefined 相等。</p></li><li><p>null 和 undefined 不能转换为其他类型的值再进行比较。</p></li><li><p>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</p></li><li><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</p></li></ol><p>下表总结了一些特殊情况及比较的结果</p><table><thead><tr><th align="left">表 达 式</th><th align="left">结 果</th></tr></thead><tbody><tr><td align="left">null == undefined</td><td align="left">true</td></tr><tr><td align="left">“NaN” == NaN</td><td align="left">false</td></tr><tr><td align="left">5 == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN != NaN</td><td align="left">true</td></tr><tr><td align="left">false == 0</td><td align="left">true</td></tr><tr><td align="left">true == 1</td><td align="left">true</td></tr><tr><td align="left">true == 2</td><td align="left">false</td></tr><tr><td align="left">undefined == 0</td><td align="left">false</td></tr><tr><td align="left">null == 0</td><td align="left">false</td></tr><tr><td align="left">“5” == 5</td><td align="left">true</td></tr></tbody></table><h4 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</p><pre><code>let result1 = ("55" == 55); // true，转换后相等let result2 = ("55" === 55); // false，不相等，因为数据类型不同</code></pre><p>不全等操作符用一个叹号和两个等于号（!==）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：</p><pre><code>let result1 = ("55" != 55); // false，转换后相等let result2 = ("55" !== 55); // true，不相等，因为数据类型不同</code></pre><p>另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。</p><p>注意 由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</p><pre><code>variable = boolean_expression ? true_value : false_value;</code></pre><p>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果boolean_expression 是 false，则赋值 false_value。</p><hr><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><pre><code>let num1 = 1, num2 = 2, num3 = 3;</code></pre><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><pre><code>let num = (5, 1, 4, 8, 0); // num 的值为 0 </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a7.html"/>
      <url>posts/8a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="85be">语言基础(二)变量</a></strong><br>本篇: <strong>[语言基础(三)数据类型]</strong><br>下篇: <strong><a href="873e">语言基础(四)操作符</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。</p><hr><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p><p> “undefined”表示值未定义；<br> “boolean”表示值为布尔值；<br> “string”表示值为字符串；<br> “number”表示值为数值；<br> “object”表示值为对象（而不是函数）或 null；<br> “function”表示值为函数；<br> “symbol”表示值为符号。</p><p>下面是使用 typeof 操作符的例子：</p><pre><code>let message = "some string";console.log(typeof message); // "string"console.log(typeof(message)); // "string"console.log(typeof 95); // "number"</code></pre><p>在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><p>注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull 返回的是”object”。这是因为特殊值 null 被认为是一个对空对象的引用。</p><hr><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：</p><pre><code>let message;console.log(message == undefined); // true </code></pre><p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined // let age 确保没有声明过这个变量console.log(message); // "undefined"console.log(age); // 报错</code></pre><p>在上面的例子中，第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。</p><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// let age  确保没有声明过这个变量console.log(typeof message); // "undefined"console.log(typeof age); // "undefined"</code></pre><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// age 没有声明if (message) {// 这个块不会执行}if (!message) {// 这个块会执行}if (age) {// 这里会报错} </code></pre><hr><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：</p><pre><code>let car = null;console.log(typeof car); // "object" </code></pre><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后被重新赋予了一个对象的引用，比如：</p><pre><code>if (car != null) {// car 是一个对象的引用} </code></pre><p>undefined 值是由 null 值派生而来的<br>    console.log(null == undefined); // true </p><p>永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><pre><code>    let message = null;    let age;    if (message) {    // 这个块不会执行    }    if (!message) {    // 这个块会执行    }     if (age) {    // 这个块不会执行    }    if (!age) {    // 这个块会执行    } </code></pre><hr><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0</p><table><thead><tr><th align="left">数据类型</th><th align="left">转换为 true 的值</th><th align="left">转换为 false 的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">true</td><td align="left">false</td></tr><tr><td align="left">String</td><td align="left">非空字符串</td><td align="left">“”（空字符串）</td></tr><tr><td align="left">Number</td><td align="left">非零数值（包括无穷值）</td><td align="left">0、NaN（参见后面的相关内容）</td></tr><tr><td align="left">Object</td><td align="left">任意对象</td><td align="left">null</td></tr><tr><td align="left">Undefined</td><td align="left">N/A（不存在）</td><td align="left">undefined</td></tr></tbody></table><p>理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p><pre><code>let message = "Hello world!";if (message) {console.log("Value is true");}</code></pre><p>在这个例子中，console.log 会输出字符串”Value is true”，因为字符串 message 会被自动转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><hr><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><pre><code>let intNum = 55; // 整数</code></pre><p>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><pre><code>let octalNum1 = 070; // 八进制的 56let octalNum2 = 079; // 无效的八进制值，当成 79 处理let octalNum3 = 08; // 无效的八进制值，当成 8 处理</code></pre><p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p><p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0<del>9 以及 A</del>F）。十六进制数字中的字母大小写均可。下面是几个例子：</p><pre><code>let hexNum1 = 0xA; // 十六进制 10let hexNum2 = 0x1f; // 十六进制 31</code></pre><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><pre><code>let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐</code></pre><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：</p><pre><code>let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</code></pre><hr><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN：</p><pre><code>console.log(0/0); // NaNconsole.log(-0/+0); // NaN</code></pre><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：</p><pre><code>console.log(5/0); // Infinityconsole.log(5/-0); // -Infinity </code></pre><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><pre><code>console.log(NaN == NaN); // false </code></pre><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回<br>true。举例如下：</p><pre><code>console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false，10 是数值console.log(isNaN("10")); // false，可以转换为数值 10console.log(isNaN("blue")); // true，不可以转换为数值console.log(isNaN(true)); // false，可以转换为数值 1</code></pre><hr><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p><p>Number()函数基于如下规则执行转换。</p><p> 布尔值，true 转换为 1，false 转换为 0。<br> 数值，直接返回。<br> null，返回 0。<br> undefined，返回 NaN。<br> 字符串，应用以下规则。</p><ol><li><p>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面的零）。</p></li><li><p> 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p></li><li><p>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p></li><li><p>如果是空字符串（不包含字符），则返回 0。</p></li><li><p>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</p></li></ol><p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用<br>toString()方法，再按照转换字符串的规则转换。</p><pre><code>let num1 = Number("Hello world!"); // NaNlet num2 = Number(""); // 0let num3 = Number("000011"); // 11let num4 = Number(true); // 1</code></pre><p>可以看到，字符串”Hello world”转换之后是 NaN，因为它找不到对应的数值。</p><p>考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。下面几个转换示例有助于理解上述规则：</p><pre><code>let num1 = parseInt("1234blue"); // 1234let num2 = parseInt(""); // NaNlet num3 = parseInt("0xA"); // 10，解释为十六进制整数let num4 = parseInt(22.5); // 22let num5 = parseInt("70"); // 70，解释为十进制值let num6 = parseInt("0xf"); // 15，解释为十六进制整数</code></pre><p>通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p><pre><code>let num1 = parseInt("10", 2); // 2，按二进制解析let num2 = parseInt("10", 8); // 8，按八进制解析let num3 = parseInt("10", 10); // 10，按十进制解析let num4 = parseInt("10", 16); // 16，按十六进制解析</code></pre><p>parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p>parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。下面是几个示例：</p><pre><code>let num1 = parseFloat("1234blue"); // 1234，按整数解析let num2 = parseFloat("0xA"); // 0let num3 = parseFloat("22.5"); // 22.5let num4 = parseFloat("22.34.5"); // 22.34let num5 = parseFloat("0908.5"); // 908.5let num6 = parseFloat("3.125e7"); // 31250000</code></pre><hr><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的：</p><pre><code>    let firstName = "John";    let lastName = 'Jacob';    let lastName = `Jingleheimerschmidt`; </code></pre><h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="left">字 面 量</th><th align="left">含 义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\t</td><td align="left">制表</td></tr><tr><td align="left">\b</td><td align="left">退格</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\f</td><td align="left">换页</td></tr><tr><td align="left">\\</td><td align="left">反斜杠（\）</td></tr><tr><td align="left">\‘</td><td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, 'hey.'‘</td></tr><tr><td align="left">\“</td><td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, "hey."“</td></tr><tr><td align="left">\ `</td><td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td></tr><tr><td align="left">\xnn</td><td align="left">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td align="left">\unnnn</td><td align="left">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符”Σ”</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><pre><code>let text = "This is the letter sigma: \u03a3.";</code></pre><p>在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。</p><p>字符串的长度可以通过其 length 属性获取：</p><pre><code>console.log(text.length); // 28 </code></pre><h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><pre><code>let lang = "Java";lang = lang + "Script"; </code></pre><p>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”</p><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><pre><code>let age = 11;let ageAsString = age.toString(); // 字符串"11"let found = true;let foundAsString = found.toString(); // 字符串"true"</code></pre><p>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。</p><p>默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>String()函数遵循如下规则:</p><p> 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。<br> 如果值是 null，返回”null”。<br> 如果值是 undefined，返回”undefined”。</p><p>下面看几个例子：</p><pre><code>let value1 = 10;let value2 = true;let value3 = null;let value4;console.log(String(value1)); // "10"console.log(String(value2)); // "true"console.log(String(value3)); // "null"console.log(String(value4)); // "undefined" </code></pre><hr><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><pre><code>let myMultiLineString = 'first line\nsecond line';let myMultiLineTemplateLiteral = `first linesecond line`;console.log(myMultiLineString);// first line// second lineconsole.log(myMultiLineTemplateLiteral);// first line // second lineconsole.log(myMultiLineString === myMultiLinetemplateLiteral); // true </code></pre><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><pre><code>        let pageHTML = `        &lt;div&gt;        &lt;a href="#"&gt;        &lt;span&gt;Jake&lt;/span&gt;        &lt;/a&gt;        &lt;/div&gt;`;</code></pre><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><pre><code>// 这个模板字面量在换行符之后有 25 个空格符let myTemplateLiteral = `first line                        second line`;console.log(myTemplateLiteral.length); // 47// 这个模板字面量以一个换行符开头let secondTemplateLiteral = `first linesecond line`;console.log(secondTemplateLiteral[0] === '\n'); // true// 这个模板字面量没有意料之外的字符let thirdTemplateLiteral = `first linesecond line`;console.log(thirdTemplateLiteral);// first line// second line </code></pre><hr><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在${}中使用一个 JavaScript 表达式实现：</p><pre><code>let value = 5;let exponent = 'second';// 以前，字符串插值是这样实现的：let interpolatedString =value + ' to the ' + exponent + ' power is ' + (value * value);// 现在，可以用模板字面量这样实现：let interpolatedTemplateLiteral =`${ value } to the ${ exponent } power is ${ value * value }`;console.log(interpolatedString); // 5 to the second power is 25console.log(interpolatedTemplateLiteral); // 5 to the second power is 25</code></pre><p>嵌套的模板字符串无须转义：</p><pre><code>console.log(`Hello, ${ `World` }!`); // Hello, World! </code></pre><p>将表达式转换为字符串时会调用 toString()：</p><pre><code>let foo = { toString: () =&gt; 'World' };console.log(`Hello, ${ foo }!`); // Hello, World! </code></pre><p>在插值表达式中可以调用函数和方法：</p><pre><code>function capitalize(word) {return `${ word[0].toUpperCase() }${ word.slice(1) }`;}console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!</code></pre><p>此外，模板也可以插入自己之前的值：</p><pre><code>let value = '';function append() {value = `${value}abc`console.log(value);}append(); // abcappend(); // abcabcappend(); // abcabcabc </code></pre><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><pre><code>let o = new Object(); </code></pre><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ol><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。</p></li><li><p>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</p></li><li><p>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 6 章将详细介绍原型。）</p></li><li><p>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</p></li></ol><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。</p><hr><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>挖个坑~QvQ<br>此坑挖于: 2020/11/19<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/85be.html"/>
      <url>posts/85be.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="14a5">语言基础(一)语法</a></strong><br>本篇: <strong>语言基础(二)变量</strong><br>下篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript变量是松散类型的，意思是可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有三个关键字可以声明变量：var、const、let。其中，var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更高版本中使用。</p><hr><h4 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h4><p>要定义变量可以用操作符var，后跟变量名。<br>var message;</p><p>变量可以保存任何类型的值。不初始会保存一个特殊值undefined。</p><hr><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用var操作符定义的变量会成为包含它的函数的局部变量。比如使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过，在函数内部定义变量时省略var操作符，可以创建一个全局变量，只要调用一次函数，可以在函数外部引用: (不推荐这么做:省略var)</p><pre><code>            function test(){                message="hi";   //全局变量            }            test();            console.log(message); </code></pre><hr><h4 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h4><p>let跟var的作用差不多，但有个明显区别，var声明的范围是函数作用域，而let声明的范围是块作用域</p><pre><code>    if(true){        var name = 'M';        console.log(name); // M    }    console.log(name); // M    if(true){        let age = 'A';        console.log(age); // A    }    console.log(age); // 未定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也试用let</p><p>let也不允许同一个块作用域中出现重复声明</p><pre><code>    var name;    var name;    let age;    let age; //标识符age已经声明过了</code></pre><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><pre><code>    var name;    let name; // 错误    let age;    var age; // 错误 </code></pre><hr><h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><pre><code>    var name="M";    console.log(name); // M    console.log(name02); //undefined    var name02="M";     console.log(name02); //报错    let name02="M"; </code></pre><hr><h5 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h5><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><pre><code>    var name = 'Matt';    console.log(window.name); // 'Matt'    let age = 26;    console.log(window.age); // undefined </code></pre><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><hr><h5 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h5><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {    // 循环逻辑    }    console.log(i); // 5</code></pre><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    // 循环逻辑    }     console.log(i); // ReferenceError: i 没有定义</code></pre><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {        setTimeout(() =&gt; console.log(i), 0)    }</code></pre><p>// 你可能以为会输出 0、1、2、3、4<br>// 实际上会输出 5、5、5、5、5 </p><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)    }    // 会输出 0、1、2、3、4 </code></pre><hr><h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 36; // TypeError: 给常量赋值// const 也不允许重复声明const name = 'Matt';const name = 'Nicholas'; // SyntaxError// const 声明的作用域也是块const name = 'Matt';if (true) {const name = 'Nicholas';}console.log(name); // Matt </code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = {};person.name = 'Matt'; // ok </code></pre><p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p><pre><code>for (const i = 0; i &lt; 10; ++i) {} // TypeError：给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p><pre><code>let i = 0;for (const j = 7; i &lt; 5; ++i) {console.log(j);}// 7, 7, 7, 7, 7for (const key in {a: 1, b: 2}) {console.log(key);}// a, bfor (const value of [1,2,3,4,5]) {console.log(value);}// 1, 2, 3, 4, 5 </code></pre><hr><h4 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h4><ol><li><p>不使用var，限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置以及不变的值。</p></li><li><p>const优先，let次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/14a5.html"/>
      <url>posts/14a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h5 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h5><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>本篇:<strong>语言基础(一)语法</strong><br>下篇:<strong><a href="85be">语言基础(二)变量</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h4><p>首先要知道,<strong>ECMAScript</strong>中一切都区分大小写。无论是<strong>变量</strong>、<strong>函数名</strong>还是<strong>操作符</strong>。换句话说<strong>变量test</strong>和<strong>变量Test</strong>是俩个不同的变量。类似的，<strong>typeof</strong>不能作为函数名，因为它是一个<strong>关键字</strong>。但是<strong>Typeof</strong>是一个完全有效的函数名。</p><hr><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>所谓<strong>标识符</strong>，就是<strong>变量</strong>、<strong>函数</strong>、<strong>属性</strong>或<strong>函数参数</strong>的名称。标识符可以由一或多个下列字符组成：</p><ol><li><p>第一个字符必须是一个<strong>字母</strong>、<strong>下划线</strong>(_)或<strong>美元符号</strong>($);</p></li><li><p>剩下的其他字符可以是<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>或<strong>数字</strong>。</p></li></ol><p>按照惯例，标识符使用<strong>驼峰大小写</strong>形式，即第一个单词首字母小写，后面每个单词的首字母大写。</p><p><strong>注意</strong> 关键字、保留字、true、false和null不能作为标识符。</p><hr><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>ECMAScript采用C语言风格的注释，包括单行注释和块注释。</p><p>单行注释以俩个斜杠字符开头， // 单行注释</p><p>块注释以一个斜杠和一个星号开头，以它们的反向组合结尾， /* 块注释 */</p><hr><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ECMAScript5增加了严格模式的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><p><code>"use strict"</code></p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p><pre><code>        function doSomething(){            "use strict";            //函数体        }</code></pre><p>所有现代浏览器都支持严格模式</p><hr><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>ECMASCript中语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><pre><code>        let sum = a + b   //没有分号也有效，但不推荐        let diff = a - b; //加分号有效，推荐</code></pre><p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号({)开始，右花括号(})结束。</p><p>if之类的控制语句只在执行多条语句要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即便只有一条语句。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="posts/h0001.html"/>
      <url>posts/h0001.html</url>
      
        <content type="html"><![CDATA[<p>网址在这里:</p><p>版本0.5:<br><a href="https://yanyanzio.top/Project/One/YYZMusic">https://yanyanzio.top/Project/One/YYZMusic</a></p><p>要源码可以联系我,有QQ</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水涨船高技术栈</title>
      <link href="posts/f0001.html"/>
      <url>posts/f0001.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS溢出属性-overflow"><a href="#CSS溢出属性-overflow" class="headerlink" title="CSS溢出属性 overflow"></a>CSS溢出属性 overflow</h3><p>该overflow属性指定如果内容溢出元素框会发生什么情况。</p><p>此属性指定在元素的内容太大而无法放入指定区域时是剪辑内容还是添加滚动条。</p><p>/* 默认值。内容不会被修剪，会呈现在元素框之外 */<br>overflow: visible;</p><p>/* 内容会被修剪，并且其余内容不可见 */<br>overflow: hidden;</p><p>/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */<br>overflow: scroll;</p><p>/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */<br>overflow: auto;</p><p>/* 规定从父元素继承overflow属性的值 */<br>overflow: inherit;</p><hr><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。 </p><p>border 和 outline<br>border 和 outline 很类似，但有如下区别：</p><p>outline不占据空间，绘制于元素内容周围。<br>根据规范，outline通常是矩形，但也可以是非矩形的。</p><p>&lt;’outline-color’&gt;<br>设置轮廓的颜色。没有设置时默认值为 currentcolor。<br>&lt;’outline-style’&gt;<br>设置轮廓的样式。没有设置时默认值为 none。<br>&lt;’outline-width’&gt;<br>设置轮廓的宽度。没有设置时默认值为 medium</p><p>outline:none; 取消选中边框</p><hr><h3 id="选择器-交集选择器"><a href="#选择器-交集选择器" class="headerlink" title="选择器: 交集选择器"></a>选择器: 交集选择器</h3><p>我主要用在绑定一个标签, 如: .Old.Xin  有一个源 <code>&lt;div class="Old"&gt;&lt;/div&gt;</code></p><p>想要在这个<strong>div</strong>中添加一个新的类,即<code>&lt;div class="Old Xin"&gt;&lt;/div&gt;</code></p><p>就用 <strong>.Old.Xin</strong> 交集选择器</p><hr><h3 id="webkit-scrollbar-滚轮样式"><a href="#webkit-scrollbar-滚轮样式" class="headerlink" title="::-webkit-scrollbar 滚轮样式"></a>::-webkit-scrollbar 滚轮样式</h3><p>::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样</p><p>::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分</p><hr><h3 id="img的边框"><a href="#img的边框" class="headerlink" title="img的边框"></a>img的边框</h3><ol><li><code>&lt;img&gt;</code> 标签的 border 属性规定图像周围的边框的宽度</li></ol><p><code>border: none;</code> // css属性</p><ol start="2"><li><p>当img没有接收到src属性的时候会自动出现边框，border:0/none都不管用的情况下，解决方法：</p><pre><code> img[src=""],img:not([src]){     opacity:0; }</code></pre></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 水涨船高技术集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="posts/e0001.html"/>
      <url>posts/e0001.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js是一套构建用户界面的渐进式框架</p><p>Vue.js 只关注视图层， 设计时采用自底向上渐进式开发的构架，核心部件只关注用户界面的构建</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p><p><strong>注意</strong>： Vue.js 不支持 IE8 及其以下 IE 版本</p><h3 id="为什么要使用Vue"><a href="#为什么要使用Vue" class="headerlink" title="为什么要使用Vue"></a>为什么要使用Vue</h3><p>1.轻量级,体积小是一个重要指标,Vue.Js压缩后只有20多KB<br>2.移动优先,更适合移动端,比如移动端的Touch事件<br>3.易上手,学习曲线平稳,文档齐全<br>4.吸收了Angular(模块化)和React(虚拟DOM的长处),并拥有自己独特的功能<br>5.开源,社区活跃度高<br>…</p><h3 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h3><p>在我们继续学习 Vue.js 2 之前，希望对以下知识有一定的了解<br><strong>HTML</strong><br><strong>CSS</strong><br><strong>JavaScript</strong></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><strong>Vue.js</strong> 是一个 <strong>JavaScript</strong> 脚本库，所以安装起来非常简单，只要引用 <strong>vue.min.js</strong> 脚本就可以了</p><p>可以在 Vue.js 的官网上直接下载 vue.min.js 然后使用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li><p><strong>安装 cnpm</strong><br><code>npm install --global cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p><strong>全局安装 vue-cli</strong><br><code>$ cnpm install --global vue-cli</code></p></li><li><p><strong>创建一个基于 webpack 模板的新项目</strong><br><code>$ vue init webpack yyzvue</code></p></li><li><p>这里需要你进行一些配置，如果不想更改，可以直接回车</p></li></ol><p><code>$ vue init webpack yyzvue</code>  </p><p><code>? Project name yyzvue</code><br><code>? Project description A Vue.js project</code><br><code>? Author sense &lt;yu.fei@gmail.com&gt;</code><br><code>? Vue build standalone</code><br><code>? Install vue-router? Yes</code><br><code>? Use ESLint to lint your code? Yes</code><br><code>? Pick an ESLint preset Standard</code><br><code>? Set up unit tests Yes</code><br><code>? Pick a test runner jest</code><br><code>? Setup e2e tests with Nightwatch? Yes</code></p><p>   <code>vue-cli · Generated "webapp".</code></p><p>   <code>To get started:</code><br>     <code>cd webapp</code><br>     <code>npm install</code><br>     <code>npm run dev</code><br>   <code>Documentation can be found at https://vuejs-templates.github.io/webpack</code></p><ol start="3"><li>安装依赖并运行<br>配置配置完成后，可以进入项目，然后执行以下命令</li></ol><p><code>$ cd webapp</code><br><code>$ cnpm install</code><br>先去喝杯茶，然后调戏小孩，再回来看看是否安装好了…</p><p><code>$ npm run dev</code></p><p> <code>DONE  Compiled successfully in </code></p><p> <code>I  Your application is running here: http://localhost:8080</code></p><p> 成功执行以上命令后访问 <a href="http://localhost:8080/%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">http://localhost:8080/，输出结果如下所示</a></p><p> <img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_1.png"></p><hr><h2 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h2><p>上一章节中，我们使用 vue-cli 工具创建了一个 webapp 的项目</p><p>如果我们使用 IDE（Eclipse、Atom）打开该目录，显示目录结构如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_2.png"></p><h3 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h3><table><thead><tr><th align="left">目录/文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">build</td><td align="left">最终发布的代码存放位置</td></tr><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的</td></tr><tr><td align="left">node_modules</td><td align="left">npm 加载的项目依赖模块</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里里面包含了几个目录及文件assets: 放置一些图片，如logo等components: 目录里面放了一个组件文件，可以不用App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录main.js: 项目的核心文件</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">.xxxx文件</td><td align="left">这些是一些配置文件，包括语法配置，git配置等</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或同统计代码啥的</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><h3 id="用vue写一个hello-word"><a href="#用vue写一个hello-word" class="headerlink" title="用vue写一个hello word"></a>用vue写一个hello word</h3><p>代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id="app"&gt;        {{message}}    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_3.png"></p><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>&lt;div id="app_01"&gt;    {{mes+'!'}}    &lt;h2 v-text="mes+'!'"&gt;iii&lt;/h2&gt;    &lt;h2&gt;hah{{mes}}iii&lt;/h2&gt;&lt;/div&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>    &lt;div id="app_01"&gt;    &lt;span v-text="mes"&gt;&lt;/span&gt;    &lt;span v-html="mes"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm= new Vue({        el: '#app_01' ,        data:{            mes: '&lt;p style="color:red;font-size:30px;"&gt;言言子&lt;/p&gt;'        }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>设置元素属性值,如: v-bind:src=”imgSrc”,v-bind:title=”arcTit”<br>其中 v-bind 可以省略</p><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-bind:title="message"&gt;HHHHH&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>当把鼠标放到<strong>HHHHH</strong>上时,鼠标下会有个标记</p><p>你看到的 <strong>v-bind</strong> 等被称为标记,指令带有前缀<strong>v-</strong>,以示他们是<strong>Vue</strong>提供的特殊特性</p><p>他们会在渲染的<strong>DOM</strong>上应用特殊的响应式行为。在这里,指令的意思为：将这个元素节点的<strong>title</strong></p><p>特性和<strong>Vue</strong>实例的<strong>message</strong>属性保持一致。</p><p>如果打开浏览器的控制台，输入<code>vue.message="哦哦哦哦哦"</code>,就会看到绑定了<strong>title</strong>特性的HTML</p><p>已经进行了更新</p><h3 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h3><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok"&gt;YES&lt;/span&gt;        &lt;span v-else&gt;NONONO&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: true            }        } );    &lt;/script&gt;&lt;/body&gt;&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok==='A'"&gt;这是A&lt;/span&gt;        &lt;span v-else-if="ok==='B'"&gt;这是B&lt;/span&gt;        &lt;span v-else&gt;啥也不是&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: 'A'            }        } );    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>&lt;div id="app"&gt;        &lt;p v-for="item in items"&gt;            {{item.message}}        &lt;/p&gt;&lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: "#app",            data: {                items: [                    {message: '言言子好可爱!'},                    {message: '言言子好萌!'}                ]            }        });    &lt;/script&gt;</code></pre><p>在控制台里，输入 vm.items.push({ message: ‘芜湖！好耶！’ })，你会发现列表最后添加了一个新项目</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><pre><code>&lt;div id="app_01"&gt;    &lt;p @click="func"&gt;{{message}}&lt;/p&gt;    &lt;input type="button" value="事件绑定-点击" v-on:click="func"&gt;    &lt;input type="button" value="事件绑定-点击" @click="func"&gt;    &lt;input type="button" value="事件绑定-" v-on:monseenter="func"&gt;    &lt;input type="button" value="事件绑定-双击" v-on:dblclick="func"&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app_01",            data: {                message: "ABC"            },            methods: {                func() {                    this.message = this.message.split('').reverse().join('');                }            }    }); &lt;/script&gt;</code></pre><p><strong>split() 方法用于把一个字符串分割成字符串数组</strong><br><strong>reverse() 方法用于颠倒数组中元素的顺序</strong><br><strong>join() 方法用于把数组中的所有元素放入一个字符串</strong></p><p>注意在 <strong>reverseMessage</strong> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><h3 id="用Vue做简单计数器"><a href="#用Vue做简单计数器" class="headerlink" title="用Vue做简单计数器"></a>用Vue做简单计数器</h3><pre><code>    &lt;div id="app"&gt;    &lt;button @click="add"&gt;+&lt;/button&gt;    &lt;span&gt;{{num}}&lt;/span&gt;    &lt;button @click="jian"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app",            data: {                num: 0            },            methods: {                add(){                    if(this.num&lt;10){                        this.num+=1;                    }else{                        alert("最大为10!");                    }                },                jian(){                    if(this.num&gt;0){                        this.num-=1;                    }else{                        alert("最小为0!");                    }                }            }    });&lt;/script&gt;</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达式的真假切换元素的显示和隐藏</p><pre><code>&lt;div id="app"&gt;    &lt;button @click="q"&gt;点击隐藏图片&lt;/button&gt;    &lt;img src="./1.jpg" v-show="isShow"&gt;    &lt;img src="./1.jpg" v-if="isShow"&gt;    &lt;img src="./1.jpg" v-show="age&gt;20"&gt;&lt;/div&gt;&lt;script&gt;    var vm =new Vue({        el: "#app",    data: {            isShow: true,            age: 18    },    methods: {            q(){                this.isShow= !this.isShow;            }    }    });&lt;/script&gt;</code></pre><p>频繁切换的元素用 <strong>v-show</strong>,反之用 <strong>v-if</strong></p><p>因为操作DOM数对性能的消耗比较大(<strong>v-if</strong>)</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue 还提供了 <strong>v-model</strong> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><pre><code>&lt;div id="app-6"&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单</p><pre><code>&lt;div class="app"&gt;    &lt;yan&gt;&lt;/yan&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个Vue组件    Vue.component('yan',{        template: '&lt;p&gt;言言子努力加油&lt;/p&gt;'    })     var vm= new Vue({         el: "#app"     }); &lt;/script&gt;</code></pre><h3 id="用Vue切换图片"><a href="#用Vue切换图片" class="headerlink" title="用Vue切换图片"></a>用Vue切换图片</h3><pre><code>&lt;div id="app"&gt;    &lt;div&gt;            &lt;img :src="img[index]" alt=""&gt;            &lt;a href="##" @click="sub" v-show="index!=0"&gt;&lt;&lt;/a&gt;            &lt;a href="##" @click="add" v-show="index&lt;img.length-1"&gt;&gt;&lt;/a&gt;        &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: '#app',        data:{                img: ['./1.jpg','./2.jpg','./3.png'],                index: 0        },        methods:{            add(){                    this.index++;            },            sub(){                    this.index--;            }        }    });&lt;/script&gt;</code></pre><h3 id="用Vue做一个记录本功能"><a href="#用Vue做一个记录本功能" class="headerlink" title="用Vue做一个记录本功能"></a>用Vue做一个记录本功能</h3><pre><code>&lt;div id="app"&gt;    &lt;header&gt;        &lt;h1&gt;记事本&lt;/h1&gt;        &lt;input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;ul&gt;            &lt;li v-for="(item,index) in arr"&gt;                &lt;div&gt;                    &lt;span&gt;{{index+1}}.&lt;/span&gt;                    &lt;label&gt;{{item}}&lt;/label&gt;                    &lt;button @click="sub(index)"&gt;&lt;/button&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;footer v-show="arr.length!=0" &gt;        &lt;span&gt;            &lt;strong  &gt;{{arr.length}}&lt;/strong&gt;        &lt;/span&gt;        &lt;button @click="clear"&gt;Clear&lt;/button&gt;    &lt;/footer&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: "#app",        data: {            arr: [                "ABC",                "QWE",                "ZXC"            ],            inputValue: ""        },        methods: {            add(){                this.arr.push(this.inputValue);            },            sub(index){                this.arr.splice(index,1);            },            clear(){                this.arr= []            }        }    });&lt;/script&gt;</code></pre><hr><h2 id="AXIOS的基本使用-实例"><a href="#AXIOS的基本使用-实例" class="headerlink" title="AXIOS的基本使用(实例)"></a>AXIOS的基本使用(实例)</h2><pre><code>&lt;input type="button"  id="get" value="get请求"&gt;&lt;input type="button" id="post" value="post请求"&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script&gt;    document.querySelector("#get").onclick= function(){        axios.get("https://autumnfish.cn/api/joke/listsadsad?num=1")        .then(function (response){            console.log(response);        },function(err){            console.log(err);        })    }    document.querySelector("#post").onclick=function(){        axios.post("https://autumnfish.cn/api/user/reg",        {username: "言言子"})        .then(function(re){            console.log(re);        },function(err){            console.log(err);        })    }&lt;/script&gt;</code></pre><h3 id="AXIOS-Vue-获取笑话"><a href="#AXIOS-Vue-获取笑话" class="headerlink" title="AXIOS+Vue:获取笑话"></a>AXIOS+Vue:获取笑话</h3><pre><code>&lt;div id="app"&gt;    &lt;input type="button" value="获取笑话" @click="getJoke"&gt;    &lt;p&gt;{{Joke}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm=new Vue({        el: "#app",        data: {            Joke: ""        },        methods: {            getJoke(){                var that= this;                axios.get("https://autumnfish.cn/api/joke")                .then(function(resq){                                            that.Joke= resq.data;                })            }        }    });&lt;/script&gt;</code></pre><h3 id="网络应用-天气查询"><a href="#网络应用-天气查询" class="headerlink" title="网络应用:天气查询"></a>网络应用:天气查询</h3><pre><code>HTML&lt;div id="app"&gt;        &lt;div&gt;            &lt;p&gt;天知道&lt;/p&gt;            &lt;div&gt;                &lt;input type="text" placeholder="请输入查询天气"                 @keyup.enter="searchTQ" v-model="city"&gt;                &lt;input type="button" value="搜索"&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;a href="##" @click="changeCity('北京')"&gt;北京&lt;/a&gt;                &lt;a href="##" @click="changeCity('上海')"&gt;上海&lt;/a&gt;                &lt;a href="##" @click="changeCity('广州')"&gt;广州&lt;/a&gt;                &lt;a href="##" @click="changeCity('深圳')"&gt;深圳&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li v-for="item in weatherList"&gt;                &lt;div&gt;{{item.date}}&lt;/div&gt;                &lt;span&gt;{{item.low}} ~ {{item.high}}&lt;/span&gt;                &lt;span&gt;{{item.type}}&lt;/span&gt;                &lt;span&gt;{{item.fengxiang}}&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;     &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;     JS    window.onload=function(){        var vm=new Vue({            el: "#app",            data: {                city: "",                weatherList: []            },            methods: {                searchTQ(){                    var that=this;                    axios.get("http://wthrcdn.etouch.cn/weather_mini?city="                    +this.city).then(function(resq){                        that.weatherList=resq.data.data.forecast;                    },function(err){                        alert(err);                    })                },                changeCity(city){                    this.city=city;                    this.searchTQ();                }            }        });    };</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/d0001.html"/>
      <url>posts/d0001.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id="Canvas-平移-translate"><a href="#Canvas-平移-translate" class="headerlink" title="Canvas 平移 translate()"></a>Canvas 平移 translate()</h2><p>平移 (translate) 就是将一个图形往水平方向和垂直方向移动一定的距离 <strong>(dx,dy)</strong></p><p>但是，Canvas 中的所有几何变换针对的不是绘制的图形，而是针对画布本身</p><p>例如刚开始的时候在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_42.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>translate(50,50)</strong> 将画布水平和垂直方向各移动 50</p><p>然后在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_43.png"></p><p>此时矩形的起点距离屏幕左上角就已经是 <strong>(100,100)</strong> 了</p><p><strong>语法</strong><br><code>void ctx.translate(dx, dy);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的移动距离</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的移动距离</td></tr></tbody></table><p>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后平移 canvas (50,50) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.translate(50,50);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_44.png"></p><hr><h2 id="Canvas-缩放-scale"><a href="#Canvas-缩放-scale" class="headerlink" title="Canvas 缩放 scale()"></a>Canvas 缩放 scale()</h2><p>缩放 (scale) 就是将一个图形围绕中心点，然后将宽和高分别乘以一定的因子(sx,sy)</p><p>但是，Canvas 中的缩放 (scale) 针对的不是绘制的图形，而是针对画布本身</p><p>画布缩放了，那么画在画布上的图形自然也就缩放了</p><p>例如刚开始的时候在 <strong>(100,100)</strong> 绘制一个 <strong>25x25</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_45.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>scale(0.5,2)</strong> 将画布水平方向缩小一倍和垂直方向放大一倍的时候</p><p>这是什么意思呢？</p><p>就是原来水平方向的 1 个单位现在变成了 0.5 个单位了，垂直方向的 1 个单位现在变成了 2 个单位了</p><p>然后在 <strong>(100,100)</strong> 绘制一个 <strong>5x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_46.png"></p><p><strong>ctx.scale()</strong> 将 <strong>canvas</strong> 水平方向和垂直方向的单位各乘以一定的因子(sx,sy)</p><p>从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离</p><p><strong>语法</strong><br><code>void ctx.scale(sx, sy)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的缩放因子</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的缩放因子</td></tr></tbody></table><p>dx 和 dy 的值可以是负数，负数是啥意思呢？就是想把整个 canvas 翻转，然后再缩放</p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后缩放画布 canvas <strong>(0.5,2)</strong> 最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_47.png"></p><p>如果缩放因子是负数，那么先镜像 (也就是先翻转)，然后再缩放</p><p>如果 sx 是负数，则先按照 Y 轴镜像，然后再缩放<br>如果 sy 是负数，则先按照 X 轴镜像，然后再缩放<br>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后缩放画布 canvas (-0.5,2) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_48.png"></p><p>哎呀，为什么绿色的没掉了呢？因为，因为垂直镜像了之后，x 轴正方向已经从水平向左改成水平向右了</p><p>如果此时还在 <strong>(50,50)</strong> 的位置画画，肯定是看不到啊，因为它已经跑到另一边去了，而屏幕的位置没变啊，于是就看不到了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_49.png"><br>绿色边框是我们的屏幕显示范围</p><p>如果此时还要看到它，就要把绘制起始点的 x 坐标也翻转下，然后再 x 2 就是变成 (-50)x2=-100 就好了</p><p>如果不 x 2 ，结果还是看不到的，因为 -50 也只是把矩形往右移动了 50 像素，到哪里了？ 贴边了…</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-3");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(-100,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_50.png"></p><hr><h2 id="Canvas-旋转-rotate"><a href="#Canvas-旋转-rotate" class="headerlink" title="Canvas 旋转 rotate()"></a>Canvas 旋转 rotate()</h2><p>旋转 ( rotate ) 就是将图形围绕一个中心点(0,0)，顺时针或者逆时针旋转一定的弧度 ( angle )</p><p>但是，Canvas 中的旋转 ( rotate ) 针对的不是绘制的图形，而是针对画布本身</p><p>画布旋转了，带来最直接的结果是什么呢？ 就是某个点与屏幕上边之间的夹角改变了</p><p>我们看一个正常情况下的笛卡尔坐标体系，某个点(50,50) 与屏幕上边和 X 轴正方向之间的夹角都是 45 度</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_51.png"></p><p><strong>绿色</strong> 的是屏幕</p><p><strong>灰色</strong> 的是画布</p><p>当我们画布顺时针旋转 30 度后，就变成了下图这样了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_52.png"></p><p>点还是那个点，点与画布之间的夹角还是 <strong>45°</strong>，但点与屏幕间的夹角已经变成了 <strong>75°</strong></p><p>最直观的感受是啥？ 就是点往左下移了那么一点点，我们去掉各种辅助线，大家看看</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_53.png"></p><p>一个点已经是这样了，如果我们画的是一个图形，那么图形上的所有点都移动了，那么直观看起来，就是图形旋转了</p><p><strong>语法</strong><br><code>void ctx.rotate(angle);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">angle</td><td align="left">顺时针旋转的弧度。可以通过角度值计算：degree * Math.PI / 180</td></tr></tbody></table><p><strong>弧度 angle</strong><br>我们特别说明下 <strong>angle</strong> 这个参数，它是一个弧度</p><p>如果我们要顺时针旋转<strong>30°</strong>，那么</p><p><code>angle = 30 * Math.PI / 180</code><br>如果想要逆时针旋转 <strong>30°</strong> 怎么办呢？逆时针旋转 30°，其实就是顺时针旋转 -30°，也就是</p><p><code>angle = 360 + ( -30 * Math.PI / 180 )</code></p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后顺时针旋转画布 <strong>30°</strong></p><p>最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.rotate(30 * Math.PI / 180);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_54.png"></p><p>我们利用多次旋转画一个折扇图</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var colors = ['#D0021B','#F5A623','#8B572A','#417505','#9013FE','#000000']for ( var i = 0; i &lt; colors.length; i++ ){    ctx.fillStyle = colors[i];    ctx.fillRect(0,0,200,50);    ctx.rotate(15 * Math.PI / 180);}&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_55.png"></p><hr><h2 id="Canvas-橡皮擦-clearRect"><a href="#Canvas-橡皮擦-clearRect" class="headerlink" title="Canvas 橡皮擦 clearRect()"></a>Canvas 橡皮擦 clearRect()</h2><p><strong>ctx.clearRect()</strong> 方法设置指定矩形区域内（以点 (x, y) 为起点，范围是 (width, height) ）所有像素变成透明，并擦除之前绘制的所有内容</p><p><strong>语法</strong><br><code>void ctx.clearRect(x, y, width, height);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">矩形起点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">矩形起点的 y 轴坐标</td></tr><tr><td align="left">width</td><td align="left">矩形的宽度</td></tr><tr><td align="left">height</td><td align="left">矩形的高度</td></tr></tbody></table><p>我们先从 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形，然后再使用 clearRect() 擦出这个矩形的 1/4</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);ctx.clearRect(50,50,200/2,50/2);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_56.png"></p><hr><h2 id="Canvas-绘图上下文-save"><a href="#Canvas-绘图上下文-save" class="headerlink" title="Canvas 绘图上下文 save()"></a>Canvas 绘图上下文 save()</h2><p>Canvas 为我们提供了 图层(Layer) 的支持，Layer(图层) 是按 “栈结构” 来进行管理的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_57.png"></p><p>当我们调用<strong>save()</strong> 方法，会保存当前 Canvas 的状态然后作为一个 Layer(图层)，添加到 Canvas栈 中，</p><p>而当我们调用 <strong>restore()</strong> 方法的时候，会恢复之前 Canvas 的状态，而此时 Canvas 的图层栈 会弹出栈顶的那个 Layer，后继的 Layer 来到栈顶，此时的 Canvas 回复到此栈顶时保存的 Canvas 状态</p><p>简单说就是 <strong>save() 往栈压入一个 Layer，restore()弹出栈顶的一个Layer，这个 Layer 代表Canvas的 状态</strong>！</p><p>也就是说可以 <strong>save()</strong> 多次，也可以 <strong>restore()</strong> 多次，但是 <strong>restore()</strong> 的调用次数 不能大于 <strong>save()</strong> 否则会引发错误</p><p><code>ctx.save()</code> 方法用于将画布的当前状态保存到栈中</p><p>下面的代码使用 save() 方法保存默认的状态，然后平移 (100,100) 绘制一个绿色矩形后，恢复之前的状态，最后再使用默认的设置绘制一个矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.save();ctx.translate(100,100);ctx.fillStyle = "green"ctx.fillRect(50,50,100,50);ctx.restore();ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_58.png"></p><hr><h2 id="Canvas-恢复画板状态-restore"><a href="#Canvas-恢复画板状态-restore" class="headerlink" title="Canvas 恢复画板状态 restore()"></a>Canvas 恢复画板状态 restore()</h2><p><code>ctx.restore()</code> 方法用于将画布恢复到最近一次的保存状态</p><p>如果没有保存状态，此方法不做任何改变</p><hr><h2 id="Canvas-图像混排模式"><a href="#Canvas-图像混排模式" class="headerlink" title="Canvas 图像混排模式"></a>Canvas 图像混排模式</h2><p>首先绘制一个蓝色的矩形，然后绘制一个红色矩形和它重叠，看看不同的图形混排模式带来的效果</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_59.png"></p><p><strong>所有代码如下</strong></p><pre><code>&lt;canvas id="canvas-1" width="500" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var gco = [ 'source-over','source-in','source-out','source-atop',            'destination-over','destination-in','destination-out','destination-atop',            'lighter', 'copy','xor', 'multiply', 'screen', 'overlay', 'darken',            'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'        ];var canvas = document.getElementById("canvas-1");canvas.width = 500;canvas.height = 2700;var ctx = canvas.getContext("2d");function draw(){    for (var i = 0; i &lt; gco.length; i++ )    {        ctx.font = "16px Microsoft YaHei"        ctx.textBaseline = "middle";        ctx.fillStyle="#333"        ctx.save();        ctx.fillText(gco[i],10,15);        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.translate(70,0)        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.fillStyle = "red";        ctx.fillRect(25, 50, 50, 50);        var canvas2 = document.createElement("canvas");        ctx2 = canvas2.getContext("2d");        ctx2.fillStyle = "blue";        ctx2.fillRect(10, 35, 50, 50);        ctx2.globalCompositeOperation = gco[i];        ctx2.fillStyle = "red";        ctx2.fillRect(25, 50, 50, 50);        ctx2.globalCompositeOperation = "source-over";        ctx.drawImage(canvas2,85,0);        ctx.restore();        ctx.translate(0,100);    }}draw();&lt;/script&gt;</code></pre><hr><h2 id="Canvas-图像裁剪"><a href="#Canvas-图像裁剪" class="headerlink" title="Canvas 图像裁剪"></a>Canvas 图像裁剪</h2><p>裁剪用于隐藏部分我们不想看到的图形</p><p>Canvas 中的裁剪和 Photoshop 中的裁剪不一样，Photoshop 中的裁剪针对的是图形，而 Canvas 中的裁剪针对的是画布本身</p><p>Canvas 中的裁剪只有一种方法，就是根据路径来裁剪</p><p>比如我们有一个画布，画布上有一张图片和一个五角星的路径</p><p><strong>语法</strong><br><code>void ctx.clip();</code><br><code>void ctx.clip(fillRule);</code><br><code>void ctx.clip(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">裁剪算法，用于设置判断一个点是在路径内还是在路径外，可选的值有</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕原则，默认的原则</td></tr><tr><td align="left">“evenodd”: 奇偶环绕原则</td><td align="left"></td></tr><tr><td align="left">path</td><td align="left">需要剪切的 Path2D 路径</td></tr></tbody></table><p>先画一个路径，然后调用 clip() 说我要裁剪接下来的图形，而且终身有效</p><p>如果不需要了，那么可以在调用 clip() 前先调用 save() 保存状态，然后再使用完后调用 </p><p>restore() 恢复状态</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c2   = document.getElementById("canvas-2");var ctx2 = c2.getContext("2d");ctx2.save();ctx2.arc(100, 100, 75, 0, Math.PI*2, false);ctx2.clip();ctx2.fillRect(0, 0, 100,100);ctx2.fillStyle="green";ctx2.fillRect(100, 100, 100,100);ctx2.restore();ctx2.fillStyle="red";ctx2.fillRect(40, 40, 30,30);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_60.png"></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> Canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
