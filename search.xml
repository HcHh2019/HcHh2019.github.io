<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0002.html"/>
      <url>posts/a0002.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong><br>本篇: <strong>基本引用类型(三) 原始值包装类型</strong><br>下篇: <strong><a href="a0003">基本引用类型(四) 单例内置对象</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p><pre><code>let s1 = "some text";let s2 = s1.substring(2);</code></pre><p>在这里，s1 是一个包含字符串的变量，它是一个原始值。第二行紧接着在 s1 上调用了 substring()方法，并把结果保存在 s2 中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步：</p><p>(1) 创建一个 String 类型的实例；<br>(2) 调用实例上的特定方法；<br>(3) 销毁实例。</p><p>可以把这 3 步想象成执行了如下 3 行 ECMAScript 代码：</p><pre><code>let s1 = new String("some text");let s2 = s1.substring(2);s1 = null;</code></pre><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过<br>用的是 Boolean 和 Number 包装类型而已。</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p><pre><code>let s1 = "some text";s1.color = "red";console.log(s1.color); // undefined</code></pre><p>可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用 typeof 会返回”object”，所有原始值包装对象都会转换为布尔值 true。</p><p>另外，Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。比如：</p><pre><code>let obj = new Object("some text");console.log(obj instanceof String); // true</code></pre><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，如下例所示：</p><p><code>let booleanObject = new Boolean(true);</code></p><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。</p><p>不过，Boolean 对象在 ECMAScript 中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用 Boolean 对象时，比如：</p><pre><code>let falseObject = new Boolean(false);let result = falseObject &amp;&amp; true;console.log(result); // truelet falseValue = false;result = falseValue &amp;&amp; true;console.log(result); // false</code></pre><p>在这段代码中，我们创建一个值为 false 的 Boolean 对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值 true 组合起来。在布尔算术中，false &amp;&amp; true 等于 false。可是，这个表达式是对 falseObject 对象而不是对它表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为 true，因此 falseObject 在这个表达式里实际上表示一个 true 值。那么true &amp;&amp; true 当然是 true。</p><p>除此之外，原始值和引用值（Boolean 对象）还有几个区别。首先，typeof 操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean 对象是 Boolean 类型的实例，在使instaceof 操作符时返回 true，但对原始值则返回 false，如下所示：</p><pre><code>console.log(typeof falseObject); // objectconsole.log(typeof falseValue); // booleanconsole.log(falseObject instanceof Boolean); // trueconsole.log(falseValue instanceof Boolean); // false</code></pre><p>理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值，如下例所示：</p><p><code>let numberObject = new Number(10);</code></p><p>valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串，如下所示：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>toFixed()方法返回包含指定小数点位数的数值字符串，如：</p><pre><code>let num = 10;console.log(num.toFixed(2)); // "10.00"</code></pre><p>这里的 toFixed()方法接收了参数 2，表示返回的数值字符串要包含两位小数。结果返回值为”10.00”，小数位填充了 0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小位：</p><pre><code>let num = 10.005;console.log(num.toFixed(2)); // "10.01"</code></pre><p>toFixed()自动舍入的特点可以用于处理货币。不过要注意的是，多个浮点数值的数学计算不一定得到精确的结果。比如，0.1 + 0.2 = 0.30000000000000004。</p><p>另一个用于格式化数值的方法是 toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。与 toFixed()一样，toExponential()也接收一个参数，表示结果中小数的位数。来看下面的例子：</p><pre><code>let num = 10;console.log(num.toExponential(1)); // "1.0e+1"</code></pre><p>toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）。来看几个例子：</p><pre><code>let num = 99;console.log(num.toPrecision(1)); // "1e+2"console.log(num.toPrecision(2)); // "99"console.log(num.toPrecision(3)); // "99.0" </code></pre><p>与 Boolean 对象类似，Number 对象也为数值提供了重要能力。但是，考虑到两者存在同样的潜在问题，因此并不建议直接实例化 Number 对象。</p><pre><code>let numberObject = new Number(10);let numberValue = 10;console.log(typeof numberObject); // "object"console.log(typeof numberValue); // "number"console.log(numberObject instanceof Number); // trueconsole.log(numberValue instanceof Number); // false </code></pre><p>isInteger()方法与安全整数<br>ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的 0可能会让人误以为数值是一个浮点值：</p><pre><code>console.log(Number.isInteger(1)); // trueconsole.log(Number.isInteger(1.00)); // trueconsole.log(Number.isInteger(1.01)); // false</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值，如下例所示：</p><p><code>let stringObject = new String("hello world");</code></p><p>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleStrin()和 toString()都返回对象的原始字符串值。</p><p>每个 String 对象都有一个 length 属性，表示字符串中字符的数量。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.length); // "11"</code></pre><p>charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符：</p><pre><code>let message = "abcde";console.log(message.charAt(2)); // "c" </code></pre><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><p>首先是 concat()，用于将一个或多个字符串拼接成一个新字符串。来看下面的例子：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world");console.log(result); // "hello world"console.log(stringValue); // "hello" </code></pre><p>在这个例子中，对 stringValue 调 用 concat()方法的结果是得到”hello world”， 但<br>stringValue 的值保持不变。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字串，如下所示：</p><pre><code>let stringValue = "hello ";let result = stringValue.concat("world", "!");console.log(result); // "hello world!"console.log(stringValue); // "hello"</code></pre><p>虽然 concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。而且多数情况下，对拼接多个字符串来说，使用加号更方便。</p><p>ECMAScript 提供了 3 个从字符串中提取子字符串的方法：slice()、substr()和 substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符开始的位置，第二个参数表示子字符串结束的位置。对 slice()和 substring()而言，第二个参数是取结束的位置（即该位置之前的字符会被提取出来）。对 substr()而言，第二个参数表示返回的子字串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat()方法一样，slice()substr()和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。来下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.slice(3)); // "lo world"console.log(stringValue.substring(3)); // "lo world"console.log(stringValue.substr(3)); // "lo world"console.log(stringValue.slice(3, 7)); // "lo w"console.log(stringValue.substring(3,7)); // "lo w"console.log(stringValue.substr(3, 7)); // "lo worl"</code></pre><p>substr()返回”lo worl”，因为第二个参数对它而言表示返回的字符数</p><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><p>有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串。来看下面的例子：</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o")); // 4console.log(stringValue.lastIndexOf("o")); // 7</code></pre><p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。</p><pre><code>let stringValue = "hello world";console.log(stringValue.indexOf("o", 6)); // 7console.log(stringValue.lastIndexOf("o", 6)); // 4 </code></pre><p>像这样使用第二个参数并循环调用indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串，如下所示：</p><pre><code>let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";let positions = new Array();let pos = stringValue.indexOf("e");while(pos &gt; -1) {    positions.push(pos);    pos = stringValue.indexOf("e", pos + 1);}console.log(positions); // [3,24,32,35,52]</code></pre><p>这个例子逐步增大开始搜索的位置，通过 indexOf()遍历了整个字符串。首先取得第一个”e”的位置，然后进入循环，将上一次的位置加 1 再传给 indexOf()，确保搜索到最后一个子字符串实例之后。每个位置都保存在 positions 数组中，可供以后使用。</p><h4 id="字符串包含方法"><a href="#字符串包含方法" class="headerlink" title="字符串包含方法"></a>字符串包含方法</h4><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("bar")); // falseconsole.log(message.endsWith("baz")); // trueconsole.log(message.endsWith("bar")); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("qux")); // false</code></pre><p>startsWith()和 includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。下面是一个例子：</p><pre><code>let message = "foobarbaz";console.log(message.startsWith("foo")); // trueconsole.log(message.startsWith("foo", 1)); // falseconsole.log(message.includes("bar")); // trueconsole.log(message.includes("bar", 4)); // false</code></pre><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h4><p>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：</p><pre><code>let stringValue = " hello world ";let trimmedStringValue = stringValue.trim();console.log(stringValue); // " hello world "console.log(trimmedStringValue); // "hello world"</code></pre><p>由于 trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。另外，trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符。</p><h4 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h4><p>ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p><pre><code>let stringValue = "na ";console.log(stringValue.repeat(16) + "batman");// na na na na na na na na na na na na na na na na batman</code></pre><h4 id="padStart-和-padEnd-方法"><a href="#padStart-和-padEnd-方法" class="headerlink" title="padStart()和 padEnd()方法"></a>padStart()和 padEnd()方法</h4><p>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(6)); // " foo"console.log(stringValue.padStart(9, ".")); // "......foo"console.log(stringValue.padEnd(6)); // "foo "console.log(stringValue.padEnd(9, ".")); // "foo......"</code></pre><p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p><pre><code>let stringValue = "foo";console.log(stringValue.padStart(8, "bar")); // "barbafoo"console.log(stringValue.padStart(2)); // "foo"console.log(stringValue.padEnd(8, "bar")); // "foobarba"console.log(stringValue.padEnd(2)); // "foo"</code></pre><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><p>下一组方法涉及大小写转换，包括 4 个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的法，与 java.lang.String 中的方法同名。toLocaleLowerCase()和 toLocaleUpperCase()方法旨在于特定地区实现。</p><pre><code>let stringValue = "hello world";console.log(stringValue.toLocaleUpperCase()); // "HELLO WORLD"console.log(stringValue.toUpperCase()); // "HELLO WORLD"console.log(stringValue.toLocaleLowerCase()); // "hello world"console.log(stringValue.toLowerCase()); // "hello world" </code></pre><h4 id="字符串模式匹配方法"><a href="#字符串模式匹配方法" class="headerlink" title="字符串模式匹配方法"></a>字符串模式匹配方法</h4><p>String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象。来看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;// 等价于 pattern.exec(text)let matches = text.match(pattern);console.log(matches.index); // 0console.log(matches[0]); // "cat"console.log(pattern.lastIndex); // 0</code></pre><p>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返-1。search()始终从字符串开头向后匹配模式。看下面的例子：</p><pre><code>let text = "cat, bat, sat, fat";let pos = text.search(/at/);console.log(pos); // 1 </code></pre><p>为简化子字符串替换操作，ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let result = text.replace("at", "ond");console.log(result); // "cond, bat, sat, fat"result = text.replace(/at/g, "ond");console.log(result); // "cond, bond, sond, fond"</code></pre><p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。ECMA-262 中规定了下表中的值。</p><table><thead><tr><th align="left">字符序列</th><th align="left">替换文本</th></tr></thead><tbody><tr><td align="left">$$</td><td align="left">$</td></tr><tr><td align="left">$&amp;</td><td align="left">匹配整个模式的子字符串。与 RegExp.lastMatch 相同</td></tr><tr><td align="left">$’</td><td align="left">匹配的子字符串之前的字符串。与 RegExp.rightContext 相同</td></tr><tr><td align="left">$`</td><td align="left">匹配的子字符串之后的字符串。与 RegExp.leftContext 相同</td></tr><tr><td align="left">$n</td><td align="left">匹配第 n 个捕获组的字符串，其中 n 是 0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr><tr><td align="left">$nn</td><td align="left">匹配第 nn 个捕获组字符串，其中 nn 是 01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/a0001.html"/>
      <url>posts/a0001.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong><br>本篇: <strong>基本引用类型(二) RegExp</strong><br>下篇: <strong><a href="a0002">基本引用类型(三) 原始值包装类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p><ol><li><p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。</p></li><li><p>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</p></li><li><p>m：多行模式，表示查找到一行文本末尾时会继续查找。</p></li><li><p>y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</p></li><li><p>u：Unicode 模式，启用 Unicode 匹配。</p></li><li><p>s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。</p></li></ol><p>使用不同模式和标记可以创建出各种正则表达式，比如：</p><pre><code>// 匹配字符串中的所有"at"let pattern1 = /at/g;// 匹配第一个"bat"或"cat"，忽略大小写let pattern2 = /[bc]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi; </code></pre><p>与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：</p><p>( [ { \ ^ $ | ) ] } ? * + . </p><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。下面是几个例子：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 匹配第一个"[bc]at"，忽略大小写let pattern2 = /\[bc\]at/i;// 匹配所有以"at"结尾的三字符组合，忽略大小写let pattern3 = /.at/gi;// 匹配所有".at"，忽略大小写let pattern4 = /\.at/gi; </code></pre><p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建，比如：</p><pre><code>// 匹配第一个"bat"或"cat"，忽略大小写let pattern1 = /[bc]at/i;// 跟 pattern1 一样，只不过是用构造函数创建的let pattern2 = new RegExp("[bc]at", "i"); </code></pre><p>注意，RegExp 构造函数的两个参数都是字符串。因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\\，正则表达式字符串中则要写成\\\\）。下表展示了几个正则表达式的字面量形式，以及使用 RegExp 构造函数创建时对应的模式字符串。</p><table><thead><tr><th align="left">字面量模式</th><th align="left">对应的字符串</th></tr></thead><tbody><tr><td align="left">/\[bc\]at/</td><td align="left">“\\[bc\\]at”</td></tr><tr><td align="left">/\.at/</td><td align="left">“\\.at”</td></tr><tr><td align="left">/name\/age/</td><td align="left">“name\\/age”</td></tr><tr><td align="left">/\d.\d{1,2}/</td><td align="left">“\\d.\\d{1,2}”</td></tr><tr><td align="left">/\w\\hello\\123/</td><td align="left">“\\w\\\\hello\\\\123”</td></tr></tbody></table><p>此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><pre><code>const re1 = /cat/g;console.log(re1); // "/cat/g"const re2 = new RegExp(re1);console.log(re2); // "/cat/g"const re3 = new RegExp(re1, "i");console.log(re3); // "/cat/i" </code></pre><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。</p><ol><li><p>global：布尔值，表示是否设置了 g 标记。</p></li><li><p>ignoreCase：布尔值，表示是否设置了 i 标记。</p></li><li><p>unicode：布尔值，表示是否设置了 u 标记。</p></li><li><p>sticky：布尔值，表示是否设置了 y 标记。</p></li><li><p>lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</p></li><li><p>multiline：布尔值，表示是否设置了 m 标记。</p></li><li><p>dotAll：布尔值，表示是否设置了 s 标记。</p></li><li><p>source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。</p></li><li><p>flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</p></li></ol><p>通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含<br>这些信息。下面是一个例子：</p><pre><code>let pattern1 = /\[bc\]at/i;console.log(pattern1.global); // falseconsole.log(pattern1.ignoreCase); // trueconsole.log(pattern1.multiline); // falseconsole.log(pattern1.lastIndex); // 0console.log(pattern1.source); // "\[bc\]at"console.log(pattern1.flags); // "i"let pattern2 = new RegExp("\\[bc\\]at", "i");console.log(pattern2.global); // falseconsole.log(pattern2.ignoreCase); // trueconsole.log(pattern2.multiline); // falseconsole.log(pattern2.lastIndex); // 0console.log(pattern2.source); // "\[bc\]at"console.log(pattern2.flags); // "i" </code></pre><p>注意，虽然第一个模式是通过字面量创建的，第二个模式是通过 RegExp 构造函数创建的，但两个模式的 source 和 flags 属性是相同的。source 和 flags 属性返回的是规范化之后可以在字面量中使用的形式。</p><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><p>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。来看下面的例子：</p><pre><code>let text = "mom and dad and baby";let pattern = /mom( and dad( and baby)?)?/gi;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" </code></pre><p>在这个例子中，模式包含两个捕获组：最内部的匹配项” and baby”，以及外部的匹配项” and dad”或” and dad and baby”。调用 exec()后找到了一个匹配项。因为整个字符串匹配模式，所以 matchs数组的 index 属性就是 0。数组的第一个元素是匹配的整个字符串，第二个元素是匹配第一个捕获的字符串，第三个元素是匹配第二个捕获组的字符串。</p><p>如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 0 </code></pre><p>上面例子中的模式没有设置全局标记，因此调用 exec()只返回第一个匹配项（”cat”）。lastIndex在非全局模式下始终不变。</p><p>如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项，如下面的例子所示：</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/g;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8matches = pattern.exec(text);console.log(matches.index); // 10console.log(matches[0]); // satconsole.log(pattern.lastIndex); // 13</code></pre><p>这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。注意模式的 lastIndex 属性每次都会变化。在全局匹配模式下，每次调用 exec()都会更新 lastIndex 值，以反映上次匹配的最后一个字符的索引。</p><p>如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项。粘附标记覆盖全局标记。</p><pre><code>let text = "cat, bat, sat, fat";let pattern = /.at/y;let matches = pattern.exec(text);console.log(matches.index); // 0console.log(matches[0]); // catconsole.log(pattern.lastIndex); // 3// 以索引 3 对应的字符开头找不到匹配项，因此 exec()返回 null// exec()没找到匹配项，于是将 lastIndex 设置为 0matches = pattern.exec(text);console.log(matches); // nullconsole.log(pattern.lastIndex); // 0// 向前设置 lastIndex 可以让粘附的模式通过 exec()找到下一个匹配项：pattern.lastIndex = 5;matches = pattern.exec(text);console.log(matches.index); // 5console.log(matches[0]); // batconsole.log(pattern.lastIndex); // 8</code></pre><p>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。test()经常用在 if 语句中：</p><pre><code>let text = "000-00-0000";let pattern = /\d{3}-\d{2}-\d{4}/;if (pattern.test(text)) {console.log("The pattern was matched."); </code></pre><p>在这个例子中，正则表达式用于测试特定的数值序列。如果输入的文本与模式匹配，则显示匹配成功的消息。这个用法常用于验证用户输入，此时我们只在乎输入是否有效，不关心为什么无效。</p><p>无论正则表达式是怎么创建的，继承的方法 toLocaleString()和 toString()都返回正则表达式的字面量表示。比如：</p><pre><code>let pattern = new RegExp("\\[bc\\]at", "gi");console.log(pattern.toString()); // /\[bc\]at/giconsole.log(pattern.toLocaleString()); // /\[bc\]at/gi</code></pre><p>这里的模式是通过 RegExp 构造函数创建的，但 toLocaleString()和 toString()返回的都是其字面量的形式。</p><p><strong>注意</strong> 正则表达式的 valueOf()方法返回正则表达式本身。</p><h3 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h3><p>每个属性都有一个全名和一个简写。下表列出了RegExp 构造函数的属性</p><table><thead><tr><th align="left">全 名</th><th align="left">简 写</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">input</td><td align="left">$_</td><td align="left">最后搜索的字符串（非标准特性）</td></tr><tr><td align="left">lastMatch</td><td align="left">$&amp;</td><td align="left">最后匹配的文本</td></tr><tr><td align="left">lastParen</td><td align="left">$+</td><td align="left">最后匹配的捕获组（非标准特性）</td></tr><tr><td align="left">leftContext</td><td align="left">$`</td><td align="left">input 字符串中出现在 lastMatch 前面的文本</td></tr><tr><td align="left">rightContext</td><td align="left">$’</td><td align="left">input 字符串中出现在 lastMatch 后面的文本</td></tr></tbody></table><p>通过这些属性可以提取出与 exec()和 test()执行的操作相关的信息。来看下面的例子：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;if (pattern.test(text)) {  console.log(RegExp.input); // this has been a short summer  console.log(RegExp.leftContext); // this has been a  console.log(RegExp.rightContext); // summer  console.log(RegExp.lastMatch); // short  console.log(RegExp.lastParen); // s} </code></pre><p>以上代码创建了一个模式，用于搜索任何后跟”hort”的字符，并把第一个字符放在了捕获组中。不同属性包含的内容如下</p><ol><li><p>input 属性中包含原始的字符串。</p></li><li><p>leftConext 属性包含原始字符串中”short”之前的内容，rightContext 属性包含”short”之后的内容。</p></li><li><p>lastMatch 属性包含匹配整个正则表达式的上一个字符串，即”short”。</p></li><li><p>lastParen 属性包含捕获组的上一次匹配，即”s”。</p></li></ol><p>这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问，如下面的例子所示，因为大多数简写形式都不是合法的 ECMAScript 标识符：</p><pre><code>let text = "this has been a short summer";let pattern = /(.)hort/g;/** 注意：Opera 不支持简写属性名* IE 不支持多行匹配*/if (pattern.test(text)) {  console.log(RegExp.$_); // this has been a short summer  console.log(RegExp["$`"]); // this has been a  console.log(RegExp["$'"]); // summer  console.log(RegExp["$&amp;"]); // short  console.log(RegExp["$+"]); // s}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(三)</title>
      <link href="posts/58a1.html"/>
      <url>posts/58a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>引用值（或者对象）是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲 JavaScript 是一门面向对象语言，但ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><p><strong>注意</strong> 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆,本章后面不会使用术语“类”。</p><p><strong>注意</strong> 函数也是一种引用类型，详情请转至 第八章函数章节</p><p>上篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong><br>本篇: <strong>基本引用类型(一) Date</strong><br>下篇: <strong><a href="a0001">基本引用类型(二) RegExp</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月1 日之前及之后的日期。</p><p>要创建日期对象，就使用 new 操作符来调用 Date 构造函数：</p><p><code>let now = new Date();</code></p><p>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒<br>数。</p><ol><li>“月/日/年”，如”5/23/2019”；</li><li>“月名 日, 年”，如”May 23, 2019”；</li><li>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”；</li><li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00</li></ol><p>比如，要创建一个表示“2019 年 5 月 23 日”的日期对象，可以使用以下代码：</p><p><code>let someDate = new Date(Date.parse("May 23, 2019")); </code></p><p>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。换句话说，下面这行代码跟前面那行代码是等价的：</p><p><code>let someDate = new Date("May 23, 2019"); </code></p><p>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1<del>31）、（0</del>23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默为 1 日。其他参数的默认值都是 0。下面是使用 Date.UTC()的两个例子：</p><pre><code>// GMT 时间 2000 年 1 月 1 日零点let y2k = new Date(Date.UTC(2000, 0));// GMT 时间 2005 年 5 月 5 日下午 5 点 55 分 55 秒let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); </code></pre><p>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数。这个方法可以方便地用在代码分析中：</p><pre><code>// 起始时间let start = Date.now();// 调用函数doSomething();// 结束时间let stop = Date.now(),result = stop - start;</code></pre><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的 AM（上午）或 PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的。下面给出了 toLocaleString()和 toString()返回的2019 年 2 月 1 日零点的示例（地区为”en-US”的 PST，即 Pacific Standard Time，太平洋标准时间）：</p><pre><code>toLocaleString() - 2/1/2019 12:00:00 AMtoString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time) </code></pre><p>Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。比如下面的例子：</p><pre><code>let date1 = new Date(2019, 0, 1); // 2019 年 1 月 1 日let date2 = new Date(2019, 1, 1); // 2019 年 2 月 1 日console.log(date1 &lt; date2); // trueconsole.log(date1 &gt; date2); // false </code></pre><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ol><li><p>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；</p></li><li><p>toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）;</p></li><li><p>toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；</p></li><li><p>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；</p></li><li><p>toUTCString()显示完整的 UTC 日期（格式特定于实现）。</p></li></ol><p>这些方法的输出与 toLocaleString()和 toString()一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p><h3 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h3><p>Date 类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p><table><thead><tr><th align="left">方 法</th><th align="left">说 明</th></tr></thead><tbody><tr><td align="left">getTime()</td><td align="left">返回日期的毫秒表示；与 valueOf()相同</td></tr><tr><td align="left">setTime(milliseconds)</td><td align="left">设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td align="left">getFullYear()</td><td align="left">返回 4 位数年（即 2019 而不是 19）</td></tr><tr><td align="left">getUTCFullYear()</td><td align="left">返回 UTC 日期的 4 位数年</td></tr><tr><td align="left">setFullYear(year)</td><td align="left">设置日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">setUTCFullYear(year)</td><td align="left">设置 UTC 日期的年（year 必须是 4 位数）</td></tr><tr><td align="left">getMonth()</td><td align="left">返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">getUTCMonth()</td><td align="left">返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="left">setMonth(month)</td><td align="left">设置日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">setUTCMonth(month)</td><td align="left">设置 UTC 日期的月（month 为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="left">getDate()</td><td align="left">返回日期中的日（1~31）</td></tr><tr><td align="left">getUTCDate()</td><td align="left">返回 UTC 日期中的日（1~31）</td></tr><tr><td align="left">setDate(date)</td><td align="left">设置日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">setUTCDate(date)</td><td align="left">设置 UTC 日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="left">getDay()</td><td align="left">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getUTCDay()</td><td align="left">返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="left">getHours()</td><td align="left">返回日期中的时（0~23）</td></tr><tr><td align="left">getUTCHours()</td><td align="left">返回 UTC 日期中的时（0~23）</td></tr><tr><td align="left">setHours(hours)</td><td align="left">设置日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">setUTCHours(hours)</td><td align="left">设置 UTC 日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="left">getMinutes()</td><td align="left">返回日期中的分（0~59）</td></tr><tr><td align="left">getUTCMinutes()</td><td align="left">返回 UTC 日期中的分（0~59）</td></tr><tr><td align="left">setMinutes(minutes)</td><td align="left">设置日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">setUTCMinutes(minutes)</td><td align="left">设置 UTC 日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="left">getSeconds()</td><td align="left">返回日期中的秒（0~59）</td></tr><tr><td align="left">getUTCSeconds()</td><td align="left">返回 UTC 日期中的秒（0~59）</td></tr><tr><td align="left">setSeconds(seconds)</td><td align="left">设置日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">setUTCSeconds(seconds)</td><td align="left">设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="left">getMilliseconds()</td><td align="left">返回日期中的毫秒</td></tr><tr><td align="left">getUTCMilliseconds()</td><td align="left">返回 UTC 日期中的毫秒</td></tr><tr><td align="left">setMilliseconds(milliseconds)</td><td align="left">设置日期中的毫秒</td></tr><tr><td align="left">setUTCMilliseconds(milliseconds)</td><td align="left">设置 UTC 日期中的毫秒</td></tr><tr><td align="left">getTimezoneOffset()</td><td align="left">返回以分钟计的 UTC 与本地时区的偏移量（如美国 EST 即“东部标准时间”返回 300，进入夏令时的地区可能有所差异）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/c803.html"/>
      <url>posts/c803.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong><br>本篇: <strong>变量、作用域与内存(三) 垃圾回收</strong><br>下篇: <strong><a href="58a1">基本引用类型(一) Date</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>挖坑了~  QAQ<br>此坑挖于: 2020/11/20<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/85b1.html"/>
      <url>posts/85b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong><br>本篇: <strong>变量、作用域与内存(二) 执行上下文与作用域</strong><br>下篇: <strong><a href="c803">变量、作用域与内存(三) 垃圾回收</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variableobject），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象。</p><p>因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和const 的顶级声明不会定义在全局上下文中但在作用域链解析上效果是一样的。</p><p>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）</p><p>看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    if (color === "blue") {        color = "red";    } else {        color = "blue";    }}changeColor();</code></pre><p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。看一看下面这个例子：</p><pre><code>var color = "blue";function changeColor() {    let anotherColor = "red";    function swapColors() {        let tempColor = anotherColor;        anotherColor = color;        color = tempColor;        // 这里可以访问 color、anotherColor 和 tempColor    }    // 这里可以访问 color 和 anotherColor，但访问不到 tempColor    swapColors();}// 这里只能访问 colorchangeColor(); </code></pre><hr><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><p>虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这现象，即代码执行到下面任意一种情况时：</p><ol><li><p>try/catch 语句的 catch 块</p></li><li><p>with 语句</p></li></ol><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。看下面的例子：</p><pre><code>function buildUrl() {    let qs = "?debug=true";    with(location){        let url = href + qs;    }    return url;}</code></pre><p>这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用的是location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的那个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成为数上下文的一部分，可以作为函数的值被返回；但像这里使用 let 声明的变量 url，因为被限制在块作用域（稍后介绍），所以在 with 块之外没有定义。</p><hr><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="使用-var-的函数作用域声明"><a href="#使用-var-的函数作用域声明" class="headerlink" title="使用 var 的函数作用域声明"></a>使用 var 的函数作用域声明</h4><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p><pre><code>function add(num1, num2) {    var sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 报错：sum 在这里不是有效变量</code></pre><p>这里，函数 add()定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回，但变量 sum 在函数外部是访问不到的。如果省略上面例子中的关键字 var，那么 sum 在 add()被调用之后就变成可以访问的了，如下所示：</p><pre><code>function add(num1, num2) {    sum = num1 + num2;    return sum;}let result = add(10, 20); // 30console.log(sum); // 30 </code></pre><p><strong>注意</strong> 未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p><p>var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。下面的例子展示了在全局作用域中两等价的代码：</p><pre><code>var name = "Jake";// 等价于：name = 'Jake';var name;下面是两个等价的函数：function fn1() {    var name = 'Jake';}// 等价于：function fn2() {    var name;    name = 'Jake';} </code></pre><p>通过在声明之前打印变量，可以验证变量会被提升。声明的提升意味着会输出 undefined 而不是<br>Reference Error：</p><pre><code>console.log(name); // undefinedvar name = 'Jake';function() {    console.log(name); // undefined    var name = 'Jake';} </code></pre><h4 id="使用-let-的块级作用域声明"><a href="#使用-let-的块级作用域声明" class="headerlink" title="使用 let 的块级作用域声明"></a>使用 let 的块级作用域声明</h4><p>ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域。</p><p>let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。</p><pre><code>var a;var a;// 不会报错{    let b;    let b;}// SyntaxError: 标识符 b 已经声明过了</code></pre><p>let 的行为非常适合在循环中声明迭代变量。使用 var 声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</p><pre><code>for (var i = 0; i &lt; 10; ++i) {}console.log(i); // 10for (let j = 0; j &lt; 10; ++j) {}console.log(j); // ReferenceError: j 没有定义</code></pre><p>严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal deadzone）的缘故，实际上不能在声明之前使用 let 变量。因此，从写 JavaScript 代码的角度说，let 的提跟 var是不一样的。</p><h4 id="使用-const-的常量声明"><a href="#使用-const-的常量声明" class="headerlink" title="使用 const 的常量声明"></a>使用 const 的常量声明</h4><p>除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><pre><code>const a; // SyntaxError: 常量声明时没有初始化const b = 3;console.log(b); // 3b = 4; // TypeError: 给常量赋值</code></pre><p>const 除了要遵循以上规则，其他方面与 let 声明是一样的</p><p>const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><pre><code>const o1 = {};o1 = {}; // TypeError: 给常量赋值const o2 = {};o2.name = 'Jake';console.log(o2.name); // 'Jake'</code></pre><p>如果想让整个对象都不能修改，可以使用 Object.freeze()，这样再给属性赋值时虽然不会报错，但会静默失败：</p><pre><code>const o3 = Object.freeze({});o3.name = 'Jake';console.log(o3.name); // undefined </code></pre><p><strong>注意</strong> 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用<br>const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现<br>重新赋值导致的 bug。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/44e8.html"/>
      <url>posts/44e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><p>上篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong><br>本篇: <strong>变量、作用域与内存(一)原始值与引用值</strong><br>下篇: <strong><a href="85b1">变量、作用域与内存(二) 执行上下文与作用域</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。</p><hr><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：</p><pre><code>let person = new Object();person.name = "Nicholas";console.log(person.name); // "Nicholas" </code></pre><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：</p><pre><code>let name = "Nicholas";name.age = 27;console.log(name.age); // undefined </code></pre><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><pre><code>let name1 = "Nicholas";let name2 = new String("Matt");name1.age = 27;name2.age = 26;console.log(name1.age); // undefinedconsole.log(name2.age); // 26console.log(typeof name1); // stringconsole.log(typeof name2); // object </code></pre><hr><h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p><pre><code>let num1 = 5;let num2 = num1;</code></pre><p>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p><pre><code>let obj1 = new Object();let obj2 = obj1;obj1.name = "Nicholas";console.log(obj2.name); // "Nicholas" </code></pre><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><p>在按值传递参数时，值会被复制到一个局部变量在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部</p><pre><code>function addTen(num) {    num += 10;    return num;}let count = 20; let result = addTen(count);console.log(count); // 20，没有变化console.log(result); // 30 function setName(obj) {    obj.name = "Nicholas";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><pre><code>function setName(obj) {    obj.name = "Nicholas";    obj = new Object();    obj.name = "Greg";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><p><strong>注意</strong> ECMAScript 中函数的参数就是局部变量</p><hr><h3 id="确定类型-instanceof"><a href="#确定类型-instanceof" class="headerlink" title="确定类型 instanceof"></a>确定类型 instanceof</h3><p>前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返”object”，如下面的例子所示：</p><pre><code>let s = "Nicholas";let b = true;let i = 22;let u;let n = null;let o = new Object();console.log(typeof s); // stringconsole.log(typeof i); // numberconsole.log(typeof b); // booleanconsole.log(typeof u); // undefinedconsole.log(typeof n); // objectconsole.log(typeof o); // object </code></pre><p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型的实例，则 instanceof 操作符返回 true。来看下面的例子：</p><pre><code>console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><p>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。</p><p><strong>注意</strong></p><p>typeof 操作符在用于检测函数时也会返回”function”</p><p>typeof 对正则表达式也返回”function”，在 IE 和 Firefox 中，typeof 对正则表达式返回”object”</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a1.html"/>
      <url>posts/8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="873e">语言基础(四)操作符</a></strong><br>本篇: <strong>[语言基础(五)语句&amp;&amp;函数]</strong><br>下篇: <strong><a href="44e8">变量、作用域与内存(一)原始值与引用值</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环：</p><pre><code>for (;;) { // 无穷循环doSomething();} </code></pre><hr><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h3><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><pre><code>for (property in expression) statement</code></pre><p>下面是一个例子：</p><pre><code>for (const propName in window) {document.write(propName);} </code></pre><p>这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量propName 赋予一个 window 对象的属性作为值，直到 window 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。</p><p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</p><hr><h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h3><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><pre><code>for (property of expression) statement</code></pre><p>下面是示例：</p><pre><code>for (const el of [2,4,6,8]) {document.write(el);} </code></pre><p>在这个例子中，我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误</p><hr><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p><pre><code>label: statement</code></pre><p>下面是一个例子：</p><pre><code>start: for (let i = 0; i &lt; count; i++) {console.log(i);}</code></pre><p>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</p><hr><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        if (i == 5 &amp;&amp; j == 5) {            break outermost;        }    num++;    }}console.log(num); // 55</code></pre><p>在这个例子中，outermost 标签标识的是第一个 for 语句。正常情况下，每个循环执行 10 次，意味着 num++语句会执行 100 次，而循环结束时 console.log 的结果应该是 100。但是，break 语带来了一个变数，即要退出到的标签。添加标签不仅让 break 退出（使用变量 j 的）内部循环，也会退出（使用变量 i 的）外部循环。当执行到 i 和 j 都等于 5 时，循环停止执行，此时 num 的值是55。</p><p>continue语句也可以使用标签，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {     if (i == 5 &amp;&amp; j == 5) {       continue outermost;    }    num++;    }}console.log(num); // 95 </code></pre><p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次结果 num 等于 95。</p><p>组合使用标签语句和 break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><hr><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>with 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><pre><code>with (expression) statement;</code></pre><p>使用 with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：</p><pre><code>let qs = location.search.substring(1);let hostName = location.hostname;let url = location.href;</code></pre><p>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</p><pre><code>with(location) {let qs = search.substring(1);let hostName = hostname;let url = href;} </code></pre><p>这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 location 对象的属性。</p><p>严格模式不允许使用 with 语句，否则会抛出错误。</p><p><strong>警告</strong> 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p><hr><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>虽然 switch 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：</p><pre><code>switch ("hello world") {    case "hello" + " world":        console.log("Greeting was found.");        break;    case "goodbye":        console.log("Closing was found.");        break;    default:        console.log("Unexpected message was found.");} </code></pre><p>注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值。比如：</p><pre><code>function sum(num1, num2) {return num1 + num2;}</code></pre><p>要注意的是，只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。 </p><p>严格模式对函数也有一些限制：</p><ol><li><p>函数不能以 eval 或 arguments 作为名称；</p></li><li><p>函数的参数不能叫 eval 或 arguments；</p></li><li><p>两个命名参数不能拥有同一个名称。</p></li></ol><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/873e.html"/>
      <url>posts/873e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><p>上篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong><br>本篇: <strong>[语言基础(四)操作符]</strong><br>下篇: <strong><a href="8a1">语言基础(五)语句&amp;&amp;函数</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。</p><hr><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作符叫一元操作符。</p><h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="headerlink" title="递增/递减操作符"></a>递增/递减操作符</h4><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p><p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p><ol><li><p>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</p></li><li><p>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</p></li><li><p>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于浮点值，加 1 或减 1。</p></li><li><p>如果是对象，则调用其（第 3 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。</p></li></ol><p>下面的例子演示了这些规则：</p><pre><code>let s1 = "2";let s2 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1++; // 值变成数值 3s2++; // 值变成 NaNb++; // 值变成数值 1f--; // 值变成 0.10000000000000009（因为浮点数不精确）o--; // 值变成-2 </code></pre><hr><h4 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h4><p>如果将一元加应用到非数值,则会执行与使用Number()转型函数一样的类型转换：布尔值false和true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toStrin()方法以得到可以转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><pre><code>let s1 = "01";let s2 = "1.1"; let s3 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1 = +s1; // 值变成数值 1s2 = +s2; // 值变成数值 1.1s3 = +s3; // 值变成 NaNb = +b; // 值变成数值 0f = +f; // 不变，还是 1.1o = +o; // 值变成数值-1 </code></pre><p>一元减由一个减号（-）表示同上</p><hr><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>挖坑了~<br>此坑挖于:2020/11/20<br>此坑填于:~</p><hr><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h4><p>逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。<br>逻辑非操作符会遵循如下规则：</p><ol><li><p>如果操作数是对象，则返回 false。</p></li><li><p>如果操作数是空字符串，则返回 true。</p></li><li><p>如果操作数是非空字符串，则返回 false。</p></li><li><p>如果操作数是数值 0，则返回 true。</p></li><li><p>如果操作数是非 0 数值（包括 Infinity），则返回 false。</p></li><li><p>如果操作数是 null，则返回 true。</p></li><li><p>如果操作数是 NaN，则返回 true。</p></li><li><p>如果操作数是 undefined，则返回 true。</p></li></ol><p>以下示例验证了上述行为：</p><pre><code>console.log(!false); // trueconsole.log(!"blue"); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!""); // trueconsole.log(!12345); // false </code></pre><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p><pre><code>console.log(!!"blue"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!12345); // true </code></pre><hr><h4 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h4><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p><p>同真为真，其余全是假</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则:</p><ol><li><p>如果第一个操作数是对象，则返回第二个操作数。</p></li><li><p>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</p></li><li><p>如果两个操作数都是对象，则返回第二个操作数。</p></li><li><p>如果有一个操作数是 null，则返回 null。</p></li><li><p>如果有一个操作数是 NaN，则返回 NaN。</p></li><li><p>如果有一个操作数是 undefined，则返回 undefined</p></li></ol><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</p><hr><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h4><p>逻辑或操作符由两个管道符（||）表示</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：</p><ol><li><p>如果第一个操作数是对象，则返回第一个操作数。</p></li><li><p>如果第一个操作数求值为 false，则返回第二个操作数。</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数。</p></li><li><p>如果两个操作数都是 null，则返回 null。</p></li><li><p>如果两个操作数都是 NaN，则返回 NaN。</p></li><li><p>如果两个操作数都是 undefined，则返回 undefined。</p></li></ol><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。</p><hr><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h4 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h4><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。</p><p>乘法操作符在处理特殊值时也有一些特殊的行为。</p><ol><li><p>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以 0，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity -Infinity。</p></li><li><p>如果是 Infinity 乘以 Infinity，则返回 Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</p></li></ol><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p><p>跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ol><li><p>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果是 0 除以 0，则返回 NaN。</p></li><li><p>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><hr><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><p>取模（余数）操作符由一个百分比符号（%）表示</p><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为:</p><ol><li><p>如果操作数是数值，则执行常规除法运算，返回余数。</p></li><li><p>如果被除数是无限值，除数是有限值，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是 0，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是无限值，则返回被除数。</p></li><li><p>如果被除数是 0，除数不是 0，则返回 0。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h4 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>如果有一个操作数是字符串，则要应用如下规则：</p><ol><li><p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</p></li><li><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。</p></li></ol><p>看下面的例子：</p><pre><code>let result1 = 5 + 5; // 两个数值console.log(result1); // 10let result2 = 5 + "5"; // 一个数值和一个字符串console.log(result2); // "55" </code></pre><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + num1 + num2;console.log(message); // "The sum of 5 and 10 is 510" </code></pre><p>如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + (num1 + num2);console.log(message); // "The sum of 5 and 10 is 15" </code></pre><hr><h4 id="加法操作符-1"><a href="#加法操作符-1" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ol><li><p> 如果两个操作数都是数值，则执行数学减法运算并返回结果。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 减 Infinity，则返回 NaN。</p></li><li><p>如果是-Infinity 减-Infinity，则返回 NaN。</p></li><li><p>如果是 Infinity 减-Infinity，则返回 Infinity。</p></li><li><p>如果是-Infinity 减 Infinity，则返回-Infinity。</p></li><li><p>如果是+0 减+0，则返回+0。</p></li><li><p>如果是+0 减-0，则返回-0。</p></li><li><p>如果是-0 减-0，则返回+0。</p></li><li><p>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</p></li></ol><p>以下示例演示了上面的规则：</p><pre><code>let result1 = 5 - true; // true 被转换为 1，所以结果是 4let result2 = NaN - 1; // NaNlet result3 = 5 - 3; // 2let result4 = 5 - ""; // ""被转换为 0，所以结果是 5let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3let result6 = 5 - null; // null 被转换为 0，所以结果是 5 </code></pre><hr><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ol><li><p>如果操作数都是数值，则执行数值比较。</p></li><li><p>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</p></li><li><p>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p><p> let result = “23” &lt; “3”; // true</p></li></ol><p>这里在比较字符串”23”和”3”时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p><pre><code>let result = "23" &lt; 3; // false</code></pre><p>因为这次会将字符串”23”转换为数值 23，然后再跟 3 比较。但如果字符串不能转换成数值呢？比如下面这个例子：</p><pre><code>let result = "a" &lt; 3; // 因为"a"会转换为 NaN，所以结果是 false</code></pre><p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。</p><hr><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ol><li><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</p></li><li><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</p></li><li><p>如果一个操作数是对象，另，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</p></li></ol><p>在进行比较时，这两个操作符会遵循如下规则:</p><ol><li><p>null 和 undefined 相等。</p></li><li><p>null 和 undefined 不能转换为其他类型的值再进行比较。</p></li><li><p>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</p></li><li><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</p></li></ol><p>下表总结了一些特殊情况及比较的结果</p><table><thead><tr><th align="left">表 达 式</th><th align="left">结 果</th></tr></thead><tbody><tr><td align="left">null == undefined</td><td align="left">true</td></tr><tr><td align="left">“NaN” == NaN</td><td align="left">false</td></tr><tr><td align="left">5 == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN != NaN</td><td align="left">true</td></tr><tr><td align="left">false == 0</td><td align="left">true</td></tr><tr><td align="left">true == 1</td><td align="left">true</td></tr><tr><td align="left">true == 2</td><td align="left">false</td></tr><tr><td align="left">undefined == 0</td><td align="left">false</td></tr><tr><td align="left">null == 0</td><td align="left">false</td></tr><tr><td align="left">“5” == 5</td><td align="left">true</td></tr></tbody></table><h4 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</p><pre><code>let result1 = ("55" == 55); // true，转换后相等let result2 = ("55" === 55); // false，不相等，因为数据类型不同</code></pre><p>不全等操作符用一个叹号和两个等于号（!==）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：</p><pre><code>let result1 = ("55" != 55); // false，转换后相等let result2 = ("55" !== 55); // true，不相等，因为数据类型不同</code></pre><p>另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。</p><p>注意 由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</p><pre><code>variable = boolean_expression ? true_value : false_value;</code></pre><p>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果boolean_expression 是 false，则赋值 false_value。</p><hr><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><pre><code>let num1 = 1, num2 = 2, num3 = 3;</code></pre><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><pre><code>let num = (5, 1, 4, 8, 0); // num 的值为 0 </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a7.html"/>
      <url>posts/8a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="85be">语言基础(二)变量</a></strong><br>本篇: <strong>[语言基础(三)数据类型]</strong><br>下篇: <strong><a href="873e">语言基础(四)操作符</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。</p><hr><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p><p> “undefined”表示值未定义；<br> “boolean”表示值为布尔值；<br> “string”表示值为字符串；<br> “number”表示值为数值；<br> “object”表示值为对象（而不是函数）或 null；<br> “function”表示值为函数；<br> “symbol”表示值为符号。</p><p>下面是使用 typeof 操作符的例子：</p><pre><code>let message = "some string";console.log(typeof message); // "string"console.log(typeof(message)); // "string"console.log(typeof 95); // "number"</code></pre><p>在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><p>注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull 返回的是”object”。这是因为特殊值 null 被认为是一个对空对象的引用。</p><hr><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：</p><pre><code>let message;console.log(message == undefined); // true </code></pre><p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined // let age 确保没有声明过这个变量console.log(message); // "undefined"console.log(age); // 报错</code></pre><p>在上面的例子中，第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。</p><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// let age  确保没有声明过这个变量console.log(typeof message); // "undefined"console.log(typeof age); // "undefined"</code></pre><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// age 没有声明if (message) {// 这个块不会执行}if (!message) {// 这个块会执行}if (age) {// 这里会报错} </code></pre><hr><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：</p><pre><code>let car = null;console.log(typeof car); // "object" </code></pre><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后被重新赋予了一个对象的引用，比如：</p><pre><code>if (car != null) {// car 是一个对象的引用} </code></pre><p>undefined 值是由 null 值派生而来的<br>    console.log(null == undefined); // true </p><p>永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><pre><code>    let message = null;    let age;    if (message) {    // 这个块不会执行    }    if (!message) {    // 这个块会执行    }     if (age) {    // 这个块不会执行    }    if (!age) {    // 这个块会执行    } </code></pre><hr><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0</p><table><thead><tr><th align="left">数据类型</th><th align="left">转换为 true 的值</th><th align="left">转换为 false 的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">true</td><td align="left">false</td></tr><tr><td align="left">String</td><td align="left">非空字符串</td><td align="left">“”（空字符串）</td></tr><tr><td align="left">Number</td><td align="left">非零数值（包括无穷值）</td><td align="left">0、NaN（参见后面的相关内容）</td></tr><tr><td align="left">Object</td><td align="left">任意对象</td><td align="left">null</td></tr><tr><td align="left">Undefined</td><td align="left">N/A（不存在）</td><td align="left">undefined</td></tr></tbody></table><p>理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p><pre><code>let message = "Hello world!";if (message) {console.log("Value is true");}</code></pre><p>在这个例子中，console.log 会输出字符串”Value is true”，因为字符串 message 会被自动转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><hr><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><pre><code>let intNum = 55; // 整数</code></pre><p>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><pre><code>let octalNum1 = 070; // 八进制的 56let octalNum2 = 079; // 无效的八进制值，当成 79 处理let octalNum3 = 08; // 无效的八进制值，当成 8 处理</code></pre><p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p><p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0<del>9 以及 A</del>F）。十六进制数字中的字母大小写均可。下面是几个例子：</p><pre><code>let hexNum1 = 0xA; // 十六进制 10let hexNum2 = 0x1f; // 十六进制 31</code></pre><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><pre><code>let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐</code></pre><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：</p><pre><code>let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</code></pre><hr><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN：</p><pre><code>console.log(0/0); // NaNconsole.log(-0/+0); // NaN</code></pre><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：</p><pre><code>console.log(5/0); // Infinityconsole.log(5/-0); // -Infinity </code></pre><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><pre><code>console.log(NaN == NaN); // false </code></pre><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回<br>true。举例如下：</p><pre><code>console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false，10 是数值console.log(isNaN("10")); // false，可以转换为数值 10console.log(isNaN("blue")); // true，不可以转换为数值console.log(isNaN(true)); // false，可以转换为数值 1</code></pre><hr><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p><p>Number()函数基于如下规则执行转换。</p><p> 布尔值，true 转换为 1，false 转换为 0。<br> 数值，直接返回。<br> null，返回 0。<br> undefined，返回 NaN。<br> 字符串，应用以下规则。</p><ol><li><p>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面的零）。</p></li><li><p> 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p></li><li><p>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p></li><li><p>如果是空字符串（不包含字符），则返回 0。</p></li><li><p>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</p></li></ol><p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用<br>toString()方法，再按照转换字符串的规则转换。</p><pre><code>let num1 = Number("Hello world!"); // NaNlet num2 = Number(""); // 0let num3 = Number("000011"); // 11let num4 = Number(true); // 1</code></pre><p>可以看到，字符串”Hello world”转换之后是 NaN，因为它找不到对应的数值。</p><p>考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。下面几个转换示例有助于理解上述规则：</p><pre><code>let num1 = parseInt("1234blue"); // 1234let num2 = parseInt(""); // NaNlet num3 = parseInt("0xA"); // 10，解释为十六进制整数let num4 = parseInt(22.5); // 22let num5 = parseInt("70"); // 70，解释为十进制值let num6 = parseInt("0xf"); // 15，解释为十六进制整数</code></pre><p>通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p><pre><code>let num1 = parseInt("10", 2); // 2，按二进制解析let num2 = parseInt("10", 8); // 8，按八进制解析let num3 = parseInt("10", 10); // 10，按十进制解析let num4 = parseInt("10", 16); // 16，按十六进制解析</code></pre><p>parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p>parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。下面是几个示例：</p><pre><code>let num1 = parseFloat("1234blue"); // 1234，按整数解析let num2 = parseFloat("0xA"); // 0let num3 = parseFloat("22.5"); // 22.5let num4 = parseFloat("22.34.5"); // 22.34let num5 = parseFloat("0908.5"); // 908.5let num6 = parseFloat("3.125e7"); // 31250000</code></pre><hr><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的：</p><pre><code>    let firstName = "John";    let lastName = 'Jacob';    let lastName = `Jingleheimerschmidt`; </code></pre><h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="left">字 面 量</th><th align="left">含 义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\t</td><td align="left">制表</td></tr><tr><td align="left">\b</td><td align="left">退格</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\f</td><td align="left">换页</td></tr><tr><td align="left">\\</td><td align="left">反斜杠（\）</td></tr><tr><td align="left">\‘</td><td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, 'hey.'‘</td></tr><tr><td align="left">\“</td><td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, "hey."“</td></tr><tr><td align="left">\ `</td><td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td></tr><tr><td align="left">\xnn</td><td align="left">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td align="left">\unnnn</td><td align="left">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符”Σ”</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><pre><code>let text = "This is the letter sigma: \u03a3.";</code></pre><p>在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。</p><p>字符串的长度可以通过其 length 属性获取：</p><pre><code>console.log(text.length); // 28 </code></pre><h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><pre><code>let lang = "Java";lang = lang + "Script"; </code></pre><p>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”</p><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><pre><code>let age = 11;let ageAsString = age.toString(); // 字符串"11"let found = true;let foundAsString = found.toString(); // 字符串"true"</code></pre><p>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。</p><p>默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>String()函数遵循如下规则:</p><p> 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。<br> 如果值是 null，返回”null”。<br> 如果值是 undefined，返回”undefined”。</p><p>下面看几个例子：</p><pre><code>let value1 = 10;let value2 = true;let value3 = null;let value4;console.log(String(value1)); // "10"console.log(String(value2)); // "true"console.log(String(value3)); // "null"console.log(String(value4)); // "undefined" </code></pre><hr><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><pre><code>let myMultiLineString = 'first line\nsecond line';let myMultiLineTemplateLiteral = `first linesecond line`;console.log(myMultiLineString);// first line// second lineconsole.log(myMultiLineTemplateLiteral);// first line // second lineconsole.log(myMultiLineString === myMultiLinetemplateLiteral); // true </code></pre><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><pre><code>        let pageHTML = `        &lt;div&gt;        &lt;a href="#"&gt;        &lt;span&gt;Jake&lt;/span&gt;        &lt;/a&gt;        &lt;/div&gt;`;</code></pre><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><pre><code>// 这个模板字面量在换行符之后有 25 个空格符let myTemplateLiteral = `first line                        second line`;console.log(myTemplateLiteral.length); // 47// 这个模板字面量以一个换行符开头let secondTemplateLiteral = `first linesecond line`;console.log(secondTemplateLiteral[0] === '\n'); // true// 这个模板字面量没有意料之外的字符let thirdTemplateLiteral = `first linesecond line`;console.log(thirdTemplateLiteral);// first line// second line </code></pre><hr><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在${}中使用一个 JavaScript 表达式实现：</p><pre><code>let value = 5;let exponent = 'second';// 以前，字符串插值是这样实现的：let interpolatedString =value + ' to the ' + exponent + ' power is ' + (value * value);// 现在，可以用模板字面量这样实现：let interpolatedTemplateLiteral =`${ value } to the ${ exponent } power is ${ value * value }`;console.log(interpolatedString); // 5 to the second power is 25console.log(interpolatedTemplateLiteral); // 5 to the second power is 25</code></pre><p>嵌套的模板字符串无须转义：</p><pre><code>console.log(`Hello, ${ `World` }!`); // Hello, World! </code></pre><p>将表达式转换为字符串时会调用 toString()：</p><pre><code>let foo = { toString: () =&gt; 'World' };console.log(`Hello, ${ foo }!`); // Hello, World! </code></pre><p>在插值表达式中可以调用函数和方法：</p><pre><code>function capitalize(word) {return `${ word[0].toUpperCase() }${ word.slice(1) }`;}console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!</code></pre><p>此外，模板也可以插入自己之前的值：</p><pre><code>let value = '';function append() {value = `${value}abc`console.log(value);}append(); // abcappend(); // abcabcappend(); // abcabcabc </code></pre><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><pre><code>let o = new Object(); </code></pre><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ol><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。</p></li><li><p>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</p></li><li><p>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 6 章将详细介绍原型。）</p></li><li><p>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</p></li></ol><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。</p><hr><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>挖个坑~QvQ<br>此坑挖于: 2020/11/19<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/85be.html"/>
      <url>posts/85be.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>上篇: <strong><a href="14a5">语言基础(一)语法</a></strong><br>本篇: <strong>语言基础(二)变量</strong><br>下篇: <strong><a href="8a7">语言基础(三)数据类型</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript变量是松散类型的，意思是可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有三个关键字可以声明变量：var、const、let。其中，var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更高版本中使用。</p><hr><h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>要定义变量可以用操作符var，后跟变量名。<br>var message;</p><p>变量可以保存任何类型的值。不初始会保存一个特殊值undefined。</p><hr><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用var操作符定义的变量会成为包含它的函数的局部变量。比如使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过，在函数内部定义变量时省略var操作符，可以创建一个全局变量，只要调用一次函数，可以在函数外部引用: (不推荐这么做:省略var)</p><pre><code>            function test(){                message="hi";   //全局变量            }            test();            console.log(message); </code></pre><hr><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let跟var的作用差不多，但有个明显区别，var声明的范围是函数作用域，而let声明的范围是块作用域</p><pre><code>    if(true){        var name = 'M';        console.log(name); // M    }    console.log(name); // M    if(true){        let age = 'A';        console.log(age); // A    }    console.log(age); // 未定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也试用let</p><p>let也不允许同一个块作用域中出现重复声明</p><pre><code>    var name;    var name;    let age;    let age; //标识符age已经声明过了</code></pre><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><pre><code>    var name;    let name; // 错误    let age;    var age; // 错误 </code></pre><hr><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><pre><code>    var name="M";    console.log(name); // M    console.log(name02); //undefined    var name02="M";     console.log(name02); //报错    let name02="M"; </code></pre><hr><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><pre><code>    var name = 'Matt';    console.log(window.name); // 'Matt'    let age = 26;    console.log(window.age); // undefined </code></pre><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><hr><h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {    // 循环逻辑    }    console.log(i); // 5</code></pre><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    // 循环逻辑    }     console.log(i); // ReferenceError: i 没有定义</code></pre><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {        setTimeout(() =&gt; console.log(i), 0)    }</code></pre><p>// 你可能以为会输出 0、1、2、3、4<br>// 实际上会输出 5、5、5、5、5 </p><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)    }    // 会输出 0、1、2、3、4 </code></pre><hr><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 36; // TypeError: 给常量赋值// const 也不允许重复声明const name = 'Matt';const name = 'Nicholas'; // SyntaxError// const 声明的作用域也是块const name = 'Matt';if (true) {const name = 'Nicholas';}console.log(name); // Matt </code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = {};person.name = 'Matt'; // ok </code></pre><p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p><pre><code>for (const i = 0; i &lt; 10; ++i) {} // TypeError：给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p><pre><code>let i = 0;for (const j = 7; i &lt; 5; ++i) {console.log(j);}// 7, 7, 7, 7, 7for (const key in {a: 1, b: 2}) {console.log(key);}// a, bfor (const value of [1,2,3,4,5]) {console.log(value);}// 1, 2, 3, 4, 5 </code></pre><hr><h3 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h3><ol><li><p>不使用var，限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置以及不变的值。</p></li><li><p>const优先，let次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/14a5.html"/>
      <url>posts/14a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><p>本篇:<strong>语言基础(一)语法</strong><br>下篇:<strong><a href="85be">语言基础(二)变量</a></strong></p><p><strong><a href="/categories/JavaScript/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">JavaScript高级程序设计</a></strong> 全部合集</p><hr><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>首先要知道,<strong>ECMAScript</strong>中一切都区分大小写。无论是<strong>变量</strong>、<strong>函数名</strong>还是<strong>操作符</strong>。换句话说<strong>变量test</strong>和<strong>变量Test</strong>是俩个不同的变量。类似的，<strong>typeof</strong>不能作为函数名，因为它是一个<strong>关键字</strong>。但是<strong>Typeof</strong>是一个完全有效的函数名。</p><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓<strong>标识符</strong>，就是<strong>变量</strong>、<strong>函数</strong>、<strong>属性</strong>或<strong>函数参数</strong>的名称。标识符可以由一或多个下列字符组成：</p><ol><li><p>第一个字符必须是一个<strong>字母</strong>、<strong>下划线</strong>(_)或<strong>美元符号</strong>($);</p></li><li><p>剩下的其他字符可以是<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>或<strong>数字</strong>。</p></li></ol><p>按照惯例，标识符使用<strong>驼峰大小写</strong>形式，即第一个单词首字母小写，后面每个单词的首字母大写。</p><p><strong>注意</strong> 关键字、保留字、true、false和null不能作为标识符。</p><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript采用C语言风格的注释，包括单行注释和块注释。</p><p>单行注释以俩个斜杠字符开头， // 单行注释</p><p>块注释以一个斜杠和一个星号开头，以它们的反向组合结尾， /* 块注释 */</p><hr><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript5增加了严格模式的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><p><code>"use strict"</code></p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p><pre><code>        function doSomething(){            "use strict";            //函数体        }</code></pre><p>所有现代浏览器都支持严格模式</p><hr><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMASCript中语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><pre><code>        let sum = a + b   //没有分号也有效，但不推荐        let diff = a - b; //加分号有效，推荐</code></pre><p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号({)开始，右花括号(})结束。</p><p>if之类的控制语句只在执行多条语句要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即便只有一条语句。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> JavaScript高级程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="posts/c06f.html"/>
      <url>posts/c06f.html</url>
      
        <content type="html"><![CDATA[<p>网址在这里:</p><p>版本0.5:<br><a href="https://yanyanzio.top/Project/One/YYZMusic">https://yanyanzio.top/Project/One/YYZMusic</a></p><p>要源码可以联系我,有QQ</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗忘的HTML&amp;&amp;CSS</title>
      <link href="posts/e31c.html"/>
      <url>posts/e31c.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS溢出属性-overflow"><a href="#CSS溢出属性-overflow" class="headerlink" title="CSS溢出属性 overflow"></a>CSS溢出属性 overflow</h3><p>该overflow属性指定如果内容溢出元素框会发生什么情况。</p><p>此属性指定在元素的内容太大而无法放入指定区域时是剪辑内容还是添加滚动条。</p><p>/* 默认值。内容不会被修剪，会呈现在元素框之外 */<br>overflow: visible;</p><p>/* 内容会被修剪，并且其余内容不可见 */<br>overflow: hidden;</p><p>/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */<br>overflow: scroll;</p><p>/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */<br>overflow: auto;</p><p>/* 规定从父元素继承overflow属性的值 */<br>overflow: inherit;</p><hr><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。 </p><p>border 和 outline<br>border 和 outline 很类似，但有如下区别：</p><p>outline不占据空间，绘制于元素内容周围。<br>根据规范，outline通常是矩形，但也可以是非矩形的。</p><p>&lt;’outline-color’&gt;<br>设置轮廓的颜色。没有设置时默认值为 currentcolor。<br>&lt;’outline-style’&gt;<br>设置轮廓的样式。没有设置时默认值为 none。<br>&lt;’outline-width’&gt;<br>设置轮廓的宽度。没有设置时默认值为 medium</p><p>outline:none; 取消选中边框</p><hr><h3 id="选择器-交集选择器"><a href="#选择器-交集选择器" class="headerlink" title="选择器: 交集选择器"></a>选择器: 交集选择器</h3><p>我主要用在绑定一个标签, 如: .Old.Xin  有一个源 <code>&lt;div class="Old"&gt;&lt;/div&gt;</code></p><p>想要在这个<strong>div</strong>中添加一个新的类,即<code>&lt;div class="Old Xin"&gt;&lt;/div&gt;</code></p><p>就用 <strong>.Old.Xin</strong> 交集选择器</p><hr><h3 id="webkit-scrollbar-滚轮样式"><a href="#webkit-scrollbar-滚轮样式" class="headerlink" title="::-webkit-scrollbar 滚轮样式"></a>::-webkit-scrollbar 滚轮样式</h3><p>::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样</p><p>::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分</p><hr><h3 id="img的边框"><a href="#img的边框" class="headerlink" title="img的边框"></a>img的边框</h3><ol><li><code>&lt;img&gt;</code> 标签的 border 属性规定图像周围的边框的宽度</li></ol><p><code>border: none;</code> // css属性</p><ol start="2"><li><p>当img没有接收到src属性的时候会自动出现边框，border:0/none都不管用的情况下，解决方法：</p><pre><code> img[src=""],img:not([src]){     opacity:0; }</code></pre></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="posts/e0b8.html"/>
      <url>posts/e0b8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js是一套构建用户界面的渐进式框架</p><p>Vue.js 只关注视图层， 设计时采用自底向上渐进式开发的构架，核心部件只关注用户界面的构建</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p><p><strong>注意</strong>： Vue.js 不支持 IE8 及其以下 IE 版本</p><h3 id="为什么要使用Vue"><a href="#为什么要使用Vue" class="headerlink" title="为什么要使用Vue"></a>为什么要使用Vue</h3><p>1.轻量级,体积小是一个重要指标,Vue.Js压缩后只有20多KB<br>2.移动优先,更适合移动端,比如移动端的Touch事件<br>3.易上手,学习曲线平稳,文档齐全<br>4.吸收了Angular(模块化)和React(虚拟DOM的长处),并拥有自己独特的功能<br>5.开源,社区活跃度高<br>…</p><h3 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h3><p>在我们继续学习 Vue.js 2 之前，希望对以下知识有一定的了解<br><strong>HTML</strong><br><strong>CSS</strong><br><strong>JavaScript</strong></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><strong>Vue.js</strong> 是一个 <strong>JavaScript</strong> 脚本库，所以安装起来非常简单，只要引用 <strong>vue.min.js</strong> 脚本就可以了</p><p>可以在 Vue.js 的官网上直接下载 vue.min.js 然后使用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li><p><strong>安装 cnpm</strong><br><code>npm install --global cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p><strong>全局安装 vue-cli</strong><br><code>$ cnpm install --global vue-cli</code></p></li><li><p><strong>创建一个基于 webpack 模板的新项目</strong><br><code>$ vue init webpack yyzvue</code></p></li><li><p>这里需要你进行一些配置，如果不想更改，可以直接回车</p></li></ol><p><code>$ vue init webpack yyzvue</code>  </p><p><code>? Project name yyzvue</code><br><code>? Project description A Vue.js project</code><br><code>? Author sense &lt;yu.fei@gmail.com&gt;</code><br><code>? Vue build standalone</code><br><code>? Install vue-router? Yes</code><br><code>? Use ESLint to lint your code? Yes</code><br><code>? Pick an ESLint preset Standard</code><br><code>? Set up unit tests Yes</code><br><code>? Pick a test runner jest</code><br><code>? Setup e2e tests with Nightwatch? Yes</code></p><p>   <code>vue-cli · Generated "webapp".</code></p><p>   <code>To get started:</code><br>     <code>cd webapp</code><br>     <code>npm install</code><br>     <code>npm run dev</code><br>   <code>Documentation can be found at https://vuejs-templates.github.io/webpack</code></p><ol start="3"><li>安装依赖并运行<br>配置配置完成后，可以进入项目，然后执行以下命令</li></ol><p><code>$ cd webapp</code><br><code>$ cnpm install</code><br>先去喝杯茶，然后调戏小孩，再回来看看是否安装好了…</p><p><code>$ npm run dev</code></p><p> <code>DONE  Compiled successfully in </code></p><p> <code>I  Your application is running here: http://localhost:8080</code></p><p> 成功执行以上命令后访问 <a href="http://localhost:8080/%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">http://localhost:8080/，输出结果如下所示</a></p><p> <img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_1.png"></p><hr><h2 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h2><p>上一章节中，我们使用 vue-cli 工具创建了一个 webapp 的项目</p><p>如果我们使用 IDE（Eclipse、Atom）打开该目录，显示目录结构如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_2.png"></p><h3 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h3><table><thead><tr><th align="left">目录/文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">build</td><td align="left">最终发布的代码存放位置</td></tr><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的</td></tr><tr><td align="left">node_modules</td><td align="left">npm 加载的项目依赖模块</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里里面包含了几个目录及文件assets: 放置一些图片，如logo等components: 目录里面放了一个组件文件，可以不用App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录main.js: 项目的核心文件</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">.xxxx文件</td><td align="left">这些是一些配置文件，包括语法配置，git配置等</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或同统计代码啥的</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><h3 id="用vue写一个hello-word"><a href="#用vue写一个hello-word" class="headerlink" title="用vue写一个hello word"></a>用vue写一个hello word</h3><p>代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id="app"&gt;        {{message}}    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_3.png"></p><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>&lt;div id="app_01"&gt;    {{mes+'!'}}    &lt;h2 v-text="mes+'!'"&gt;iii&lt;/h2&gt;    &lt;h2&gt;hah{{mes}}iii&lt;/h2&gt;&lt;/div&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>    &lt;div id="app_01"&gt;    &lt;span v-text="mes"&gt;&lt;/span&gt;    &lt;span v-html="mes"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm= new Vue({        el: '#app_01' ,        data:{            mes: '&lt;p style="color:red;font-size:30px;"&gt;言言子&lt;/p&gt;'        }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>设置元素属性值,如: v-bind:src=”imgSrc”,v-bind:title=”arcTit”<br>其中 v-bind 可以省略</p><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-bind:title="message"&gt;HHHHH&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>当把鼠标放到<strong>HHHHH</strong>上时,鼠标下会有个标记</p><p>你看到的 <strong>v-bind</strong> 等被称为标记,指令带有前缀<strong>v-</strong>,以示他们是<strong>Vue</strong>提供的特殊特性</p><p>他们会在渲染的<strong>DOM</strong>上应用特殊的响应式行为。在这里,指令的意思为：将这个元素节点的<strong>title</strong></p><p>特性和<strong>Vue</strong>实例的<strong>message</strong>属性保持一致。</p><p>如果打开浏览器的控制台，输入<code>vue.message="哦哦哦哦哦"</code>,就会看到绑定了<strong>title</strong>特性的HTML</p><p>已经进行了更新</p><h3 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h3><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok"&gt;YES&lt;/span&gt;        &lt;span v-else&gt;NONONO&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: true            }        } );    &lt;/script&gt;&lt;/body&gt;&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok==='A'"&gt;这是A&lt;/span&gt;        &lt;span v-else-if="ok==='B'"&gt;这是B&lt;/span&gt;        &lt;span v-else&gt;啥也不是&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: 'A'            }        } );    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>&lt;div id="app"&gt;        &lt;p v-for="item in items"&gt;            {{item.message}}        &lt;/p&gt;&lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: "#app",            data: {                items: [                    {message: '言言子好可爱!'},                    {message: '言言子好萌!'}                ]            }        });    &lt;/script&gt;</code></pre><p>在控制台里，输入 vm.items.push({ message: ‘芜湖！好耶！’ })，你会发现列表最后添加了一个新项目</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><pre><code>&lt;div id="app_01"&gt;    &lt;p @click="func"&gt;{{message}}&lt;/p&gt;    &lt;input type="button" value="事件绑定-点击" v-on:click="func"&gt;    &lt;input type="button" value="事件绑定-点击" @click="func"&gt;    &lt;input type="button" value="事件绑定-" v-on:monseenter="func"&gt;    &lt;input type="button" value="事件绑定-双击" v-on:dblclick="func"&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app_01",            data: {                message: "ABC"            },            methods: {                func() {                    this.message = this.message.split('').reverse().join('');                }            }    }); &lt;/script&gt;</code></pre><p><strong>split() 方法用于把一个字符串分割成字符串数组</strong><br><strong>reverse() 方法用于颠倒数组中元素的顺序</strong><br><strong>join() 方法用于把数组中的所有元素放入一个字符串</strong></p><p>注意在 <strong>reverseMessage</strong> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><h3 id="用Vue做简单计数器"><a href="#用Vue做简单计数器" class="headerlink" title="用Vue做简单计数器"></a>用Vue做简单计数器</h3><pre><code>    &lt;div id="app"&gt;    &lt;button @click="add"&gt;+&lt;/button&gt;    &lt;span&gt;{{num}}&lt;/span&gt;    &lt;button @click="jian"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app",            data: {                num: 0            },            methods: {                add(){                    if(this.num&lt;10){                        this.num+=1;                    }else{                        alert("最大为10!");                    }                },                jian(){                    if(this.num&gt;0){                        this.num-=1;                    }else{                        alert("最小为0!");                    }                }            }    });&lt;/script&gt;</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达式的真假切换元素的显示和隐藏</p><pre><code>&lt;div id="app"&gt;    &lt;button @click="q"&gt;点击隐藏图片&lt;/button&gt;    &lt;img src="./1.jpg" v-show="isShow"&gt;    &lt;img src="./1.jpg" v-if="isShow"&gt;    &lt;img src="./1.jpg" v-show="age&gt;20"&gt;&lt;/div&gt;&lt;script&gt;    var vm =new Vue({        el: "#app",    data: {            isShow: true,            age: 18    },    methods: {            q(){                this.isShow= !this.isShow;            }    }    });&lt;/script&gt;</code></pre><p>频繁切换的元素用 <strong>v-show</strong>,反之用 <strong>v-if</strong></p><p>因为操作DOM数对性能的消耗比较大(<strong>v-if</strong>)</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue 还提供了 <strong>v-model</strong> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><pre><code>&lt;div id="app-6"&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单</p><pre><code>&lt;div class="app"&gt;    &lt;yan&gt;&lt;/yan&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个Vue组件    Vue.component('yan',{        template: '&lt;p&gt;言言子努力加油&lt;/p&gt;'    })     var vm= new Vue({         el: "#app"     }); &lt;/script&gt;</code></pre><h3 id="用Vue切换图片"><a href="#用Vue切换图片" class="headerlink" title="用Vue切换图片"></a>用Vue切换图片</h3><pre><code>&lt;div id="app"&gt;    &lt;div&gt;            &lt;img :src="img[index]" alt=""&gt;            &lt;a href="##" @click="sub" v-show="index!=0"&gt;&lt;&lt;/a&gt;            &lt;a href="##" @click="add" v-show="index&lt;img.length-1"&gt;&gt;&lt;/a&gt;        &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: '#app',        data:{                img: ['./1.jpg','./2.jpg','./3.png'],                index: 0        },        methods:{            add(){                    this.index++;            },            sub(){                    this.index--;            }        }    });&lt;/script&gt;</code></pre><h3 id="用Vue做一个记录本功能"><a href="#用Vue做一个记录本功能" class="headerlink" title="用Vue做一个记录本功能"></a>用Vue做一个记录本功能</h3><pre><code>&lt;div id="app"&gt;    &lt;header&gt;        &lt;h1&gt;记事本&lt;/h1&gt;        &lt;input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;ul&gt;            &lt;li v-for="(item,index) in arr"&gt;                &lt;div&gt;                    &lt;span&gt;{{index+1}}.&lt;/span&gt;                    &lt;label&gt;{{item}}&lt;/label&gt;                    &lt;button @click="sub(index)"&gt;&lt;/button&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;footer v-show="arr.length!=0" &gt;        &lt;span&gt;            &lt;strong  &gt;{{arr.length}}&lt;/strong&gt;        &lt;/span&gt;        &lt;button @click="clear"&gt;Clear&lt;/button&gt;    &lt;/footer&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: "#app",        data: {            arr: [                "ABC",                "QWE",                "ZXC"            ],            inputValue: ""        },        methods: {            add(){                this.arr.push(this.inputValue);            },            sub(index){                this.arr.splice(index,1);            },            clear(){                this.arr= []            }        }    });&lt;/script&gt;</code></pre><hr><h2 id="AXIOS的基本使用-实例"><a href="#AXIOS的基本使用-实例" class="headerlink" title="AXIOS的基本使用(实例)"></a>AXIOS的基本使用(实例)</h2><pre><code>&lt;input type="button"  id="get" value="get请求"&gt;&lt;input type="button" id="post" value="post请求"&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script&gt;    document.querySelector("#get").onclick= function(){        axios.get("https://autumnfish.cn/api/joke/listsadsad?num=1")        .then(function (response){            console.log(response);        },function(err){            console.log(err);        })    }    document.querySelector("#post").onclick=function(){        axios.post("https://autumnfish.cn/api/user/reg",        {username: "言言子"})        .then(function(re){            console.log(re);        },function(err){            console.log(err);        })    }&lt;/script&gt;</code></pre><h3 id="AXIOS-Vue-获取笑话"><a href="#AXIOS-Vue-获取笑话" class="headerlink" title="AXIOS+Vue:获取笑话"></a>AXIOS+Vue:获取笑话</h3><pre><code>&lt;div id="app"&gt;    &lt;input type="button" value="获取笑话" @click="getJoke"&gt;    &lt;p&gt;{{Joke}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm=new Vue({        el: "#app",        data: {            Joke: ""        },        methods: {            getJoke(){                var that= this;                axios.get("https://autumnfish.cn/api/joke")                .then(function(resq){                                            that.Joke= resq.data;                })            }        }    });&lt;/script&gt;</code></pre><h3 id="网络应用-天气查询"><a href="#网络应用-天气查询" class="headerlink" title="网络应用:天气查询"></a>网络应用:天气查询</h3><pre><code>HTML&lt;div id="app"&gt;        &lt;div&gt;            &lt;p&gt;天知道&lt;/p&gt;            &lt;div&gt;                &lt;input type="text" placeholder="请输入查询天气"                 @keyup.enter="searchTQ" v-model="city"&gt;                &lt;input type="button" value="搜索"&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;a href="##" @click="changeCity('北京')"&gt;北京&lt;/a&gt;                &lt;a href="##" @click="changeCity('上海')"&gt;上海&lt;/a&gt;                &lt;a href="##" @click="changeCity('广州')"&gt;广州&lt;/a&gt;                &lt;a href="##" @click="changeCity('深圳')"&gt;深圳&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li v-for="item in weatherList"&gt;                &lt;div&gt;{{item.date}}&lt;/div&gt;                &lt;span&gt;{{item.low}} ~ {{item.high}}&lt;/span&gt;                &lt;span&gt;{{item.type}}&lt;/span&gt;                &lt;span&gt;{{item.fengxiang}}&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;     &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;     JS    window.onload=function(){        var vm=new Vue({            el: "#app",            data: {                city: "",                weatherList: []            },            methods: {                searchTQ(){                    var that=this;                    axios.get("http://wthrcdn.etouch.cn/weather_mini?city="                    +this.city).then(function(resq){                        that.weatherList=resq.data.data.forecast;                    },function(err){                        alert(err);                    })                },                changeCity(city){                    this.city=city;                    this.searchTQ();                }            }        });    };</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/f7d3.html"/>
      <url>posts/f7d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id="Canvas-平移-translate"><a href="#Canvas-平移-translate" class="headerlink" title="Canvas 平移 translate()"></a>Canvas 平移 translate()</h2><p>平移 (translate) 就是将一个图形往水平方向和垂直方向移动一定的距离 <strong>(dx,dy)</strong></p><p>但是，Canvas 中的所有几何变换针对的不是绘制的图形，而是针对画布本身</p><p>例如刚开始的时候在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_42.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>translate(50,50)</strong> 将画布水平和垂直方向各移动 50</p><p>然后在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_43.png"></p><p>此时矩形的起点距离屏幕左上角就已经是 <strong>(100,100)</strong> 了</p><p><strong>语法</strong><br><code>void ctx.translate(dx, dy);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的移动距离</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的移动距离</td></tr></tbody></table><p>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后平移 canvas (50,50) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.translate(50,50);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_44.png"></p><hr><h2 id="Canvas-缩放-scale"><a href="#Canvas-缩放-scale" class="headerlink" title="Canvas 缩放 scale()"></a>Canvas 缩放 scale()</h2><p>缩放 (scale) 就是将一个图形围绕中心点，然后将宽和高分别乘以一定的因子(sx,sy)</p><p>但是，Canvas 中的缩放 (scale) 针对的不是绘制的图形，而是针对画布本身</p><p>画布缩放了，那么画在画布上的图形自然也就缩放了</p><p>例如刚开始的时候在 <strong>(100,100)</strong> 绘制一个 <strong>25x25</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_45.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>scale(0.5,2)</strong> 将画布水平方向缩小一倍和垂直方向放大一倍的时候</p><p>这是什么意思呢？</p><p>就是原来水平方向的 1 个单位现在变成了 0.5 个单位了，垂直方向的 1 个单位现在变成了 2 个单位了</p><p>然后在 <strong>(100,100)</strong> 绘制一个 <strong>5x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_46.png"></p><p><strong>ctx.scale()</strong> 将 <strong>canvas</strong> 水平方向和垂直方向的单位各乘以一定的因子(sx,sy)</p><p>从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离</p><p><strong>语法</strong><br><code>void ctx.scale(sx, sy)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的缩放因子</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的缩放因子</td></tr></tbody></table><p>dx 和 dy 的值可以是负数，负数是啥意思呢？就是想把整个 canvas 翻转，然后再缩放</p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后缩放画布 canvas <strong>(0.5,2)</strong> 最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_47.png"></p><p>如果缩放因子是负数，那么先镜像 (也就是先翻转)，然后再缩放</p><p>如果 sx 是负数，则先按照 Y 轴镜像，然后再缩放<br>如果 sy 是负数，则先按照 X 轴镜像，然后再缩放<br>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后缩放画布 canvas (-0.5,2) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_48.png"></p><p>哎呀，为什么绿色的没掉了呢？因为，因为垂直镜像了之后，x 轴正方向已经从水平向左改成水平向右了</p><p>如果此时还在 <strong>(50,50)</strong> 的位置画画，肯定是看不到啊，因为它已经跑到另一边去了，而屏幕的位置没变啊，于是就看不到了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_49.png"><br>绿色边框是我们的屏幕显示范围</p><p>如果此时还要看到它，就要把绘制起始点的 x 坐标也翻转下，然后再 x 2 就是变成 (-50)x2=-100 就好了</p><p>如果不 x 2 ，结果还是看不到的，因为 -50 也只是把矩形往右移动了 50 像素，到哪里了？ 贴边了…</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-3");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(-100,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_50.png"></p><hr><h2 id="Canvas-旋转-rotate"><a href="#Canvas-旋转-rotate" class="headerlink" title="Canvas 旋转 rotate()"></a>Canvas 旋转 rotate()</h2><p>旋转 ( rotate ) 就是将图形围绕一个中心点(0,0)，顺时针或者逆时针旋转一定的弧度 ( angle )</p><p>但是，Canvas 中的旋转 ( rotate ) 针对的不是绘制的图形，而是针对画布本身</p><p>画布旋转了，带来最直接的结果是什么呢？ 就是某个点与屏幕上边之间的夹角改变了</p><p>我们看一个正常情况下的笛卡尔坐标体系，某个点(50,50) 与屏幕上边和 X 轴正方向之间的夹角都是 45 度</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_51.png"></p><p><strong>绿色</strong> 的是屏幕</p><p><strong>灰色</strong> 的是画布</p><p>当我们画布顺时针旋转 30 度后，就变成了下图这样了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_52.png"></p><p>点还是那个点，点与画布之间的夹角还是 <strong>45°</strong>，但点与屏幕间的夹角已经变成了 <strong>75°</strong></p><p>最直观的感受是啥？ 就是点往左下移了那么一点点，我们去掉各种辅助线，大家看看</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_53.png"></p><p>一个点已经是这样了，如果我们画的是一个图形，那么图形上的所有点都移动了，那么直观看起来，就是图形旋转了</p><p><strong>语法</strong><br><code>void ctx.rotate(angle);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">angle</td><td align="left">顺时针旋转的弧度。可以通过角度值计算：degree * Math.PI / 180</td></tr></tbody></table><p><strong>弧度 angle</strong><br>我们特别说明下 <strong>angle</strong> 这个参数，它是一个弧度</p><p>如果我们要顺时针旋转<strong>30°</strong>，那么</p><p><code>angle = 30 * Math.PI / 180</code><br>如果想要逆时针旋转 <strong>30°</strong> 怎么办呢？逆时针旋转 30°，其实就是顺时针旋转 -30°，也就是</p><p><code>angle = 360 + ( -30 * Math.PI / 180 )</code></p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后顺时针旋转画布 <strong>30°</strong></p><p>最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.rotate(30 * Math.PI / 180);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_54.png"></p><p>我们利用多次旋转画一个折扇图</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var colors = ['#D0021B','#F5A623','#8B572A','#417505','#9013FE','#000000']for ( var i = 0; i &lt; colors.length; i++ ){    ctx.fillStyle = colors[i];    ctx.fillRect(0,0,200,50);    ctx.rotate(15 * Math.PI / 180);}&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_55.png"></p><hr><h2 id="Canvas-橡皮擦-clearRect"><a href="#Canvas-橡皮擦-clearRect" class="headerlink" title="Canvas 橡皮擦 clearRect()"></a>Canvas 橡皮擦 clearRect()</h2><p><strong>ctx.clearRect()</strong> 方法设置指定矩形区域内（以点 (x, y) 为起点，范围是 (width, height) ）所有像素变成透明，并擦除之前绘制的所有内容</p><p><strong>语法</strong><br><code>void ctx.clearRect(x, y, width, height);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">矩形起点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">矩形起点的 y 轴坐标</td></tr><tr><td align="left">width</td><td align="left">矩形的宽度</td></tr><tr><td align="left">height</td><td align="left">矩形的高度</td></tr></tbody></table><p>我们先从 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形，然后再使用 clearRect() 擦出这个矩形的 1/4</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);ctx.clearRect(50,50,200/2,50/2);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_56.png"></p><hr><h2 id="Canvas-绘图上下文-save"><a href="#Canvas-绘图上下文-save" class="headerlink" title="Canvas 绘图上下文 save()"></a>Canvas 绘图上下文 save()</h2><p>Canvas 为我们提供了 图层(Layer) 的支持，Layer(图层) 是按 “栈结构” 来进行管理的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_57.png"></p><p>当我们调用<strong>save()</strong> 方法，会保存当前 Canvas 的状态然后作为一个 Layer(图层)，添加到 Canvas栈 中，</p><p>而当我们调用 <strong>restore()</strong> 方法的时候，会恢复之前 Canvas 的状态，而此时 Canvas 的图层栈 会弹出栈顶的那个 Layer，后继的 Layer 来到栈顶，此时的 Canvas 回复到此栈顶时保存的 Canvas 状态</p><p>简单说就是 <strong>save() 往栈压入一个 Layer，restore()弹出栈顶的一个Layer，这个 Layer 代表Canvas的 状态</strong>！</p><p>也就是说可以 <strong>save()</strong> 多次，也可以 <strong>restore()</strong> 多次，但是 <strong>restore()</strong> 的调用次数 不能大于 <strong>save()</strong> 否则会引发错误</p><p><code>ctx.save()</code> 方法用于将画布的当前状态保存到栈中</p><p>下面的代码使用 save() 方法保存默认的状态，然后平移 (100,100) 绘制一个绿色矩形后，恢复之前的状态，最后再使用默认的设置绘制一个矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.save();ctx.translate(100,100);ctx.fillStyle = "green"ctx.fillRect(50,50,100,50);ctx.restore();ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_58.png"></p><hr><h2 id="Canvas-恢复画板状态-restore"><a href="#Canvas-恢复画板状态-restore" class="headerlink" title="Canvas 恢复画板状态 restore()"></a>Canvas 恢复画板状态 restore()</h2><p><code>ctx.restore()</code> 方法用于将画布恢复到最近一次的保存状态</p><p>如果没有保存状态，此方法不做任何改变</p><hr><h2 id="Canvas-图像混排模式"><a href="#Canvas-图像混排模式" class="headerlink" title="Canvas 图像混排模式"></a>Canvas 图像混排模式</h2><p>首先绘制一个蓝色的矩形，然后绘制一个红色矩形和它重叠，看看不同的图形混排模式带来的效果</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_59.png"></p><p><strong>所有代码如下</strong></p><pre><code>&lt;canvas id="canvas-1" width="500" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var gco = [ 'source-over','source-in','source-out','source-atop',            'destination-over','destination-in','destination-out','destination-atop',            'lighter', 'copy','xor', 'multiply', 'screen', 'overlay', 'darken',            'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'        ];var canvas = document.getElementById("canvas-1");canvas.width = 500;canvas.height = 2700;var ctx = canvas.getContext("2d");function draw(){    for (var i = 0; i &lt; gco.length; i++ )    {        ctx.font = "16px Microsoft YaHei"        ctx.textBaseline = "middle";        ctx.fillStyle="#333"        ctx.save();        ctx.fillText(gco[i],10,15);        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.translate(70,0)        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.fillStyle = "red";        ctx.fillRect(25, 50, 50, 50);        var canvas2 = document.createElement("canvas");        ctx2 = canvas2.getContext("2d");        ctx2.fillStyle = "blue";        ctx2.fillRect(10, 35, 50, 50);        ctx2.globalCompositeOperation = gco[i];        ctx2.fillStyle = "red";        ctx2.fillRect(25, 50, 50, 50);        ctx2.globalCompositeOperation = "source-over";        ctx.drawImage(canvas2,85,0);        ctx.restore();        ctx.translate(0,100);    }}draw();&lt;/script&gt;</code></pre><hr><h2 id="Canvas-图像裁剪"><a href="#Canvas-图像裁剪" class="headerlink" title="Canvas 图像裁剪"></a>Canvas 图像裁剪</h2><p>裁剪用于隐藏部分我们不想看到的图形</p><p>Canvas 中的裁剪和 Photoshop 中的裁剪不一样，Photoshop 中的裁剪针对的是图形，而 Canvas 中的裁剪针对的是画布本身</p><p>Canvas 中的裁剪只有一种方法，就是根据路径来裁剪</p><p>比如我们有一个画布，画布上有一张图片和一个五角星的路径</p><p><strong>语法</strong><br><code>void ctx.clip();</code><br><code>void ctx.clip(fillRule);</code><br><code>void ctx.clip(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">裁剪算法，用于设置判断一个点是在路径内还是在路径外，可选的值有</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕原则，默认的原则</td></tr><tr><td align="left">“evenodd”: 奇偶环绕原则</td><td align="left"></td></tr><tr><td align="left">path</td><td align="left">需要剪切的 Path2D 路径</td></tr></tbody></table><p>先画一个路径，然后调用 clip() 说我要裁剪接下来的图形，而且终身有效</p><p>如果不需要了，那么可以在调用 clip() 前先调用 save() 保存状态，然后再使用完后调用 </p><p>restore() 恢复状态</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c2   = document.getElementById("canvas-2");var ctx2 = c2.getContext("2d");ctx2.save();ctx2.arc(100, 100, 75, 0, Math.PI*2, false);ctx2.clip();ctx2.fillRect(0, 0, 100,100);ctx2.fillStyle="green";ctx2.fillRect(100, 100, 100,100);ctx2.restore();ctx2.fillStyle="red";ctx2.fillRect(40, 40, 30,30);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_60.png"></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
