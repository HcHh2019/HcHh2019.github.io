<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/85b1.html"/>
      <url>posts/85b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><hr><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><hr><h3 id="作用域链增强"><a href="#作用域链增强" class="headerlink" title="作用域链增强"></a>作用域链增强</h3><hr><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(二)</title>
      <link href="posts/44e8.html"/>
      <url>posts/44e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量、作用域与内存"><a href="#变量、作用域与内存" class="headerlink" title="变量、作用域与内存"></a>变量、作用域与内存</h1><hr><h2 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h2><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（byvalue）访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。</p><hr><h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。比如，看下面的例子：</p><pre><code>let person = new Object();person.name = "Nicholas";console.log(person.name); // "Nicholas" </code></pre><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：</p><pre><code>let name = "Nicholas";name.age = 27;console.log(name.age); // undefined </code></pre><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p><pre><code>let name1 = "Nicholas";let name2 = new String("Matt");name1.age = 27;name2.age = 26;console.log(name1.age); // undefinedconsole.log(name2.age); // 26console.log(typeof name1); // stringconsole.log(typeof name2); // object </code></pre><hr><h3 id="复制值"><a href="#复制值" class="headerlink" title="复制值"></a>复制值</h3><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。请看下面的例子：</p><pre><code>let num1 = 5;let num2 = num1;</code></pre><p>这里，num1 包含数值 5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在num1 中的 5 是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p><pre><code>let obj1 = new Object();let obj2 = obj1;obj1.name = "Nicholas";console.log(obj2.name); // "Nicholas" </code></pre><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><p>在按值传递参数时，值会被复制到一个局部变量在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部</p><pre><code>function addTen(num) {    num += 10;    return num;}let count = 20; let result = addTen(count);console.log(count); // 20，没有变化console.log(result); // 30 function setName(obj) {    obj.name = "Nicholas";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p><pre><code>function setName(obj) {    obj.name = "Nicholas";    obj = new Object();    obj.name = "Greg";}let person = new Object();setName(person);console.log(person.name); // "Nicholas" </code></pre><p>这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p><p><strong>注意</strong> ECMAScript 中函数的参数就是局部变量</p><hr><h3 id="确定类型-instanceof"><a href="#确定类型-instanceof" class="headerlink" title="确定类型 instanceof"></a>确定类型 instanceof</h3><p>前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null，那么 typeof返”object”，如下面的例子所示：</p><pre><code>let s = "Nicholas";let b = true;let i = 22;let u;let n = null;let o = new Object();console.log(typeof s); // stringconsole.log(typeof i); // numberconsole.log(typeof b); // booleanconsole.log(typeof u); // undefinedconsole.log(typeof n); // objectconsole.log(typeof o); // object </code></pre><p>typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 instanceof 操作符，语法如下：</p><p><code>result = variable instanceof constructor</code></p><p>如果变量是给定引用类型的实例，则 instanceof 操作符返回 true。来看下面的例子：</p><pre><code>console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><p>按照定义，所有引用值都是 Object 的实例，因此通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true。类似地，如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象。</p><p><strong>注意</strong></p><p>typeof 操作符在用于检测函数时也会返回”function”</p><p>typeof 对正则表达式也返回”function”，在 IE 和 Firefox 中，typeof 对正则表达式返回”object”</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a1.html"/>
      <url>posts/8a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><hr><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>太简单了…我可以不说嘛…<br>凡是学过一门语言的都应该知道叭！</p><hr><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 let 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。初始化、条件表达式和循环后表达式都不是必需的。因此，下面这种写法可以创建一个无穷循环：</p><pre><code>for (;;) { // 无穷循环doSomething();} </code></pre><hr><h3 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a>for-in 语句</h3><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><pre><code>for (property in expression) statement</code></pre><p>下面是一个例子：</p><pre><code>for (const propName in window) {document.write(propName);} </code></pre><p>这个例子使用 for-in 循环显示了 BOM 对象 window 的所有属性。每次执行循环，都会给变量propName 赋予一个 window 对象的属性作为值，直到 window 的所有属性都被枚举一遍。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。</p><p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。</p><hr><h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for-of 语句"></a>for-of 语句</h3><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><pre><code>for (property of expression) statement</code></pre><p>下面是示例：</p><pre><code>for (const el of [2,4,6,8]) {document.write(el);} </code></pre><p>在这个例子中，我们使用 for-of 语句显示了一个包含 4 个元素的数组中的所有元素。循环会一直持续到将所有元素都迭代完。与 for 循环一样，这里控制语句中的 const 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 const</p><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素。如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误</p><hr><h3 id="标签语句"><a href="#标签语句" class="headerlink" title="标签语句"></a>标签语句</h3><p>标签语句用于给语句加标签，语法如下：</p><pre><code>label: statement</code></pre><p>下面是一个例子：</p><pre><code>start: for (let i = 0; i &lt; count; i++) {console.log(i);}</code></pre><p>在这个例子中，start 是一个标签，可以在后面通过 break 或 continue 语句引用。标签语句的典型应用场景是嵌套循环。</p><hr><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {        if (i == 5 &amp;&amp; j == 5) {            break outermost;        }    num++;    }}console.log(num); // 55</code></pre><p>在这个例子中，outermost 标签标识的是第一个 for 语句。正常情况下，每个循环执行 10 次，意味着 num++语句会执行 100 次，而循环结束时 console.log 的结果应该是 100。但是，break 语带来了一个变数，即要退出到的标签。添加标签不仅让 break 退出（使用变量 j 的）内部循环，也会退出（使用变量 i 的）外部循环。当执行到 i 和 j 都等于 5 时，循环停止执行，此时 num 的值是55。</p><p>continue语句也可以使用标签，如下面的例子所示：</p><pre><code>let num = 0;outermost:for (let i = 0; i &lt; 10; i++) {    for (let j = 0; j &lt; 10; j++) {     if (i == 5 &amp;&amp; j == 5) {       continue outermost;    }    num++;    }}console.log(num); // 95 </code></pre><p>这一次，continue 语句会强制循环继续执行，但不是继续执行内部循环，而是继续执行外部循环。当 i 和 j 都等于 5 时，会执行 continue，跳到外部循环继续执行，从而导致内部循环少执行 5 次结果 num 等于 95。</p><p>组合使用标签语句和 break、continue 能实现复杂的逻辑，但也容易出错。注意标签要使用描述性强的文本，而嵌套也不要太深。</p><hr><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>with 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><pre><code>with (expression) statement;</code></pre><p>使用 with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如下面的例子所示：</p><pre><code>let qs = location.search.substring(1);let hostName = location.hostname;let url = location.href;</code></pre><p>上面代码中的每一行都用到了 location 对象。如果使用 with 语句，就可以少写一些代码：</p><pre><code>with(location) {let qs = search.substring(1);let hostName = hostname;let url = href;} </code></pre><p>这里，with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如果有，则该变量会被求值为 location 对象的属性。</p><p>严格模式不允许使用 with 语句，否则会抛出错误。</p><p><strong>警告</strong> 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p><hr><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>虽然 switch 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch 语句可以用于所有数据类型（在很多语言中，它只能用于数值），因此可以使用字符串甚至象。其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：</p><pre><code>switch ("hello world") {    case "hello" + " world":        console.log("Greeting was found.");        break;    case "goodbye":        console.log("Closing was found.");        break;    default:        console.log("Unexpected message was found.");} </code></pre><p>注意 switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型（比如，字符串”10”不等于数值 10）。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值。比如：</p><pre><code>function sum(num1, num2) {return num1 + num2;}</code></pre><p>要注意的是，只要碰到 return 语句，函数就会立即停止执行并退出。因此，return 语句后面的代码不会被执行。 </p><p>严格模式对函数也有一些限制：</p><ol><li><p>函数不能以 eval 或 arguments 作为名称；</p></li><li><p>函数的参数不能叫 eval 或 arguments；</p></li><li><p>两个命名参数不能拥有同一个名称。</p></li></ol><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/873e.html"/>
      <url>posts/873e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等</p><hr><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。</p><hr><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只操作一个值的操作符叫一元操作符。</p><h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="headerlink" title="递增/递减操作符"></a>递增/递减操作符</h4><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p><p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p><p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p><ol><li><p>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</p></li><li><p>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</p></li><li><p>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</p></li><li><p>对于浮点值，加 1 或减 1。</p></li><li><p>如果是对象，则调用其（第 3 章会详细介绍的）valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值。</p></li></ol><p>下面的例子演示了这些规则：</p><pre><code>let s1 = "2";let s2 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1++; // 值变成数值 3s2++; // 值变成 NaNb++; // 值变成数值 1f--; // 值变成 0.10000000000000009（因为浮点数不精确）o--; // 值变成-2 </code></pre><hr><h4 id="一元加和减"><a href="#一元加和减" class="headerlink" title="一元加和减"></a>一元加和减</h4><p>如果将一元加应用到非数值,则会执行与使用Number()转型函数一样的类型转换：布尔值false和true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toStrin()方法以得到可以转换的值。</p><p>下面的例子演示了一元加在应用到不同数据类型时的行为：</p><pre><code>let s1 = "01";let s2 = "1.1"; let s3 = "z";let b = false;let f = 1.1;let o = {valueOf() {return -1;}};s1 = +s1; // 值变成数值 1s2 = +s2; // 值变成数值 1.1s3 = +s3; // 值变成 NaNb = +b; // 值变成数值 0f = +f; // 不变，还是 1.1o = +o; // 值变成数值-1 </code></pre><p>一元减由一个减号（-）表示同上</p><hr><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>挖坑了~<br>此坑挖于:2020/11/20<br>此坑填于:~</p><hr><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h4><p>逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。<br>逻辑非操作符会遵循如下规则：</p><ol><li><p>如果操作数是对象，则返回 false。</p></li><li><p>如果操作数是空字符串，则返回 true。</p></li><li><p>如果操作数是非空字符串，则返回 false。</p></li><li><p>如果操作数是数值 0，则返回 true。</p></li><li><p>如果操作数是非 0 数值（包括 Infinity），则返回 false。</p></li><li><p>如果操作数是 null，则返回 true。</p></li><li><p>如果操作数是 NaN，则返回 true。</p></li><li><p>如果操作数是 undefined，则返回 true。</p></li></ol><p>以下示例验证了上述行为：</p><pre><code>console.log(!false); // trueconsole.log(!"blue"); // falseconsole.log(!0); // trueconsole.log(!NaN); // trueconsole.log(!""); // trueconsole.log(!12345); // false </code></pre><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。结果与对同一个值使用 Boolean()函数是一样的：</p><pre><code>console.log(!!"blue"); // trueconsole.log(!!0); // falseconsole.log(!!NaN); // falseconsole.log(!!""); // falseconsole.log(!!12345); // true </code></pre><hr><h4 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h4><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p><p>同真为真，其余全是假</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则:</p><ol><li><p>如果第一个操作数是对象，则返回第二个操作数。</p></li><li><p>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</p></li><li><p>如果两个操作数都是对象，则返回第二个操作数。</p></li><li><p>如果有一个操作数是 null，则返回 null。</p></li><li><p>如果有一个操作数是 NaN，则返回 NaN。</p></li><li><p>如果有一个操作数是 undefined，则返回 undefined</p></li></ol><p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</p><hr><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h4><p>逻辑或操作符由两个管道符（||）表示</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：</p><ol><li><p>如果第一个操作数是对象，则返回第一个操作数。</p></li><li><p>如果第一个操作数求值为 false，则返回第二个操作数。</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数。</p></li><li><p>如果两个操作数都是 null，则返回 null。</p></li><li><p>如果两个操作数都是 NaN，则返回 NaN。</p></li><li><p>如果两个操作数都是 undefined，则返回 undefined。</p></li></ol><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。</p><hr><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h4 id="乘法操作符"><a href="#乘法操作符" class="headerlink" title="乘法操作符"></a>乘法操作符</h4><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。</p><p>乘法操作符在处理特殊值时也有一些特殊的行为。</p><ol><li><p>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以 0，则返回 NaN。</p></li><li><p>如果是 Infinity 乘以非 0的有限数值，则根据第二个操作数的符号返回 Infinity -Infinity。</p></li><li><p>如果是 Infinity 乘以 Infinity，则返回 Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</p></li></ol><h4 id="除法操作符"><a href="#除法操作符" class="headerlink" title="除法操作符"></a>除法操作符</h4><p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p><p>跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ol><li><p>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity或-Infinity。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果是 0 除以 0，则返回 NaN。</p></li><li><p>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><hr><h4 id="取模操作符"><a href="#取模操作符" class="headerlink" title="取模操作符"></a>取模操作符</h4><p>取模（余数）操作符由一个百分比符号（%）表示</p><p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为:</p><ol><li><p>如果操作数是数值，则执行常规除法运算，返回余数。</p></li><li><p>如果被除数是无限值，除数是有限值，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是 0，则返回 NaN。</p></li><li><p>如果是 Infinity 除以 Infinity，则返回 NaN。</p></li><li><p>如果被除数是有限值，除数是无限值，则返回被除数。</p></li><li><p>如果被除数是 0，除数不是 0，则返回 0。</p></li><li><p>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</p></li></ol><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h4 id="加法操作符"><a href="#加法操作符" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>如果有一个操作数是字符串，则要应用如下规则：</p><ol><li><p>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；</p></li><li><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null，则调用 String()函数，分别获取”undefined”和”null”。</p></li></ol><p>看下面的例子：</p><pre><code>let result1 = 5 + 5; // 两个数值console.log(result1); // 10let result2 = 5 + "5"; // 一个数值和一个字符串console.log(result2); // "55" </code></pre><p>ECMAScript 中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + num1 + num2;console.log(message); // "The sum of 5 and 10 is 510" </code></pre><p>如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：</p><pre><code>let num1 = 5;let num2 = 10;let message = "The sum of 5 and 10 is " + (num1 + num2);console.log(message); // "The sum of 5 and 10 is 15" </code></pre><hr><h4 id="加法操作符-1"><a href="#加法操作符-1" class="headerlink" title="加法操作符"></a>加法操作符</h4><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ol><li><p> 如果两个操作数都是数值，则执行数学减法运算并返回结果。</p></li><li><p>如果有任一操作数是 NaN，则返回 NaN。</p></li><li><p>如果是 Infinity 减 Infinity，则返回 NaN。</p></li><li><p>如果是-Infinity 减-Infinity，则返回 NaN。</p></li><li><p>如果是 Infinity 减-Infinity，则返回 Infinity。</p></li><li><p>如果是-Infinity 减 Infinity，则返回-Infinity。</p></li><li><p>如果是+0 减+0，则返回+0。</p></li><li><p>如果是+0 减-0，则返回-0。</p></li><li><p>如果是-0 减-0，则返回+0。</p></li><li><p>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</p></li></ol><p>以下示例演示了上面的规则：</p><pre><code>let result1 = 5 - true; // true 被转换为 1，所以结果是 4let result2 = NaN - 1; // NaNlet result3 = 5 - 3; // 2let result4 = 5 - ""; // ""被转换为 0，所以结果是 5let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3let result6 = 5 - null; // null 被转换为 0，所以结果是 5 </code></pre><hr><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ol><li><p>如果操作数都是数值，则执行数值比较。</p></li><li><p>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</p></li><li><p>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</p></li><li><p>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</p></li><li><p>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</p><p> let result = “23” &lt; “3”; // true</p></li></ol><p>这里在比较字符串”23”和”3”时返回 true。因为两个操作数都是字符串，所以会逐个比较它们的字符编码（字符”2”的编码是 50，而字符”3”的编码是 51）。不过，如果有一个操作数是数值，那么比较的结果就对了：</p><pre><code>let result = "23" &lt; 3; // false</code></pre><p>因为这次会将字符串”23”转换为数值 23，然后再跟 3 比较。但如果字符串不能转换成数值呢？比如下面这个例子：</p><pre><code>let result = "a" &lt; 3; // 因为"a"会转换为 NaN，所以结果是 false</code></pre><p>因为字符”a”不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即任何关系操作符在涉及比较 NaN 时都返回 false。</p><hr><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ol><li><p>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</p></li><li><p>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</p></li><li><p>如果一个操作数是对象，另，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</p></li></ol><p>在进行比较时，这两个操作符会遵循如下规则:</p><ol><li><p>null 和 undefined 相等。</p></li><li><p>null 和 undefined 不能转换为其他类型的值再进行比较。</p></li><li><p>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN。</p></li><li><p>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等。</p></li></ol><p>下表总结了一些特殊情况及比较的结果</p><table><thead><tr><th align="left">表 达 式</th><th align="left">结 果</th></tr></thead><tbody><tr><td align="left">null == undefined</td><td align="left">true</td></tr><tr><td align="left">“NaN” == NaN</td><td align="left">false</td></tr><tr><td align="left">5 == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN == NaN</td><td align="left">false</td></tr><tr><td align="left">NaN != NaN</td><td align="left">true</td></tr><tr><td align="left">false == 0</td><td align="left">true</td></tr><tr><td align="left">true == 1</td><td align="left">true</td></tr><tr><td align="left">true == 2</td><td align="left">false</td></tr><tr><td align="left">undefined == 0</td><td align="left">false</td></tr><tr><td align="left">null == 0</td><td align="left">false</td></tr><tr><td align="left">“5” == 5</td><td align="left">true</td></tr></tbody></table><h4 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h4><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true，比如：</p><pre><code>let result1 = ("55" == 55); // true，转换后相等let result2 = ("55" === 55); // false，不相等，因为数据类型不同</code></pre><p>不全等操作符用一个叹号和两个等于号（!==）表示，只有两个操作数在不转换的前提下不相等才返回 true。比如：</p><pre><code>let result1 = ("55" != 55); // false，转换后相等let result2 = ("55" !== 55); // true，不相等，因为数据类型不同</code></pre><p>另外，虽然 null == undefined 是 true（因为这两个值类似），但 null === undefined 是false，因为它们不是相同的数据类型。</p><p>注意 由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p><hr><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一，语法跟 Java 中一样：</p><pre><code>variable = boolean_expression ? true_value : false_value;</code></pre><p>上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expression 的值决定将哪个值赋给变量 variable 。如果 boolean_expression 是 true ，则赋值 true_value ；如果boolean_expression 是 false，则赋值 false_value。</p><hr><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号操作符可以用来在一条语句中执行多个操作，如下所示：</p><pre><code>let num1 = 1, num2 = 2, num3 = 3;</code></pre><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><pre><code>let num = (5, 1, 4, 8, 0); // num 的值为 0 </code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/8a7.html"/>
      <url>posts/8a7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。</p><hr><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p><p> “undefined”表示值未定义；<br> “boolean”表示值为布尔值；<br> “string”表示值为字符串；<br> “number”表示值为数值；<br> “object”表示值为对象（而不是函数）或 null；<br> “function”表示值为函数；<br> “symbol”表示值为符号。</p><p>下面是使用 typeof 操作符的例子：</p><pre><code>let message = "some string";console.log(typeof message); // "string"console.log(typeof(message)); // "string"console.log(typeof 95); // "number"</code></pre><p>在这个例子中，我们把一个变量（message）和一个数值字面量传给了 typeof 操作符。注意，因为 typeof 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><p>注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeofnull 返回的是”object”。这是因为特殊值 null 被认为是一个对空对象的引用。</p><hr><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值：</p><pre><code>let message;console.log(message == undefined); // true </code></pre><p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined主要用于比较，增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p><p>注意，包含 undefined 值的变量跟未定义变量是有区别的。请看下面的例子：</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined // let age 确保没有声明过这个变量console.log(message); // "undefined"console.log(age); // 报错</code></pre><p>在上面的例子中，第一个 console.log 会指出变量 message 的值，即”undefined”。而第二个console.log 要输出一个未声明的变量 age 的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用 typeof。</p><p>在对未初始化的变量调用 typeof 时，返回的结果是”undefined”，但对未声明的变量调用它时，返回的结果还是”undefined”，</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// let age  确保没有声明过这个变量console.log(typeof message); // "undefined"console.log(typeof age); // "undefined"</code></pre><p>无论是声明还是未声明，typeof 返回的都是字符串”undefined”。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p><pre><code>let message; // 这个变量被声明了，只是值为 undefined// age 没有声明if (message) {// 这个块不会执行}if (!message) {// 这个块会执行}if (age) {// 这里会报错} </code></pre><hr><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：</p><pre><code>let car = null;console.log(typeof car); // "object" </code></pre><p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后被重新赋予了一个对象的引用，比如：</p><pre><code>if (car != null) {// car 是一个对象的引用} </code></pre><p>undefined 值是由 null 值派生而来的<br>    console.log(null == undefined); // true </p><p>永远不必显式地将变量值设置为 undefined。但 null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其与 undefined 区分开来。</p><pre><code>    let message = null;    let age;    if (message) {    // 这个块不会执行    }    if (!message) {    // 这个块会执行    }     if (age) {    // 这个块不会执行    }    if (!age) {    // 这个块会执行    } </code></pre><hr><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0</p><table><thead><tr><th align="left">数据类型</th><th align="left">转换为 true 的值</th><th align="left">转换为 false 的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">true</td><td align="left">false</td></tr><tr><td align="left">String</td><td align="left">非空字符串</td><td align="left">“”（空字符串）</td></tr><tr><td align="left">Number</td><td align="left">非零数值（包括无穷值）</td><td align="left">0、NaN（参见后面的相关内容）</td></tr><tr><td align="left">Object</td><td align="left">任意对象</td><td align="left">null</td></tr><tr><td align="left">Undefined</td><td align="left">N/A（不存在）</td><td align="left">undefined</td></tr></tbody></table><p>理解以上转换非常重要，因为像 if 等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p><pre><code>let message = "Hello world!";if (message) {console.log("Value is true");}</code></pre><p>在这个例子中，console.log 会输出字符串”Value is true”，因为字符串 message 会被自动转换为等价的布尔值 true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p><hr><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>最基本的数值字面量格式是十进制整数，直接写出来即可：</p><pre><code>let intNum = 55; // 整数</code></pre><p>整数也可以用八进制（以 8 为基数）或十六进制（以 16 为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7）。如果字面量中包含的数字超出应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p><pre><code>let octalNum1 = 070; // 八进制的 56let octalNum2 = 079; // 无效的八进制值，当成 79 处理let octalNum3 = 08; // 无效的八进制值，当成 8 处理</code></pre><p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p><p>要创建十六进制字面量，必须让真正的数值前缀 0x（区分大小写），然后是十六进制数字（0<del>9 以及 A</del>F）。十六进制数字中的字母大小写均可。下面是几个例子：</p><pre><code>let hexNum1 = 0xA; // 十六进制 10let hexNum2 = 0x1f; // 十六进制 31</code></pre><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p><pre><code>let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐</code></pre><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0（如 1.0），那它也会被转换为整数，如下例所示：</p><pre><code>let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理</code></pre><hr><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN：</p><pre><code>console.log(0/0); // NaNconsole.log(-0/+0); // NaN</code></pre><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity：</p><pre><code>console.log(5/0); // Infinityconsole.log(5/-0); // -Infinity </code></pre><p>NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）。其次，NaN 不等于包括 NaN 在内的任何值。例如，下面的比较操作会返回 false：</p><pre><code>console.log(NaN == NaN); // false </code></pre><p>为此，ECMAScript 提供了 isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致这个函数返回<br>true。举例如下：</p><pre><code>console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false，10 是数值console.log(isNaN("10")); // false，可以转换为数值 10console.log(isNaN("blue")); // true，不可以转换为数值console.log(isNaN(true)); // false，可以转换为数值 1</code></pre><hr><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p>有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p><p>Number()函数基于如下规则执行转换。</p><p> 布尔值，true 转换为 1，false 转换为 0。<br> 数值，直接返回。<br> null，返回 0。<br> undefined，返回 NaN。<br> 字符串，应用以下规则。</p><ol><li><p>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回 123，Number(“011”)返回 11（忽略前面的零）。</p></li><li><p> 如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p></li><li><p>如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p></li><li><p>如果是空字符串（不包含字符），则返回 0。</p></li><li><p>如果字符串包含除上述情况之外的其他字符，则返回 NaN。</p></li></ol><p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用<br>toString()方法，再按照转换字符串的规则转换。</p><pre><code>let num1 = Number("Hello world!"); // NaNlet num2 = Number(""); // 0let num3 = Number("000011"); // 11let num4 = Number(true); // 1</code></pre><p>可以看到，字符串”Hello world”转换之后是 NaN，因为它找不到对应的数值。</p><p>考虑到用 Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用 parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number()不一样，它返回 0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为 22，因为小数点不是有效的整数字符。</p><p>假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以”0x”开头，就会被解释为十六进制整数。如果字符串以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。下面几个转换示例有助于理解上述规则：</p><pre><code>let num1 = parseInt("1234blue"); // 1234let num2 = parseInt(""); // NaNlet num3 = parseInt("0xA"); // 10，解释为十六进制整数let num4 = parseInt(22.5); // 22let num5 = parseInt("70"); // 70，解释为十进制值let num6 = parseInt("0xf"); // 15，解释为十六进制整数</code></pre><p>通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p><pre><code>let num1 = parseInt("10", 2); // 2，按二进制解析let num2 = parseInt("10", 8); // 8，按八进制解析let num3 = parseInt("10", 10); // 10，按十进制解析let num4 = parseInt("10", 16); // 16，按十六进制解析</code></pre><p>parseFloat()函数的工作方式跟 parseInt()函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，”22.34.5”将转换成 22.34。</p><p>parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 0。因为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 parseFloat()返回整数。下面是几个示例：</p><pre><code>let num1 = parseFloat("1234blue"); // 1234，按整数解析let num2 = parseFloat("0xA"); // 0let num3 = parseFloat("22.5"); // 22.5let num4 = parseFloat("22.34.5"); // 22.34let num5 = parseFloat("0908.5"); // 908.5let num6 = parseFloat("3.125e7"); // 31250000</code></pre><hr><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（”）、单引号（’）或反引号（`）标示，因此下面的代码都是合法的：</p><pre><code>    let firstName = "John";    let lastName = 'Jacob';    let lastName = `Jingleheimerschmidt`; </code></pre><h4 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h4><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p><table><thead><tr><th align="left">字 面 量</th><th align="left">含 义</th></tr></thead><tbody><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\t</td><td align="left">制表</td></tr><tr><td align="left">\b</td><td align="left">退格</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\f</td><td align="left">换页</td></tr><tr><td align="left">\\</td><td align="left">反斜杠（\）</td></tr><tr><td align="left">\‘</td><td align="left">单引号（’），在字符串以单引号标示时使用，例如’He said, 'hey.'‘</td></tr><tr><td align="left">\“</td><td align="left">双引号（”），在字符串以双引号标示时使用，例如”He said, "hey."“</td></tr><tr><td align="left">\ `</td><td align="left">反引号（`），在字符串以反引号标示时使用，例如`He said, \`hey.\``</td></tr><tr><td align="left">\xnn</td><td align="left">以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如\x41 等于”A”</td></tr><tr><td align="left">\unnnn</td><td align="left">以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如\u03a3 等于希腊字符”Σ”</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p><pre><code>let text = "This is the letter sigma: \u03a3.";</code></pre><p>在这个例子中，即使包含 6 个字符长的转义序列，变量 text 仍然是 28 个字符长。因为转义序列表示一个字符，所以只算一个字符。</p><p>字符串的长度可以通过其 length 属性获取：</p><pre><code>console.log(text.length); // 28 </code></pre><h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p><pre><code>let lang = "Java";lang = lang + "Script"; </code></pre><p>这里，变量 lang 一开始包含字符串”Java”。紧接着，lang 被重新定义为包含”Java”和”Script”的组合，也就是”JavaScript”。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上”Java”和”Script”。最后销毁原始的字符串”Java”和字符串”Script”</p><h4 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h4><p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p><pre><code>let age = 11;let ageAsString = age.toString(); // 字符串"11"let found = true;let foundAsString = found.toString(); // 字符串"true"</code></pre><p>toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。）null 和 undefined 值没有 toString()方法。</p><p>默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p><pre><code>let num = 10;console.log(num.toString()); // "10"console.log(num.toString(2)); // "1010"console.log(num.toString(8)); // "12"console.log(num.toString(10)); // "10"console.log(num.toString(16)); // "a" </code></pre><p>String()函数遵循如下规则:</p><p> 如果值有 toString()方法，则调用该方法（不传参数）并返回结果。<br> 如果值是 null，返回”null”。<br> 如果值是 undefined，返回”undefined”。</p><p>下面看几个例子：</p><pre><code>let value1 = 10;let value2 = true;let value3 = null;let value4;console.log(String(value1)); // "10"console.log(String(value2)); // "true"console.log(String(value3)); // "null"console.log(String(value4)); // "undefined" </code></pre><hr><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><pre><code>let myMultiLineString = 'first line\nsecond line';let myMultiLineTemplateLiteral = `first linesecond line`;console.log(myMultiLineString);// first line// second lineconsole.log(myMultiLineTemplateLiteral);// first line // second lineconsole.log(myMultiLineString === myMultiLinetemplateLiteral); // true </code></pre><p>顾名思义，模板字面量在定义模板时特别有用，比如下面这个 HTML 模板：</p><pre><code>        let pageHTML = `        &lt;div&gt;        &lt;a href="#"&gt;        &lt;span&gt;Jake&lt;/span&gt;        &lt;/a&gt;        &lt;/div&gt;`;</code></pre><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><pre><code>// 这个模板字面量在换行符之后有 25 个空格符let myTemplateLiteral = `first line                        second line`;console.log(myTemplateLiteral.length); // 47// 这个模板字面量以一个换行符开头let secondTemplateLiteral = `first linesecond line`;console.log(secondTemplateLiteral[0] === '\n'); // true// 这个模板字面量没有意料之外的字符let thirdTemplateLiteral = `first linesecond line`;console.log(thirdTemplateLiteral);// first line// second line </code></pre><hr><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在${}中使用一个 JavaScript 表达式实现：</p><pre><code>let value = 5;let exponent = 'second';// 以前，字符串插值是这样实现的：let interpolatedString =value + ' to the ' + exponent + ' power is ' + (value * value);// 现在，可以用模板字面量这样实现：let interpolatedTemplateLiteral =`${ value } to the ${ exponent } power is ${ value * value }`;console.log(interpolatedString); // 5 to the second power is 25console.log(interpolatedTemplateLiteral); // 5 to the second power is 25</code></pre><p>嵌套的模板字符串无须转义：</p><pre><code>console.log(`Hello, ${ `World` }!`); // Hello, World! </code></pre><p>将表达式转换为字符串时会调用 toString()：</p><pre><code>let foo = { toString: () =&gt; 'World' };console.log(`Hello, ${ foo }!`); // Hello, World! </code></pre><p>在插值表达式中可以调用函数和方法：</p><pre><code>function capitalize(word) {return `${ word[0].toUpperCase() }${ word.slice(1) }`;}console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!</code></pre><p>此外，模板也可以插入自己之前的值：</p><pre><code>let value = '';function append() {value = `${value}abc`console.log(value);}append(); // abcappend(); // abcabcappend(); // abcabcabc </code></pre><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><pre><code>let o = new Object(); </code></pre><p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ol><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。</p></li><li><p>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty(“name”)）或符号。</p></li><li><p>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。（第 6 章将详细介绍原型。）</p></li><li><p>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用（本章稍后讨论的）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</p></li></ol><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。</p><hr><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a>Symbol 类型</h3><p>挖个坑~QvQ<br>此坑挖于: 2020/11/19<br>此坑填于: ~</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/85be.html"/>
      <url>posts/85be.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript变量是松散类型的，意思是可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有三个关键字可以声明变量：var、const、let。其中，var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更高版本中使用。</p><hr><h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>要定义变量可以用操作符var，后跟变量名。<br>var message;</p><p>变量可以保存任何类型的值。不初始会保存一个特殊值undefined。</p><hr><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用var操作符定义的变量会成为包含它的函数的局部变量。比如使用var在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁。</p><p>不过，在函数内部定义变量时省略var操作符，可以创建一个全局变量，只要调用一次函数，可以在函数外部引用: (不推荐这么做:省略var)</p><pre><code>            function test(){                message="hi";   //全局变量            }            test();            console.log(message); </code></pre><hr><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let跟var的作用差不多，但有个明显区别，var声明的范围是函数作用域，而let声明的范围是块作用域</p><pre><code>    if(true){        var name = 'M';        console.log(name); // M    }    console.log(name); // M    if(true){        let age = 'A';        console.log(age); // A    }    console.log(age); // 未定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也试用let</p><p>let也不允许同一个块作用域中出现重复声明</p><pre><code>    var name;    var name;    let age;    let age; //标识符age已经声明过了</code></pre><p>对声明冗余报错不会因混用 let 和 var 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><pre><code>    var name;    let name; // 错误    let age;    var age; // 错误 </code></pre><hr><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。</p><pre><code>    var name="M";    console.log(name); // M    console.log(name02); //undefined    var name02="M";     console.log(name02); //报错    let name02="M"; </code></pre><hr><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）。</p><pre><code>    var name = 'Matt';    console.log(window.name); // 'Matt'    let age = 26;    console.log(window.age); // undefined </code></pre><p>不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><hr><h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {    // 循环逻辑    }    console.log(i); // 5</code></pre><p>改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部：</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    // 循环逻辑    }     console.log(i); // ReferenceError: i 没有定义</code></pre><p>在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><pre><code>    for (var i = 0; i &lt; 5; ++i) {        setTimeout(() =&gt; console.log(i), 0)    }</code></pre><p>// 你可能以为会输出 0、1、2、3、4<br>// 实际上会输出 5、5、5、5、5 </p><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p><pre><code>    for (let i = 0; i &lt; 5; ++i) {    setTimeout(() =&gt; console.log(i), 0)    }    // 会输出 0、1、2、3、4 </code></pre><hr><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 36; // TypeError: 给常量赋值// const 也不允许重复声明const name = 'Matt';const name = 'Nicholas'; // SyntaxError// const 声明的作用域也是块const name = 'Matt';if (true) {const name = 'Nicholas';}console.log(name); // Matt </code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = {};person.name = 'Matt'; // ok </code></pre><p>JavaScript 引擎会为 for 循环中的 let 声明分别创建独立的变量实例，虽然 const 变量跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）：</p><pre><code>for (const i = 0; i &lt; 10; ++i) {} // TypeError：给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 for-of 和 for-in 循环特别有意义：</p><pre><code>let i = 0;for (const j = 7; i &lt; 5; ++i) {console.log(j);}// 7, 7, 7, 7, 7for (const key in {a: 1, b: 2}) {console.log(key);}// a, bfor (const value of [1,2,3,4,5]) {console.log(value);}// 1, 2, 3, 4, 5 </code></pre><hr><h3 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="headerlink" title="声明风格及最佳实践"></a>声明风格及最佳实践</h3><ol><li><p>不使用var，限制自己只使用let和const有助于提升代码质量，因为变量有了明确的作用域、声明位置以及不变的值。</p></li><li><p>const优先，let次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript高级语言程序设计(一)</title>
      <link href="posts/14a5.html"/>
      <url>posts/14a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p>介绍语言的基本概念，包括语法和流程控制语句；解释JavaScript与其他类C语言在语法上的异同点；讨论内置操作符时也会谈到强制类型转换；此外还将介绍所有的原始类型，包括：Symbol等。</p><hr><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>首先要知道,<strong>ECMAScript</strong>中一切都区分大小写。无论是<strong>变量</strong>、<strong>函数名</strong>还是<strong>操作符</strong>。换句话说<strong>变量test</strong>和<strong>变量Test</strong>是俩个不同的变量。类似的，<strong>typeof</strong>不能作为函数名，因为它是一个<strong>关键字</strong>。但是<strong>Typeof</strong>是一个完全有效的函数名。</p><hr><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>所谓<strong>标识符</strong>，就是<strong>变量</strong>、<strong>函数</strong>、<strong>属性</strong>或<strong>函数参数</strong>的名称。标识符可以由一或多个下列字符组成：</p><ol><li><p>第一个字符必须是一个<strong>字母</strong>、<strong>下划线</strong>(_)或<strong>美元符号</strong>($);</p></li><li><p>剩下的其他字符可以是<strong>字母</strong>、<strong>下划线</strong>、<strong>美元符号</strong>或<strong>数字</strong>。</p></li></ol><p>按照惯例，标识符使用<strong>驼峰大小写</strong>形式，即第一个单词首字母小写，后面每个单词的首字母大写。</p><p><strong>注意</strong> 关键字、保留字、true、false和null不能作为标识符。</p><hr><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>ECMAScript采用C语言风格的注释，包括单行注释和块注释。</p><p>单行注释以俩个斜杠字符开头， // 单行注释</p><p>块注释以一个斜杠和一个星号开头，以它们的反向组合结尾， /* 块注释 */</p><hr><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript5增加了严格模式的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><p><code>"use strict"</code></p><p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p><pre><code>        function doSomething(){            "use strict";            //函数体        }</code></pre><p>所有现代浏览器都支持严格模式</p><hr><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMASCript中语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾。</p><pre><code>        let sum = a + b   //没有分号也有效，但不推荐        let diff = a - b; //加分号有效，推荐</code></pre><p>多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号({)开始，右花括号(})结束。</p><p>if之类的控制语句只在执行多条语句要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即便只有一条语句。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐播放器</title>
      <link href="posts/c06f.html"/>
      <url>posts/c06f.html</url>
      
        <content type="html"><![CDATA[<p>网址在这里:</p><p>版本0.5:<br><a href="https://yanyanzio.top/Project/One/YYZMusic">https://yanyanzio.top/Project/One/YYZMusic</a></p><p>要源码可以联系我,有QQ</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗忘的HTML&amp;&amp;CSS</title>
      <link href="posts/e31c.html"/>
      <url>posts/e31c.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS溢出属性-overflow"><a href="#CSS溢出属性-overflow" class="headerlink" title="CSS溢出属性 overflow"></a>CSS溢出属性 overflow</h3><p>该overflow属性指定如果内容溢出元素框会发生什么情况。</p><p>此属性指定在元素的内容太大而无法放入指定区域时是剪辑内容还是添加滚动条。</p><p>/* 默认值。内容不会被修剪，会呈现在元素框之外 */<br>overflow: visible;</p><p>/* 内容会被修剪，并且其余内容不可见 */<br>overflow: hidden;</p><p>/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */<br>overflow: scroll;</p><p>/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */<br>overflow: auto;</p><p>/* 规定从父元素继承overflow属性的值 */<br>overflow: inherit;</p><hr><h3 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h3><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。 </p><p>border 和 outline<br>border 和 outline 很类似，但有如下区别：</p><p>outline不占据空间，绘制于元素内容周围。<br>根据规范，outline通常是矩形，但也可以是非矩形的。</p><p>&lt;’outline-color’&gt;<br>设置轮廓的颜色。没有设置时默认值为 currentcolor。<br>&lt;’outline-style’&gt;<br>设置轮廓的样式。没有设置时默认值为 none。<br>&lt;’outline-width’&gt;<br>设置轮廓的宽度。没有设置时默认值为 medium</p><p>outline:none; 取消选中边框</p><hr><h3 id="选择器-交集选择器"><a href="#选择器-交集选择器" class="headerlink" title="选择器: 交集选择器"></a>选择器: 交集选择器</h3><p>我主要用在绑定一个标签, 如: .Old.Xin  有一个源 <code>&lt;div class="Old"&gt;&lt;/div&gt;</code></p><p>想要在这个<strong>div</strong>中添加一个新的类,即<code>&lt;div class="Old Xin"&gt;&lt;/div&gt;</code></p><p>就用 <strong>.Old.Xin</strong> 交集选择器</p><hr><h3 id="webkit-scrollbar-滚轮样式"><a href="#webkit-scrollbar-滚轮样式" class="headerlink" title="::-webkit-scrollbar 滚轮样式"></a>::-webkit-scrollbar 滚轮样式</h3><p>::-webkit-scrollbar 滚动条整体部分，其中的属性有width,height,background,border（就和一个块级元素一样</p><p>::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分</p><hr><h3 id="img的边框"><a href="#img的边框" class="headerlink" title="img的边框"></a>img的边框</h3><ol><li><code>&lt;img&gt;</code> 标签的 border 属性规定图像周围的边框的宽度</li></ol><p><code>border: none;</code> // css属性</p><ol start="2"><li><p>当img没有接收到src属性的时候会自动出现边框，border:0/none都不管用的情况下，解决方法：</p><pre><code> img[src=""],img:not([src]){     opacity:0; }</code></pre></li></ol><hr><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="posts/e0b8.html"/>
      <url>posts/e0b8.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue.js是一套构建用户界面的渐进式框架</p><p>Vue.js 只关注视图层， 设计时采用自底向上渐进式开发的构架，核心部件只关注用户界面的构建</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件</p><p><strong>注意</strong>： Vue.js 不支持 IE8 及其以下 IE 版本</p><h3 id="为什么要使用Vue"><a href="#为什么要使用Vue" class="headerlink" title="为什么要使用Vue"></a>为什么要使用Vue</h3><p>1.轻量级,体积小是一个重要指标,Vue.Js压缩后只有20多KB<br>2.移动优先,更适合移动端,比如移动端的Touch事件<br>3.易上手,学习曲线平稳,文档齐全<br>4.吸收了Angular(模块化)和React(虚拟DOM的长处),并拥有自己独特的功能<br>5.开源,社区活跃度高<br>…</p><h3 id="学前准备"><a href="#学前准备" class="headerlink" title="学前准备"></a>学前准备</h3><p>在我们继续学习 Vue.js 2 之前，希望对以下知识有一定的了解<br><strong>HTML</strong><br><strong>CSS</strong><br><strong>JavaScript</strong></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><strong>Vue.js</strong> 是一个 <strong>JavaScript</strong> 脚本库，所以安装起来非常简单，只要引用 <strong>vue.min.js</strong> 脚本就可以了</p><p>可以在 Vue.js 的官网上直接下载 vue.min.js 然后使用 <code>&lt;script&gt;</code> 标签引入</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><ol><li><p><strong>安装 cnpm</strong><br><code>npm install --global cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p><strong>全局安装 vue-cli</strong><br><code>$ cnpm install --global vue-cli</code></p></li><li><p><strong>创建一个基于 webpack 模板的新项目</strong><br><code>$ vue init webpack yyzvue</code></p></li><li><p>这里需要你进行一些配置，如果不想更改，可以直接回车</p></li></ol><p><code>$ vue init webpack yyzvue</code>  </p><p><code>? Project name yyzvue</code><br><code>? Project description A Vue.js project</code><br><code>? Author sense &lt;yu.fei@gmail.com&gt;</code><br><code>? Vue build standalone</code><br><code>? Install vue-router? Yes</code><br><code>? Use ESLint to lint your code? Yes</code><br><code>? Pick an ESLint preset Standard</code><br><code>? Set up unit tests Yes</code><br><code>? Pick a test runner jest</code><br><code>? Setup e2e tests with Nightwatch? Yes</code></p><p>   <code>vue-cli · Generated "webapp".</code></p><p>   <code>To get started:</code><br>     <code>cd webapp</code><br>     <code>npm install</code><br>     <code>npm run dev</code><br>   <code>Documentation can be found at https://vuejs-templates.github.io/webpack</code></p><ol start="3"><li>安装依赖并运行<br>配置配置完成后，可以进入项目，然后执行以下命令</li></ol><p><code>$ cd webapp</code><br><code>$ cnpm install</code><br>先去喝杯茶，然后调戏小孩，再回来看看是否安装好了…</p><p><code>$ npm run dev</code></p><p> <code>DONE  Compiled successfully in </code></p><p> <code>I  Your application is running here: http://localhost:8080</code></p><p> 成功执行以上命令后访问 <a href="http://localhost:8080/%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA">http://localhost:8080/，输出结果如下所示</a></p><p> <img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_1.png"></p><hr><h2 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h2><p>上一章节中，我们使用 vue-cli 工具创建了一个 webapp 的项目</p><p>如果我们使用 IDE（Eclipse、Atom）打开该目录，显示目录结构如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_2.png"></p><h3 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h3><table><thead><tr><th align="left">目录/文件</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">build</td><td align="left">最终发布的代码存放位置</td></tr><tr><td align="left">config</td><td align="left">配置目录，包括端口号等。我们初学可以使用默认的</td></tr><tr><td align="left">node_modules</td><td align="left">npm 加载的项目依赖模块</td></tr><tr><td align="left">src</td><td align="left">这里是我们要开发的目录，基本上要做的事情都在这个目录里里面包含了几个目录及文件assets: 放置一些图片，如logo等components: 目录里面放了一个组件文件，可以不用App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录main.js: 项目的核心文件</td></tr><tr><td align="left">static</td><td align="left">静态资源目录，如图片、字体等</td></tr><tr><td align="left">test</td><td align="left">初始测试目录，可删除</td></tr><tr><td align="left">.xxxx文件</td><td align="left">这些是一些配置文件，包括语法配置，git配置等</td></tr><tr><td align="left">index.html</td><td align="left">首页入口文件，你可以添加一些 meta 信息或同统计代码啥的</td></tr><tr><td align="left">package.json</td><td align="left">项目配置文件</td></tr><tr><td align="left">README.md</td><td align="left">项目的说明文档，markdown 格式</td></tr></tbody></table><h3 id="用vue写一个hello-word"><a href="#用vue写一个hello-word" class="headerlink" title="用vue写一个hello word"></a>用vue写一个hello word</h3><p>代码如下</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;div id="app"&gt;        {{message}}    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/vue_3.png"></p><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><pre><code>&lt;div id="app_01"&gt;    {{mes+'!'}}    &lt;h2 v-text="mes+'!'"&gt;iii&lt;/h2&gt;    &lt;h2&gt;hah{{mes}}iii&lt;/h2&gt;&lt;/div&gt;</code></pre><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><pre><code>    &lt;div id="app_01"&gt;    &lt;span v-text="mes"&gt;&lt;/span&gt;    &lt;span v-html="mes"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        var vm= new Vue({        el: '#app_01' ,        data:{            mes: '&lt;p style="color:red;font-size:30px;"&gt;言言子&lt;/p&gt;'        }        });    &lt;/script&gt;</code></pre><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>设置元素属性值,如: v-bind:src=”imgSrc”,v-bind:title=”arcTit”<br>其中 v-bind 可以省略</p><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-bind:title="message"&gt;HHHHH&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue=new Vue({            el:"#app",            data:{                message:"hello word!"            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p>当把鼠标放到<strong>HHHHH</strong>上时,鼠标下会有个标记</p><p>你看到的 <strong>v-bind</strong> 等被称为标记,指令带有前缀<strong>v-</strong>,以示他们是<strong>Vue</strong>提供的特殊特性</p><p>他们会在渲染的<strong>DOM</strong>上应用特殊的响应式行为。在这里,指令的意思为：将这个元素节点的<strong>title</strong></p><p>特性和<strong>Vue</strong>实例的<strong>message</strong>属性保持一致。</p><p>如果打开浏览器的控制台，输入<code>vue.message="哦哦哦哦哦"</code>,就会看到绑定了<strong>title</strong>特性的HTML</p><p>已经进行了更新</p><h3 id="v-if-v-else-v-else-if"><a href="#v-if-v-else-v-else-if" class="headerlink" title="v-if,v-else,v-else-if"></a>v-if,v-else,v-else-if</h3><pre><code>&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok"&gt;YES&lt;/span&gt;        &lt;span v-else&gt;NONONO&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: true            }        } );    &lt;/script&gt;&lt;/body&gt;&lt;body&gt;      &lt;div id="app"&gt;        &lt;span v-if="ok==='A'"&gt;这是A&lt;/span&gt;        &lt;span v-else-if="ok==='B'"&gt;这是B&lt;/span&gt;        &lt;span v-else&gt;啥也不是&lt;/span&gt;    &lt;/div&gt;     &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vue= new Vue({            el: "#app" ,            data: {                ok: 'A'            }        } );    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><pre><code>&lt;div id="app"&gt;        &lt;p v-for="item in items"&gt;            {{item.message}}        &lt;/p&gt;&lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: "#app",            data: {                items: [                    {message: '言言子好可爱!'},                    {message: '言言子好萌!'}                ]            }        });    &lt;/script&gt;</code></pre><p>在控制台里，输入 vm.items.push({ message: ‘芜湖！好耶！’ })，你会发现列表最后添加了一个新项目</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为了让用户和你的应用进行交互，我们可以用 v-on 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><pre><code>&lt;div id="app_01"&gt;    &lt;p @click="func"&gt;{{message}}&lt;/p&gt;    &lt;input type="button" value="事件绑定-点击" v-on:click="func"&gt;    &lt;input type="button" value="事件绑定-点击" @click="func"&gt;    &lt;input type="button" value="事件绑定-" v-on:monseenter="func"&gt;    &lt;input type="button" value="事件绑定-双击" v-on:dblclick="func"&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app_01",            data: {                message: "ABC"            },            methods: {                func() {                    this.message = this.message.split('').reverse().join('');                }            }    }); &lt;/script&gt;</code></pre><p><strong>split() 方法用于把一个字符串分割成字符串数组</strong><br><strong>reverse() 方法用于颠倒数组中元素的顺序</strong><br><strong>join() 方法用于把数组中的所有元素放入一个字符串</strong></p><p>注意在 <strong>reverseMessage</strong> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><h3 id="用Vue做简单计数器"><a href="#用Vue做简单计数器" class="headerlink" title="用Vue做简单计数器"></a>用Vue做简单计数器</h3><pre><code>    &lt;div id="app"&gt;    &lt;button @click="add"&gt;+&lt;/button&gt;    &lt;span&gt;{{num}}&lt;/span&gt;    &lt;button @click="jian"&gt;-&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    var vm= new Vue({            el: "#app",            data: {                num: 0            },            methods: {                add(){                    if(this.num&lt;10){                        this.num+=1;                    }else{                        alert("最大为10!");                    }                },                jian(){                    if(this.num&gt;0){                        this.num-=1;                    }else{                        alert("最小为0!");                    }                }            }    });&lt;/script&gt;</code></pre><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>根据表达式的真假切换元素的显示和隐藏</p><pre><code>&lt;div id="app"&gt;    &lt;button @click="q"&gt;点击隐藏图片&lt;/button&gt;    &lt;img src="./1.jpg" v-show="isShow"&gt;    &lt;img src="./1.jpg" v-if="isShow"&gt;    &lt;img src="./1.jpg" v-show="age&gt;20"&gt;&lt;/div&gt;&lt;script&gt;    var vm =new Vue({        el: "#app",    data: {            isShow: true,            age: 18    },    methods: {            q(){                this.isShow= !this.isShow;            }    }    });&lt;/script&gt;</code></pre><p>频繁切换的元素用 <strong>v-show</strong>,反之用 <strong>v-if</strong></p><p>因为操作DOM数对性能的消耗比较大(<strong>v-if</strong>)</p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>Vue 还提供了 <strong>v-model</strong> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><pre><code>&lt;div id="app-6"&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input v-model="message"&gt;&lt;/div&gt;var app6 = new Vue({  el: '#app-6',  data: {    message: 'Hello Vue!'  }})</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单</p><pre><code>&lt;div class="app"&gt;    &lt;yan&gt;&lt;/yan&gt;&lt;/div&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt;    // 定义一个Vue组件    Vue.component('yan',{        template: '&lt;p&gt;言言子努力加油&lt;/p&gt;'    })     var vm= new Vue({         el: "#app"     }); &lt;/script&gt;</code></pre><h3 id="用Vue切换图片"><a href="#用Vue切换图片" class="headerlink" title="用Vue切换图片"></a>用Vue切换图片</h3><pre><code>&lt;div id="app"&gt;    &lt;div&gt;            &lt;img :src="img[index]" alt=""&gt;            &lt;a href="##" @click="sub" v-show="index!=0"&gt;&lt;&lt;/a&gt;            &lt;a href="##" @click="add" v-show="index&lt;img.length-1"&gt;&gt;&lt;/a&gt;        &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: '#app',        data:{                img: ['./1.jpg','./2.jpg','./3.png'],                index: 0        },        methods:{            add(){                    this.index++;            },            sub(){                    this.index--;            }        }    });&lt;/script&gt;</code></pre><h3 id="用Vue做一个记录本功能"><a href="#用Vue做一个记录本功能" class="headerlink" title="用Vue做一个记录本功能"></a>用Vue做一个记录本功能</h3><pre><code>&lt;div id="app"&gt;    &lt;header&gt;        &lt;h1&gt;记事本&lt;/h1&gt;        &lt;input v-model="inputValue" @keyup.enter="add" autofocus="autofocus" autocomplete="off" placeholder="请输入"&gt;    &lt;/header&gt;    &lt;section&gt;        &lt;ul&gt;            &lt;li v-for="(item,index) in arr"&gt;                &lt;div&gt;                    &lt;span&gt;{{index+1}}.&lt;/span&gt;                    &lt;label&gt;{{item}}&lt;/label&gt;                    &lt;button @click="sub(index)"&gt;&lt;/button&gt;                &lt;/div&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/section&gt;    &lt;footer v-show="arr.length!=0" &gt;        &lt;span&gt;            &lt;strong  &gt;{{arr.length}}&lt;/strong&gt;        &lt;/span&gt;        &lt;button @click="clear"&gt;Clear&lt;/button&gt;    &lt;/footer&gt;&lt;/div&gt;&lt;script&gt;    var vm = new Vue({        el: "#app",        data: {            arr: [                "ABC",                "QWE",                "ZXC"            ],            inputValue: ""        },        methods: {            add(){                this.arr.push(this.inputValue);            },            sub(index){                this.arr.splice(index,1);            },            clear(){                this.arr= []            }        }    });&lt;/script&gt;</code></pre><hr><h2 id="AXIOS的基本使用-实例"><a href="#AXIOS的基本使用-实例" class="headerlink" title="AXIOS的基本使用(实例)"></a>AXIOS的基本使用(实例)</h2><pre><code>&lt;input type="button"  id="get" value="get请求"&gt;&lt;input type="button" id="post" value="post请求"&gt;&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script&gt;    document.querySelector("#get").onclick= function(){        axios.get("https://autumnfish.cn/api/joke/listsadsad?num=1")        .then(function (response){            console.log(response);        },function(err){            console.log(err);        })    }    document.querySelector("#post").onclick=function(){        axios.post("https://autumnfish.cn/api/user/reg",        {username: "言言子"})        .then(function(re){            console.log(re);        },function(err){            console.log(err);        })    }&lt;/script&gt;</code></pre><h3 id="AXIOS-Vue-获取笑话"><a href="#AXIOS-Vue-获取笑话" class="headerlink" title="AXIOS+Vue:获取笑话"></a>AXIOS+Vue:获取笑话</h3><pre><code>&lt;div id="app"&gt;    &lt;input type="button" value="获取笑话" @click="getJoke"&gt;    &lt;p&gt;{{Joke}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var vm=new Vue({        el: "#app",        data: {            Joke: ""        },        methods: {            getJoke(){                var that= this;                axios.get("https://autumnfish.cn/api/joke")                .then(function(resq){                                            that.Joke= resq.data;                })            }        }    });&lt;/script&gt;</code></pre><h3 id="网络应用-天气查询"><a href="#网络应用-天气查询" class="headerlink" title="网络应用:天气查询"></a>网络应用:天气查询</h3><pre><code>HTML&lt;div id="app"&gt;        &lt;div&gt;            &lt;p&gt;天知道&lt;/p&gt;            &lt;div&gt;                &lt;input type="text" placeholder="请输入查询天气"                 @keyup.enter="searchTQ" v-model="city"&gt;                &lt;input type="button" value="搜索"&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;a href="##" @click="changeCity('北京')"&gt;北京&lt;/a&gt;                &lt;a href="##" @click="changeCity('上海')"&gt;上海&lt;/a&gt;                &lt;a href="##" @click="changeCity('广州')"&gt;广州&lt;/a&gt;                &lt;a href="##" @click="changeCity('深圳')"&gt;深圳&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;ul&gt;            &lt;li v-for="item in weatherList"&gt;                &lt;div&gt;{{item.date}}&lt;/div&gt;                &lt;span&gt;{{item.low}} ~ {{item.high}}&lt;/span&gt;                &lt;span&gt;{{item.type}}&lt;/span&gt;                &lt;span&gt;{{item.fengxiang}}&lt;/span&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;     &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;     JS    window.onload=function(){        var vm=new Vue({            el: "#app",            data: {                city: "",                weatherList: []            },            methods: {                searchTQ(){                    var that=this;                    axios.get("http://wthrcdn.etouch.cn/weather_mini?city="                    +this.city).then(function(resq){                        that.weatherList=resq.data.data.forecast;                    },function(err){                        alert(err);                    })                },                changeCity(city){                    this.city=city;                    this.searchTQ();                }            }        });    };</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/f7d3.html"/>
      <url>posts/f7d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id="Canvas-平移-translate"><a href="#Canvas-平移-translate" class="headerlink" title="Canvas 平移 translate()"></a>Canvas 平移 translate()</h2><p>平移 (translate) 就是将一个图形往水平方向和垂直方向移动一定的距离 <strong>(dx,dy)</strong></p><p>但是，Canvas 中的所有几何变换针对的不是绘制的图形，而是针对画布本身</p><p>例如刚开始的时候在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_42.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>translate(50,50)</strong> 将画布水平和垂直方向各移动 50</p><p>然后在 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_43.png"></p><p>此时矩形的起点距离屏幕左上角就已经是 <strong>(100,100)</strong> 了</p><p><strong>语法</strong><br><code>void ctx.translate(dx, dy);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的移动距离</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的移动距离</td></tr></tbody></table><p>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后平移 canvas (50,50) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.translate(50,50);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_44.png"></p><hr><h2 id="Canvas-缩放-scale"><a href="#Canvas-缩放-scale" class="headerlink" title="Canvas 缩放 scale()"></a>Canvas 缩放 scale()</h2><p>缩放 (scale) 就是将一个图形围绕中心点，然后将宽和高分别乘以一定的因子(sx,sy)</p><p>但是，Canvas 中的缩放 (scale) 针对的不是绘制的图形，而是针对画布本身</p><p>画布缩放了，那么画在画布上的图形自然也就缩放了</p><p>例如刚开始的时候在 <strong>(100,100)</strong> 绘制一个 <strong>25x25</strong> 的矩形可能是这样的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_45.png"></p><p>灰色的底为画布(canvas)，绿色的边框为屏幕</p><p>当我们使用 <strong>scale(0.5,2)</strong> 将画布水平方向缩小一倍和垂直方向放大一倍的时候</p><p>这是什么意思呢？</p><p>就是原来水平方向的 1 个单位现在变成了 0.5 个单位了，垂直方向的 1 个单位现在变成了 2 个单位了</p><p>然后在 <strong>(100,100)</strong> 绘制一个 <strong>5x50</strong> 的矩形就是这样的了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_46.png"></p><p><strong>ctx.scale()</strong> 将 <strong>canvas</strong> 水平方向和垂直方向的单位各乘以一定的因子(sx,sy)</p><p>从某些方面说, scale() 缩放的不是画布，而是画布上 1 个单位的距离</p><p><strong>语法</strong><br><code>void ctx.scale(sx, sy)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">dx</td><td align="left">水平方向的缩放因子</td></tr><tr><td align="left">dy</td><td align="left">垂直方向的缩放因子</td></tr></tbody></table><p>dx 和 dy 的值可以是负数，负数是啥意思呢？就是想把整个 canvas 翻转，然后再缩放</p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后缩放画布 canvas <strong>(0.5,2)</strong> 最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_47.png"></p><p>如果缩放因子是负数，那么先镜像 (也就是先翻转)，然后再缩放</p><p>如果 sx 是负数，则先按照 Y 轴镜像，然后再缩放<br>如果 sy 是负数，则先按照 X 轴镜像，然后再缩放<br>下面的范例先在点 (50,50) 绘制一个橘黄色的 100x50 的矩形，然后缩放画布 canvas (-0.5,2) 最后在点 (50,50) 绘制一个 100x50 的绿色矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_48.png"></p><p>哎呀，为什么绿色的没掉了呢？因为，因为垂直镜像了之后，x 轴正方向已经从水平向左改成水平向右了</p><p>如果此时还在 <strong>(50,50)</strong> 的位置画画，肯定是看不到啊，因为它已经跑到另一边去了，而屏幕的位置没变啊，于是就看不到了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_49.png"><br>绿色边框是我们的屏幕显示范围</p><p>如果此时还要看到它，就要把绘制起始点的 x 坐标也翻转下，然后再 x 2 就是变成 (-50)x2=-100 就好了</p><p>如果不 x 2 ，结果还是看不到的，因为 -50 也只是把矩形往右移动了 50 像素，到哪里了？ 贴边了…</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-3");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.scale(-0.5,2);ctx.fillStyle="green";ctx.fillRect(-100,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_50.png"></p><hr><h2 id="Canvas-旋转-rotate"><a href="#Canvas-旋转-rotate" class="headerlink" title="Canvas 旋转 rotate()"></a>Canvas 旋转 rotate()</h2><p>旋转 ( rotate ) 就是将图形围绕一个中心点(0,0)，顺时针或者逆时针旋转一定的弧度 ( angle )</p><p>但是，Canvas 中的旋转 ( rotate ) 针对的不是绘制的图形，而是针对画布本身</p><p>画布旋转了，带来最直接的结果是什么呢？ 就是某个点与屏幕上边之间的夹角改变了</p><p>我们看一个正常情况下的笛卡尔坐标体系，某个点(50,50) 与屏幕上边和 X 轴正方向之间的夹角都是 45 度</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_51.png"></p><p><strong>绿色</strong> 的是屏幕</p><p><strong>灰色</strong> 的是画布</p><p>当我们画布顺时针旋转 30 度后，就变成了下图这样了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_52.png"></p><p>点还是那个点，点与画布之间的夹角还是 <strong>45°</strong>，但点与屏幕间的夹角已经变成了 <strong>75°</strong></p><p>最直观的感受是啥？ 就是点往左下移了那么一点点，我们去掉各种辅助线，大家看看</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_53.png"></p><p>一个点已经是这样了，如果我们画的是一个图形，那么图形上的所有点都移动了，那么直观看起来，就是图形旋转了</p><p><strong>语法</strong><br><code>void ctx.rotate(angle);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">angle</td><td align="left">顺时针旋转的弧度。可以通过角度值计算：degree * Math.PI / 180</td></tr></tbody></table><p><strong>弧度 angle</strong><br>我们特别说明下 <strong>angle</strong> 这个参数，它是一个弧度</p><p>如果我们要顺时针旋转<strong>30°</strong>，那么</p><p><code>angle = 30 * Math.PI / 180</code><br>如果想要逆时针旋转 <strong>30°</strong> 怎么办呢？逆时针旋转 30°，其实就是顺时针旋转 -30°，也就是</p><p><code>angle = 360 + ( -30 * Math.PI / 180 )</code></p><p>下面的范例先在点 <strong>(50,50)</strong> 绘制一个橘黄色的 <strong>100x50</strong> 的矩形，然后顺时针旋转画布 <strong>30°</strong></p><p>最后在点 <strong>(50,50)</strong> 绘制一个 <strong>100x50</strong> 的绿色矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="orange";ctx.fillRect(50,50,100,50);ctx.rotate(30 * Math.PI / 180);ctx.fillStyle="green";ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_54.png"></p><p>我们利用多次旋转画一个折扇图</p><pre><code>&lt;canvas id="canvas-2" width="400" height="00"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var colors = ['#D0021B','#F5A623','#8B572A','#417505','#9013FE','#000000']for ( var i = 0; i &lt; colors.length; i++ ){    ctx.fillStyle = colors[i];    ctx.fillRect(0,0,200,50);    ctx.rotate(15 * Math.PI / 180);}&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_55.png"></p><hr><h2 id="Canvas-橡皮擦-clearRect"><a href="#Canvas-橡皮擦-clearRect" class="headerlink" title="Canvas 橡皮擦 clearRect()"></a>Canvas 橡皮擦 clearRect()</h2><p><strong>ctx.clearRect()</strong> 方法设置指定矩形区域内（以点 (x, y) 为起点，范围是 (width, height) ）所有像素变成透明，并擦除之前绘制的所有内容</p><p><strong>语法</strong><br><code>void ctx.clearRect(x, y, width, height);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">矩形起点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">矩形起点的 y 轴坐标</td></tr><tr><td align="left">width</td><td align="left">矩形的宽度</td></tr><tr><td align="left">height</td><td align="left">矩形的高度</td></tr></tbody></table><p>我们先从 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形，然后再使用 clearRect() 擦出这个矩形的 1/4</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);ctx.clearRect(50,50,200/2,50/2);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_56.png"></p><hr><h2 id="Canvas-绘图上下文-save"><a href="#Canvas-绘图上下文-save" class="headerlink" title="Canvas 绘图上下文 save()"></a>Canvas 绘图上下文 save()</h2><p>Canvas 为我们提供了 图层(Layer) 的支持，Layer(图层) 是按 “栈结构” 来进行管理的</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_57.png"></p><p>当我们调用<strong>save()</strong> 方法，会保存当前 Canvas 的状态然后作为一个 Layer(图层)，添加到 Canvas栈 中，</p><p>而当我们调用 <strong>restore()</strong> 方法的时候，会恢复之前 Canvas 的状态，而此时 Canvas 的图层栈 会弹出栈顶的那个 Layer，后继的 Layer 来到栈顶，此时的 Canvas 回复到此栈顶时保存的 Canvas 状态</p><p>简单说就是 <strong>save() 往栈压入一个 Layer，restore()弹出栈顶的一个Layer，这个 Layer 代表Canvas的 状态</strong>！</p><p>也就是说可以 <strong>save()</strong> 多次，也可以 <strong>restore()</strong> 多次，但是 <strong>restore()</strong> 的调用次数 不能大于 <strong>save()</strong> 否则会引发错误</p><p><code>ctx.save()</code> 方法用于将画布的当前状态保存到栈中</p><p>下面的代码使用 save() 方法保存默认的状态，然后平移 (100,100) 绘制一个绿色矩形后，恢复之前的状态，最后再使用默认的设置绘制一个矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.save();ctx.translate(100,100);ctx.fillStyle = "green"ctx.fillRect(50,50,100,50);ctx.restore();ctx.fillRect(50,50,100,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_58.png"></p><hr><h2 id="Canvas-恢复画板状态-restore"><a href="#Canvas-恢复画板状态-restore" class="headerlink" title="Canvas 恢复画板状态 restore()"></a>Canvas 恢复画板状态 restore()</h2><p><code>ctx.restore()</code> 方法用于将画布恢复到最近一次的保存状态</p><p>如果没有保存状态，此方法不做任何改变</p><hr><h2 id="Canvas-图像混排模式"><a href="#Canvas-图像混排模式" class="headerlink" title="Canvas 图像混排模式"></a>Canvas 图像混排模式</h2><p>首先绘制一个蓝色的矩形，然后绘制一个红色矩形和它重叠，看看不同的图形混排模式带来的效果</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_59.png"></p><p><strong>所有代码如下</strong></p><pre><code>&lt;canvas id="canvas-1" width="500" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var gco = [ 'source-over','source-in','source-out','source-atop',            'destination-over','destination-in','destination-out','destination-atop',            'lighter', 'copy','xor', 'multiply', 'screen', 'overlay', 'darken',            'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light',            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'        ];var canvas = document.getElementById("canvas-1");canvas.width = 500;canvas.height = 2700;var ctx = canvas.getContext("2d");function draw(){    for (var i = 0; i &lt; gco.length; i++ )    {        ctx.font = "16px Microsoft YaHei"        ctx.textBaseline = "middle";        ctx.fillStyle="#333"        ctx.save();        ctx.fillText(gco[i],10,15);        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.translate(70,0)        ctx.fillStyle = "blue";        ctx.fillRect(10, 35, 50, 50);        ctx.fillStyle = "red";        ctx.fillRect(25, 50, 50, 50);        var canvas2 = document.createElement("canvas");        ctx2 = canvas2.getContext("2d");        ctx2.fillStyle = "blue";        ctx2.fillRect(10, 35, 50, 50);        ctx2.globalCompositeOperation = gco[i];        ctx2.fillStyle = "red";        ctx2.fillRect(25, 50, 50, 50);        ctx2.globalCompositeOperation = "source-over";        ctx.drawImage(canvas2,85,0);        ctx.restore();        ctx.translate(0,100);    }}draw();&lt;/script&gt;</code></pre><hr><h2 id="Canvas-图像裁剪"><a href="#Canvas-图像裁剪" class="headerlink" title="Canvas 图像裁剪"></a>Canvas 图像裁剪</h2><p>裁剪用于隐藏部分我们不想看到的图形</p><p>Canvas 中的裁剪和 Photoshop 中的裁剪不一样，Photoshop 中的裁剪针对的是图形，而 Canvas 中的裁剪针对的是画布本身</p><p>Canvas 中的裁剪只有一种方法，就是根据路径来裁剪</p><p>比如我们有一个画布，画布上有一张图片和一个五角星的路径</p><p><strong>语法</strong><br><code>void ctx.clip();</code><br><code>void ctx.clip(fillRule);</code><br><code>void ctx.clip(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">裁剪算法，用于设置判断一个点是在路径内还是在路径外，可选的值有</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕原则，默认的原则</td></tr><tr><td align="left">“evenodd”: 奇偶环绕原则</td><td align="left"></td></tr><tr><td align="left">path</td><td align="left">需要剪切的 Path2D 路径</td></tr></tbody></table><p>先画一个路径，然后调用 clip() 说我要裁剪接下来的图形，而且终身有效</p><p>如果不需要了，那么可以在调用 clip() 前先调用 save() 保存状态，然后再使用完后调用 </p><p>restore() 恢复状态</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c2   = document.getElementById("canvas-2");var ctx2 = c2.getContext("2d");ctx2.save();ctx2.arc(100, 100, 75, 0, Math.PI*2, false);ctx2.clip();ctx2.fillRect(0, 0, 100,100);ctx2.fillStyle="green";ctx2.fillRect(100, 100, 100,100);ctx2.restore();ctx2.fillStyle="red";ctx2.fillRect(40, 40, 30,30);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_60.png"></p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
