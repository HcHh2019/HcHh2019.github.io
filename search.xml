<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Canvas基础</title>
      <link href="posts/f7d3.html"/>
      <url>posts/f7d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas-创建"><a href="#Canvas-创建" class="headerlink" title="Canvas 创建"></a>Canvas 创建</h2><p>因为 canvas 是 HTML 中的一个元素，所以创建一个 <code>&lt;canvas&gt;</code> 很简单</p><pre><code>&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;</code></pre><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的唯一名称</td></tr><tr><td align="left">width</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的宽度，默认为 300px</td></tr><tr><td align="left">height</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的高度，默认为 150px</td></tr><tr><td align="left">style</td><td align="left">指定画布 <code>&lt;canvas&gt;</code> 的样式</td></tr></tbody></table><hr><h2 id="Canvas-绘图上下文"><a href="#Canvas-绘图上下文" class="headerlink" title="Canvas 绘图上下文"></a>Canvas 绘图上下文</h2><p><code>&lt;canvas&gt;</code> 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成<br><code>&lt;canvas&gt;</code> 元素有一个叫做 <code>getContext()</code> 的方法</p><pre><code>canvas.getContext(contextType, contextAttributes);</code></pre><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">contextType</td><td align="left">上下文类型，一个字符串，值可以是 2d</td></tr><tr><td align="left">contextAttributes</td><td align="left">创建上下文时设置属性，一个字典对象，默认为空即可</td></tr></tbody></table><p>对于 2d 图像而言，可以使用下面的代码获取渲染上下文</p><pre><code>var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');</code></pre><hr><h2 id="Canvas-单位和坐标体系"><a href="#Canvas-单位和坐标体系" class="headerlink" title="Canvas 单位和坐标体系"></a>Canvas 单位和坐标体系</h2><p>既然我们已经能够使用 <code>getContext("2d")</code> 获取渲染上下文对象，那么我们就可以使用这个对象来绘制图形了。比如我们要绘制一个矩形 rect，那么我们要怎么做呢，首先，我们要确定一个起始点 (一般是左上角),然后确定矩形的长和宽，就像下面这样</p><p>1.确定起点位置(x1,y1)，例如(100,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_1.png"></p><p>2.确定矩形的长和宽(width,height), 例如(200,100)<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_2.png"></p><p>大家有没有发现，如果加上起始坐标，其实就是确定了终点坐标(x2,y2)<br>x2 = x1 + width  = 100 + 200 = 300<br>y2 = y1 + height = 100 + 100 = 200</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_3.png"></p><hr><h2 id="Canvas-绘制矩形"><a href="#Canvas-绘制矩形" class="headerlink" title="Canvas 绘制矩形"></a>Canvas 绘制矩形</h2><p>渲染上下文 ( ctx ) 提供了 <code>strokeRect()</code> 方法用来绘制一个矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/%E4%B8%8B%E8%BD%BD.png"></p><p>我们可以重复使用 <code>strokeRect()</code> 方法绘制多个矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeRect(50,50,100,100);ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_5.png"></p><p>绘图顺序:后来画的会覆盖之前画的<br>超出画板大小后图像将不显示</p><hr><h2 id="Canvas-画笔-strokeStyle"><a href="#Canvas-画笔-strokeStyle" class="headerlink" title="Canvas 画笔 strokeStyle"></a>Canvas 画笔 strokeStyle</h2><p><code>ctx.strokeStyle</code> 属性用于设置画笔(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.strokeStyle = color;</code><br><code>ctx.strokeStyle = gradient;</code><br><code>ctx.strokeStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>例如下面这些颜色都是 橙色</p><p><code>ctx.strokeStyle = "orange";</code><br><code>ctx.strokeStyle = "#FFA500";</code><br><code>ctx.strokeStyle = "rgb(255,165,0)";</code><br><code>ctx.strokeStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色边框的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_6.png"></p><p><code>strokeStyle</code> 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "green";ctx.strokeRect(0,0,200,200);ctx.strokeRect(0,0,100,100);ctx.strokeStyle = "red";ctx.strokeRect(50,50,100,100);ctx.strokeStyle = "#00ff00";ctx.strokeRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下<br><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_7.png"></p><hr><h2 id="Canvas-填充矩形-fillRect"><a href="#Canvas-填充矩形-fillRect" class="headerlink" title="Canvas 填充矩形 fillRect"></a>Canvas 填充矩形 fillRect</h2><p><code>fillRect()</code> 方法和 <code>strokeRect()</code> 方法一样，不同的是它会使用特定的颜色(默认为黑色)来填充矩形</p><p><code>strokeRect(x, y, width, height)</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">起始点 x 坐标</td></tr><tr><td align="left">y</td><td align="left">起始点 y 坐标</td></tr><tr><td align="left">width</td><td align="left">矩形长度</td></tr><tr><td align="left">height</td><td align="left">矩形高度</td></tr></tbody></table><p>例如下面的代码在 (50,50) 开始绘制一个 200 x 50 且填充黑色的矩形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_8.png"></p><p>我们可以重复使用 <code>fillRect()</code> 方法绘制多个填充矩形</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillRect(0,0,200,200);ctx.fillRect(0,0,100,100);ctx.fillRect(50,50,100,100);ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_9.png"><br>全部粘在一起，黑乎乎的….<br>这就是绘图顺序,后来画的会覆盖之前画的</p><hr><h2 id="Canvas-填充样式-fillStyle"><a href="#Canvas-填充样式-fillStyle" class="headerlink" title="Canvas 填充样式 fillStyle"></a>Canvas 填充样式 fillStyle</h2><p><code>ctx.fillStyle</code> 属性用于设置填充(绘制图形)颜色或者样式</p><p>默认值是黑色 #000 (black)</p><p>语法<br><code>ctx.fillStyle = color;</code><br><code>ctx.fillStyle = gradient;</code><br><code>ctx.fillStyle = pattern;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">一个字符串颜色值，可以是任意的 CSS 颜色值，比如 red 、#000 等</td></tr><tr><td align="left">gradient</td><td align="left">一个渐变，是一个 CanvasGradient 对象 ( 线性渐变或放射性渐变)，我们后面会讲</td></tr><tr><td align="left">pattern</td><td align="left">一个绘画对象，是一个 CanvasPattern 对象 ( 可重复的图片)，可以是一张图片，或者另一个画布</td></tr></tbody></table><p>下面这些颜色都是 橙色</p><p><code>ctx.fillStyle = "orange";</code><br><code>ctx.fillStyle = "#FFA500";</code><br><code>ctx.fillStyle = "rgb(255,165,0)";</code><br><code>ctx.fillStyle = "rgba(255,165,0,1)"</code></p><p>例如我们要绘制一个绿色的矩形，可以这么做</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.strokeRect(50,50,200,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_10.png"></p><p>fillStyle 一旦设置就会成为接下来的默认画笔，除非再次调用设置为其它的值</p><pre><code>&lt;canvas id="canvas-2" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillRect(0,0,200,200);ctx.fillStyle = "#ccc";ctx.fillRect(0,0,100,100);ctx.fillStyle = "red";ctx.fillRect(50,50,100,100);ctx.fillStyle = "#00ff00";ctx.fillRect(250,250,100,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_11.png"></p><p>绘制调色器<br>我们可以使用两层 for 循环来绘制方格阵列，每个方格不同的颜色</p><p>用两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变</p><pre><code>&lt;canvas id="canvas-3" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var ctx = document.getElementById('canvas-3').getContext('2d');for (var i=0;i&lt;6;i++){    for (var j=0;j&lt;6;j++){    ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' +                     Math.floor(255-42.5*j) + ',0)';    ctx.fillRect(j*25,i*25,25,25);    }}&lt;/script&gt;</code></pre><p>运行效果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_12.png"></p><hr><h2 id="Canvas-绘制路径"><a href="#Canvas-绘制路径" class="headerlink" title="Canvas 绘制路径"></a>Canvas 绘制路径</h2><p>步骤:<br>1.首先， <code>beginPath()</code> 这个操作是可选的，如果最后线段要闭合，那么这个就是必选<br>2.其次要做的就是确定起点坐标 <code>moveTo(x0,y0)</code>，也就是先把画笔移动到某个位置，然后在开始画画<br>3.然后确定好下一个位置 (x1,y1) <code>lineTo(x1,y1)</code><br>4.如果我们要将图形闭合，则还要绘制到起始点 <code>closePath()</code></p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ctx.beginPath()</td><td align="left">开始一个新路径的</td></tr><tr><td align="left">ctx.moveTo(x,y)</td><td align="left">将新路径的起始点移动到坐标 (x，y)</td></tr><tr><td align="left">ctx.lineTo(x,y)</td><td align="left">使用直线连接子路径的终点到坐标(x，y)，并不会真正地绘制为什么说是终点，如果不再继续调用 lineTo() 那么它就是终点了不是</td></tr><tr><td align="left">ctx.closePath()</td><td align="left">将画笔返回到当前子路径起始点</td></tr><tr><td align="left">ctx.stroke()</td><td align="left">根据当前的画线样式，绘制当前或已经存在的路径</td></tr></tbody></table><p>下面的代码绘制了一个三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_13.png"></p><p>不调用 <code>closePath()</code> 则不会闭合图形</p><pre><code>&lt;canvas id="canvas-11" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-11");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_14.png"></p><p>看一个多次调用 moveTo() 的例子</p><pre><code>&lt;canvas id="canvas-4" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");ctx.strokeStyle = "green"ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.stroke();ctx.strokeStyle = "yellow"ctx.moveTo(100,100);ctx.lineTo(20,200);ctx.lineTo(220,220);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_15.png"></p><hr><h2 id="Canvas-按路径绘制圆弧"><a href="#Canvas-按路径绘制圆弧" class="headerlink" title="Canvas 按路径绘制圆弧"></a>Canvas 按路径绘制圆弧</h2><p>Canvas 中的 2D 渲染上下文文提供了 <code>arc()</code> 方法用于绘制圆弧<br><code>void ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);</code></p><table><thead><tr><th align="left">x</th><th align="left">圆弧中心（圆心）的 x 轴坐标</th></tr></thead><tbody><tr><td align="left">y</td><td align="left">圆弧中心（圆心）的 y 轴坐标</td></tr><tr><td align="left">radius</td><td align="left">圆弧的半径</td></tr><tr><td align="left">startAngle</td><td align="left">圆弧的起始点， x轴方向开始计算，单位以弧度表示</td></tr><tr><td align="left">endAngle</td><td align="left">圆弧的终点， 单位以弧度表示</td></tr><tr><td align="left">anticlockwise</td><td align="left">可选， bool 类型 ，如果为 true，逆时针绘制圆弧，反之，顺时针绘制，默认为 false</td></tr></tbody></table><p>圆弧，就是以某个点 (x0,y0) 作为圆心(红色)，以两个角度作为起始(startAngle)和结束角度(enddAngle)，绘制的一定大小(radius) 的半圆</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_16.png"></p><p>如果开始角度为 0 ，而结束角度为 2 * Math.PI ，那么就是一个圆了</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_17.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆弧，圆弧的起始角度为 30，结束角度为 75</p><pre><code>&lt;canvas id="canvas-1" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,30 * Math.PI /180,75 * Math.PI /180 );ctx.stroke();&lt;/script&gt;</code></pre><p>注意： <code>arc()</code> 方法绘制出来的是虚拟路径，需要使用 <code>stroke()</code> 实体化</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_18.png"></p><p>下面的代码以 (100,100) 作为圆心, 绘制一个半径为 50 的圆</p><pre><code>&lt;canvas id="canvas-2" width="300" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.strokeStyle = "#9013FE"ctx.beginPath();ctx.arc(100,100,50,0,2*Math.PI);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_19.png"></p><hr><h2 id="Canvas-填充路径-fill"><a href="#Canvas-填充路径-fill" class="headerlink" title="Canvas 填充路径 fill()"></a>Canvas 填充路径 fill()</h2><p>绘制各种路径，如果路径是闭合的 (调用了 closePath() 方法)，那么还可以使用特定的颜色来填充它</p><p><code>fill()</code> 方法根据当前的填充样式，填充当前或已存在的路径，可选的填充方法有非零环绕或者奇偶环绕</p><p><code>void ctx.fill();</code><br><code>void ctx.fill(fillRule);</code><br><code>void ctx.fill(path, fillRule);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fillRule</td><td align="left">一种算法，决定点是在路径内还是在路径外，允许的值：</td></tr><tr><td align="left">“nonzero”:</td><td align="left">非零环绕规则， 默认的规则</td></tr><tr><td align="left">“evenodd”:</td><td align="left">奇偶环绕规则</td></tr><tr><td align="left">path</td><td align="left">可选，需要填充的 Path2D 路径</td></tr></tbody></table><p><strong>非零环绕或者奇偶环绕</strong><br>当路径非常复杂时，怎么个复杂法呢，就是纵横交错，比如下面张路径</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_20.png"></p><p>非零环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_21.png"></p><p>奇偶环绕填充方式如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_22.png"></p><p>下面的范例绘画了一个绿色的三角形</p><pre><code>&lt;canvas id="canvas-1" width="400" height="300"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.fillStyle="green"ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(200,20);ctx.lineTo(120,120);ctx.closePath();ctx.fill();ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_23.png"></p><p><strong>注意</strong><br>可以从上图中看到，填充的时候只是填充内部，边框还是存在的，这就是路径绘图与其它方法的不同</p><hr><h2 id="Canvas-路径线段厚度-lineWidth"><a href="#Canvas-路径线段厚度-lineWidth" class="headerlink" title="Canvas 路径线段厚度 lineWidth"></a>Canvas 路径线段厚度 lineWidth</h2><p>前面我们绘制路径时使用的都是默认粗细，默认值为 1.0<br>其实 Canvas 还提供了 <code>lineWidth</code> 属性用来设置路径的粗细</p><p><code>lineWidth</code> 属性用于设置线段厚度的属性 ( 即线段的宽度 )<br>当获取属性值时，它可以返回当前的值 ( 默认值是1.0 )<br>当给属性赋值时， 0、 负数、 Infinity 和 NaN 都会被忽略；除此之外，都会被赋予一个新值<br><code>ctx.lineWidth = value;</code></p><p>下面的代码使用 lineWidth 属性设置线段的宽度</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_24.png"></p><hr><h2 id="Canvas-线条末端样式-lineCap"><a href="#Canvas-线条末端样式-lineCap" class="headerlink" title="Canvas 线条末端样式 lineCap"></a>Canvas 线条末端样式 lineCap</h2><p>绘制线条时，线条起始和终点的默认演示是平齐的一条线，当然我们可以通过属性 lineCap 改变它<br>Canvas 提供了三种线条末端样式，分别是 butt 、round 、square<br>它们的表现如下图</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_25.png"></p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的<br>中间的是 round 的效果，端点处加上了半径为一半线宽的半圆<br>右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块</p><p><strong>Canvas lineCap 属性</strong></p><p><strong>语法</strong><br>ctx.lineCap = “butt”;<br>ctx.lineCap = “round”;<br>ctx.lineCap = “square”;</p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">butt</td><td align="left">线段末端以方形结束</td></tr><tr><td align="left">round</td><td align="left">线段末端以圆形结束</td></tr><tr><td align="left">square</td><td align="left">线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域</td></tr></tbody></table><p>下面的代码使用 lineCap 属性绘制以圆形结尾的线段</p><pre><code>&lt;canvas id="canvas-1" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.beginPath();ctx.moveTo(50,50);ctx.lineWidth = 15;ctx.lineCap = "round";ctx.lineTo(100, 50);ctx.stroke();&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_26.png"></p><hr><h2 id="Canvas-线条与线条间接合处的样式"><a href="#Canvas-线条与线条间接合处的样式" class="headerlink" title="Canvas 线条与线条间接合处的样式"></a>Canvas 线条与线条间接合处的样式</h2><p>多次调用 <code>lineTo()</code> 方法绘制多个线条组成路径时，我们会发现线条与线条之间接合处的样式有时候不一样</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_27.png"></p><p>Canvas 把这个接合处的样式称之为 lineJoin 并提供了 lineJoin 属性用于设置它</p><p>ctx.lineJoin 是用来设置 2 个长度不为 0 的相连部分 ( 线段，圆弧，曲线 ) 如何连接在一起的属性</p><p><strong>语法</strong><br><code>ctx.lineJoin = "bevel";</code><br><code>ctx.lineJoin = "round";</code><br><code>ctx.lineJoin = "miter";</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">round</td><td align="left">通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状，圆角的半径是线段的宽度</td></tr><tr><td align="left">bevel</td><td align="left">在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角</td></tr><tr><td align="left">miter</td><td align="left">默认，通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域,这个设置可以通过 <code>miterLimit</code> 属性设置</td></tr></tbody></table><p><strong>注意</strong><br>如果 2 个相连部分在同一方向，那么 lineJoin 不会产生任何效果，因为在那种情况下不会出现连接区域</p><p>我们可以使用 for 循环绘制了 3 条不同的路径，演示 lineJoin 属性 3 种不同的设置</p><pre><code>&lt;canvas id="canvas-2" width="300" height="150"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var lineJoin = ['round','bevel','miter'];ctx.lineWidth = 10;for (var i = 0; i &lt; lineJoin.length; i++) {ctx.lineJoin = lineJoin[i];ctx.beginPath();ctx.moveTo(50,50+i*40);ctx.lineTo(25,45+i*40);ctx.lineTo(75,10+i*40);ctx.lineTo(115,45+i*40);ctx.lineTo(155,10+i*40);ctx.stroke();}&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_28.png"></p><hr><h2 id="Canvas-线性渐变-LinearGradient"><a href="#Canvas-线性渐变-LinearGradient" class="headerlink" title="Canvas 线性渐变 ( LinearGradient )"></a>Canvas 线性渐变 ( LinearGradient )</h2><p>线性渐变 ( LinearGradient ) 就是从一个颜色值直线性的渐变到另一个颜色值<br><code>createLinearGradient()</code> 创建一个沿参数坐标指定的直线的渐变，并返回一个渐变 CanvasGradient 对象</p><p><strong>语法</strong><br><code>CanvasGradient ctx.createLinearGradient(x0, y0, x1, y1);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">x0</td><td align="left">起点的 x 轴坐标</td></tr><tr><td align="left">y0</td><td align="left">起点的 y 轴坐标</td></tr><tr><td align="left">x1</td><td align="left">终点的 x 轴坐标</td></tr><tr><td align="left">y1</td><td align="left">终点的 y 轴坐标</td></tr></tbody></table><p>线性渐变的使用方法<br>1.使用 <code>createLinearGradient()</code> 方法创建一个指定了开始和结束点的 CanvasGradient 对象<br>2.创建成功后，可以使用 <code>CanvasGradient.addColorStop()</code>方法添加起始色标<br>3.然后把渐变对象赋值给 <code>strokeStyle</code> 或者 <code>fillStyle</code> 属性</p><p>使用 createLinearGradient() 创建一个线性渐变</p><pre><code>&lt;canvas id="canvas-1" width="400" height="200"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.lineWidth = 8var gradient = ctx.createLinearGradient(0,0,200,0);gradient.addColorStop(0,"green");gradient.addColorStop(1,"blue");ctx.fillStyle = gradient;ctx.fillRect(10,10,200,100);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_29.png"></p><hr><h2 id="Canvas-绘制文本-fillText"><a href="#Canvas-绘制文本-fillText" class="headerlink" title="Canvas 绘制文本 fillText"></a>Canvas 绘制文本 fillText</h2><p><code>fillText()</code> 在 (x, y) 位置填充文本 text。如果选项的第四个参数提供了最大宽度，文本会进行缩放以适应最大宽度</p><p><strong>语法</strong><br><code>void ctx.fillText(text, x, y [, maxWidth]);</code></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">text</td><td align="left">要绘制的文本</td></tr><tr><td align="left">x</td><td align="left">文本起始点的 x 轴坐标</td></tr><tr><td align="left">y</td><td align="left">文本起始点的 y 轴坐标</td></tr><tr><td align="left">maxWidth</td><td align="left">可选，需要绘制的最大宽度。如果指定了值，并且经过计算字符串的宽度比最大宽度还要宽，字体为了适应会使用一个水平缩小的字体或者小号的字体</td></tr></tbody></table><p>我们可以使用 fillStyle 设置全局填充颜色，当然了，这个肯定也会影响到文本的颜色<br>下面的代码绘制了一个绿色的文本</p><pre><code>&lt;canvas id="canvas-2" width="300" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");ctx.fillStyle = "green";ctx.fillText("简单教程，简单编程",20,20);ctx.fillText("https://www.twle.cn",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_30.png"></p><hr><h2 id="Canvas-字体-font"><a href="#Canvas-字体-font" class="headerlink" title="Canvas 字体 font"></a>Canvas 字体 font</h2><p><code>ctx.font</code> 属性用于绘制文字时，设置当前字体样式的属性<br>font 的使用和 CSS font 规范相同的字符串值。 默认字体是 10px sans-serif</p><p><strong>语法</strong><br><code>ctx.font = value;</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">符合 CSS font 语法的字符串。默认字体是 10px sans-serif</td></tr></tbody></table><p>我们先来看看一般的使用方法，将字体为 48px 大小的微软雅黑</p><pre><code>&lt;canvas id="canvas-1" width="500" height="100"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-1");var ctx = c.getContext("2d");ctx.font = "48px Microsoft YaHei"ctx.fillText("简单教程，简单编程",50,50);&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_31.png"></p><hr><h2 id="Canvas-绘制图像-drawImage"><a href="#Canvas-绘制图像-drawImage" class="headerlink" title="Canvas 绘制图像 drawImage()"></a>Canvas 绘制图像 drawImage()</h2><p>接下来的范例，我们将使用下面这张图片</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png"><br>图片的宽高是 160x160<br>图片的 URL 地址是<br><a href="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png">https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_32.png</a><br>一旦我们获得了一张图片，我们就可以使用 <code>drawImage()</code> 方法将它绘制到 Canvas 上</p><p><strong>怎么绘制图片</strong><br>在我们继续讲解 <code>drawImage()</code> 方法之前，我们先来讲讲如何绘制图片<br>图片本身就是一个矩形，它有自己的左上角 <strong>(0,0)</strong> 和宽高 <strong>( w,h )</strong></p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_33.png"></p><p>我们可以将整张图片绘制到画布上，也可以将图片的一部分绘制到画布上</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_34.png"></p><p>比如我们可以从图片的 <strong>(sx,sy)</strong> 点开始截取宽高为 <strong>(sWidth,sHeight)</strong> 的一部分绘制到画布上</p><p>如果 <strong>sx=0,sy=0</strong> 且 <strong>sWidth=width,sHeight=height</strong> 那么就是整张图片绘制到画布上</p><p>我们再来看看画布，画布也是一个矩形，它也有自己的宽高，我们把图片绘制到画布的时候必须指定从哪个点 <strong>(dx,dy)</strong> 开始画</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_35.png"></p><p>如果指定的点 <strong>dx=0,dy=0</strong> 其实就是从屏幕的左上角开始画起</p><p>当然，这样就是可能占据画布的大部分空间，也可能会把其它已经在画布上的东西遮住</p><p>所以，也可以在画布上指定区域 <strong>(dWidth,dHeight)</strong> ,只将图片画到这个区域里</p><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_36.png"></p><p>如果指定了 <strong>(dWidth,dHeight)</strong> 因为它可能和 <strong>(sWidth,sHeight)</strong> 不一样</p><p>可能更小，也可能更大，可能更高，也可能更窄，那么就会涉及到图片的缩放问题</p><p>如果 **(dWidth,dHeight)**比图片的宽高大,那么图片将放大,反之图片将缩小</p><p>Canvas 只有一种缩放规则，那就是填满指定的区域 <strong>(dWidth,dHeight)</strong></p><p>接下来我们看看 Canvas 提供的绘制图片的方法 drawImage()</p><p><strong>语法</strong><br><code>void ctx.drawImage(image, dx, dy);</code><br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code><br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></p><table><thead><tr><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">image</td><td align="left">绘制到画板的图像资源，可以是任何的 canvas 图像源 ( CanvasImageSource)，例如：HTMLImageElement，HTMLVideoElement，或者 HTMLCanvasElement</td></tr><tr><td align="left">dx</td><td align="left">绘制图像时起点的 X 轴位置</td></tr><tr><td align="left">dy</td><td align="left">绘制图像时起点的 Y 轴位置</td></tr><tr><td align="left">dWidth</td><td align="left">在目标画布上绘制图像的宽度。 允许对绘制的图像进行缩放，如果不传递，绘制图像 如果不说明， 在绘制时图片宽度不会缩放</td></tr><tr><td align="left">dHeight</td><td align="left">在目标画布上绘制图像的高度。 允许对绘制的图像进行缩放。 如果不说明， 在绘制时图片高度不会缩放</td></tr><tr><td align="left">sx</td><td align="left">截取图像时指定起点的 X 坐标</td></tr><tr><td align="left">sy</td><td align="left">截取图像时指定起点的 Y 坐标</td></tr><tr><td align="left">sWidth</td><td align="left">图像截取的高度</td></tr><tr><td align="left">sHeight</td><td align="left">图像截取的宽度</td></tr></tbody></table><p><strong>因为该方法有三种形式，那么我们就分三个范例来演示</strong></p><ol><li><p>在画板的指定点绘制整张图片<br><code>void ctx.drawImage(image, dx, dy);</code><br>下面的范例从画板的 (50,50) 开始绘制一整张图片</p><pre><code> &lt;canvas id="canvas-1" width="400" height="300" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-1"); var ctx = c.getContext("2d"); var img = document.createElement("img"); img.onload = function() {     ctx.drawImage(this, 50, 50); } img.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_37new.png"></p><p>如果画布比图片小，比如画布的宽高为 <strong>100x100</strong> 那么多出来的图片会被裁掉(不显示)</p><pre><code>&lt;canvas id="canvas-2" width="100" height="100" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-2");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 30, 30);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_38.png"></p><ol start="2"><li><p>在画板上指定位置和指定区域绘制整张图片<br><code>void ctx.drawImage(image, dx, dy, dWidth, dHeight);</code></p><pre><code> &lt;canvas id="canvas-3" width="300" height="200" style="border:1px solid #ccc"&gt; &lt;/canvas&gt; &lt;script&gt; var c   = document.getElementById("canvas-3"); var ctx = c.getContext("2d"); var img2 = document.createElement("img"); img2.onload = function() {     ctx.drawImage(this, 50, 50,50,50); } img2.src = "https://www.twle.cn/static/i/meimei_160x160.png"; &lt;/script&gt;</code></pre></li></ol><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_39.png"></p><p>大家看到没有，此时的图片会自己缩放到指定大小</p><p>如果我们指定的区域比例和原图不一样是什么情况呢？比如 <strong>(50,250)</strong></p><pre><code>&lt;canvas id="canvas-4" width="300" height="300" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-4");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50, 50,50,250);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_40.png"></p><p>可以看到图片被拉伸到填满区域了…类似的，如果宽度比较大，而高度比较小，就会水平拉伸</p><ol start="3"><li>截取图片的一部分绘制到画板上的指定区域<br><code>void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></li></ol><p>下面的代码以距离图片左上角位置 (50,50) 截取宽高为 50x50 的部分图片绘制到画板上</p><p>绘制点为 (50,50)，绘制宽高为 (50,150)</p><pre><code>&lt;canvas id="canvas-5" width="300" height="200" style="border:1px solid #ccc"&gt;&lt;/canvas&gt;&lt;script&gt;var c   = document.getElementById("canvas-5");var ctx = c.getContext("2d");var img2 = document.createElement("img");img2.onload = function() {    ctx.drawImage(this, 50,50,50,50,50,50,50,150);}img2.src = "https://www.twle.cn/static/i/meimei_160x160.png";&lt;/script&gt;</code></pre><p><img src="https://gitee.com/OxOYYZi/picgo/raw/master/img/canvas_41.png"></p><p>图片仍然被拉伸了</p><p><strong>注意</strong><br>在画板上绘制图片的时候绘制区域最好和图片大小相适应，不然会拉伸图片</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> canvas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试页</title>
      <link href="posts/34d2.html"/>
      <url>posts/34d2.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="噢哈哈哈"><a href="#噢哈哈哈" class="headerlink" title="噢哈哈哈"></a>噢哈哈哈</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
